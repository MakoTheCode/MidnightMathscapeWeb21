<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Teacher Login | St. Michael Academy</title>
    <link rel="stylesheet" href="mainCSS.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
    <style>
        .disabled-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 10000;
            justify-content: center;
            align-items: center;
            color: white;
            font-family: 'Inter', sans-serif;
            text-align: center;
        }
        
        .disabled-message {
            background: #8A1532;
            padding: 40px;
            border-radius: 10px;
            max-width: 400px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }
        
        .disabled-message h2 {
            margin-bottom: 20px;
            color: white;
        }
        
        .disabled-message p {
            margin-bottom: 20px;
            line-height: 1.5;
        }
        
        .disabled-message button {
            background: #501121;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1rem;
        }
    </style>
</head>
<body>
    <!-- Disabled Account Overlay -->
    <div class="disabled-overlay" id="disabledOverlay">
        <div class="disabled-message">
                <h2><i class="fas fa-user-slash"></i> Account Disabled</h2>
                <p id="disabledOverlayReason">This account has been disabled by the administrator.</p>
                <p>Please contact your system administrator to regain access.</p>
                <button onclick="location.reload()">Try Again</button>
            </div>
    </div>

    <!-- Hidden debug output for disabled-account checks (only visible during local testing) -->
    <pre id="disabledDebug" style="display:none;position:fixed;bottom:10px;left:10px;right:10px;max-height:40vh;overflow:auto;background:#111;color:#0f0;padding:10px;border-radius:6px;z-index:10001;font-size:12px;"></pre>

    <div class="container-wrap">
        <div class="-main">
            <div class="main-image">
                <img src="images/main image.PNG" alt="logo" width="550" height="550" title="St. Michael Academy">
            </div>
        </div>

        <div class="-side">
            <div class="flip-container">
                <div class="flip-inner">
                    <div class="flip-front">
                        <img src="images/academy logo.jpg" alt="logo" width="60" height="55" title="St. Michael Academy">
                        <h2>Teacher Login</h2>
                        <p>Track your student's progress and performance inside Midnight Mathscape.</p>
                        <h3>__________________________________</h3>
                        
                        <form id="loginFormElement">
                            <a>Email</a>
                            <div class="input-group">
                                <i class="fas fa-envelope"></i>
                                <input type="email" id="loginEmail" placeholder="Email" required>
                            </div>
                            <span class="error-message" id="loginEmailError"></span>
                            
                            <a>Password</a>
                            <div class="input-group">
                                <i class="fas fa-lock"></i>
                                <input type="password" id="loginPassword" placeholder="Password" required>
                            </div>
                            <span class="error-message" id="loginPasswordError"></span>
                            
                            <button type="submit">Login</button>
                        </form>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-database-compat.js"></script>
    <script>
  // helper: sha256 -> hex (same as settingsPage)
    async function sha256hex(text) {
        const enc = new TextEncoder();
        const data = enc.encode(text);
        const hash = await crypto.subtle.digest('SHA-256', data);
        return Array.from(new Uint8Array(hash)).map(b=>b.toString(16).padStart(2,'0')).join('');
    }

    // Firebase configuration
    const firebaseConfig = {
        apiKey: "AIzaSyDNp5EX5oKWWIFWjQ5o5e5MnaVZTgFVLwo",
        authDomain: "midnightmathscape-e8e70.firebaseapp.com",
        databaseURL: "https://midnightmathscape-e8e70-default-rtdb.firebaseio.com",
        projectId: "midnightmathscape-e8e70",
        storageBucket: "midnightmathscape-e8e70.firebasestorage.app",
        messagingSenderId: "643428213528",
        appId: "1:643428213528:web:e14dfea52725d1b647746d",
        measurementId: "G-FTYBFHGQ4T"
    };

    // Initialize Firebase
    const app = firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const db = firebase.firestore();
    const rdb = firebase.database();

    // List of special emails that are allowed to override disabled flags.
    // Only add a very small set of trusted addresses here. Admins in general are NOT allowed to bypass.
    const SPECIAL_OVERRIDE_EMAILS = [
        'admin@stmichael.com',
        'admin@stmichael.com.ph'
        
    ];
    // When true, any DB/query error during disabled checks will block login (fail-closed).
    // When false (default) DB/query errors will be ignored and login continues (fail-open).
    const FAIL_CLOSED_ON_ERROR = false;

    // Function to check if account is disabled
    // Check whether an account is disabled. Accepts auth UID and optional email.
    // If a disabled marker is found, this function will also set the disabled overlay reason text.
    async function isAccountDisabled(uid, email=null) {
        const diagnostics = [];
        let sawError = null;
        const lower = email ? String(email).toLowerCase() : null;

        // Allow explicit special override emails to bypass the disabled checks
        if (lower && SPECIAL_OVERRIDE_EMAILS.includes(lower)) {
            diagnostics.push({check: 'special_override', email: lower});
            console.warn('isAccountDisabled: special override email, allowing login', lower);
            return false;
        }

        try {
            // 1) Check disabledAccounts collection by uid (doc id)
            if (uid) {
                try {
                    const disabledDoc = await db.collection('disabledAccounts').doc(uid).get();
                    diagnostics.push({check: 'disabledAccounts.doc(uid)', uid, exists: disabledDoc.exists});
                    if (disabledDoc.exists) {
                        const reasonEl = document.getElementById('disabledOverlayReason');
                        if (reasonEl) reasonEl.textContent = 'This account is totally disabled. (disabledAccounts by uid)';
                        console.warn('isAccountDisabled: disabledAccounts doc found for uid', uid, disabledDoc.data());
                        return true;
                    }
                } catch (e) {
                    diagnostics.push({check: 'disabledAccounts.doc(uid).error', error: String(e)});
                    sawError = e;
                }
            }

            // 2) Check users collection document by uid
            if (uid) {
                try {
                    const userDoc = await db.collection('users').doc(uid).get();
                    diagnostics.push({check: 'users.doc(uid)', uid, exists: userDoc.exists});
                    if (userDoc.exists && userDoc.data().disabled === true) {
                        const reasonEl = document.getElementById('disabledOverlayReason');
                        if (reasonEl) reasonEl.textContent = 'This account is totally disabled. (users doc by uid)';
                        console.warn('isAccountDisabled: users doc for uid marked disabled', uid, userDoc.data());
                        return true;
                    }
                } catch (e) {
                    diagnostics.push({check: 'users.doc(uid).error', error: String(e)});
                    sawError = e;
                }
            }

            // 3) Additional checks by email
            if (email) {
                // a) Check disabledAccounts collection for a document with id == email or id == lower
                try {
                    const docByEmail = await db.collection('disabledAccounts').doc(lower).get();
                    diagnostics.push({check: 'disabledAccounts.doc(lower)', id: lower, exists: docByEmail.exists});
                    if (docByEmail.exists) {
                        const reasonEl = document.getElementById('disabledOverlayReason');
                        if (reasonEl) reasonEl.textContent = 'This account is totally disabled. (disabledAccounts by email id)';
                        console.warn('isAccountDisabled: disabledAccounts doc found by email id', lower, docByEmail.data());
                        return true;
                    }
                } catch (e) { diagnostics.push({check: 'disabledAccounts.doc(lower).error', error: String(e)}); sawError = e; }

                try {
                    const docByEmailOrig = await db.collection('disabledAccounts').doc(email).get();
                    diagnostics.push({check: 'disabledAccounts.doc(email)', id: email, exists: docByEmailOrig.exists});
                    if (docByEmailOrig.exists) {
                        const reasonEl = document.getElementById('disabledOverlayReason');
                        if (reasonEl) reasonEl.textContent = 'This account is totally disabled. (disabledAccounts by email id)';
                        console.warn('isAccountDisabled: disabledAccounts doc found by email id', email, docByEmailOrig.data());
                        return true;
                    }
                } catch (e) { diagnostics.push({check: 'disabledAccounts.doc(email).error', error: String(e)}); sawError = e; }

                // b) Check disabledAccounts collection where email field equals lower
                try {
                    const daQ = await db.collection('disabledAccounts').where('email', '==', lower).limit(1).get();
                    diagnostics.push({check: 'disabledAccounts.where(email==lower)', lower, count: daQ.size});
                    if (!daQ.empty) {
                        const reasonEl = document.getElementById('disabledOverlayReason');
                        if (reasonEl) reasonEl.textContent = 'This account is totally disabled. (disabledAccounts by email field)';
                        console.warn('isAccountDisabled: disabledAccounts entry found for email', lower, daQ.docs.map(d=>d.id));
                        return true;
                    }
                } catch (e) { diagnostics.push({check: 'disabledAccounts.where.email.error', error: String(e)}); sawError = e; }

                // c) Check Firestore users by email (try lower and original)
                try {
                    let q = await db.collection('users').where('email', '==', lower).limit(10).get();
                    diagnostics.push({check: 'users.where(email==lower)', lower, count: q.size});
                    if (q.empty) {
                        q = await db.collection('users').where('email', '==', String(email)).limit(10).get();
                        diagnostics.push({check: 'users.where(email==orig)', email, count: q.size});
                    }
                    if (!q.empty) {
                        for (const doc of q.docs) {
                            const d = doc.data() || {};
                            const docEmail = (d.email || '').toString().toLowerCase();
                            diagnostics.push({check: 'users.doc.check', id: doc.id, email: d.email, disabled: d.disabled});
                            if (docEmail === lower && d.disabled === true) {
                                const reasonEl = document.getElementById('disabledOverlayReason');
                                if (reasonEl) reasonEl.textContent = 'This account is totally disabled. (users by email)';
                                console.warn('isAccountDisabled: users doc for email marked disabled', doc.id, d);
                                return true;
                            }
                        }
                    }
                } catch (e) { diagnostics.push({check: 'users.where.email.error', error: String(e)}); sawError = e; }

                // d) As a last resort, check Realtime Database paths if configured
                try {
                    if (rdb) {
                        try {
                            const r1 = await rdb.ref('disabledAccounts/' + (uid || lower || '')).get();
                            diagnostics.push({check: 'rtdb.disabledAccounts.byUidOrLower', path: 'disabledAccounts/' + (uid || lower || ''), exists: r1.exists()});
                            if (r1.exists()) {
                                const reasonEl = document.getElementById('disabledOverlayReason');
                                if (reasonEl) reasonEl.textContent = 'This account is totally disabled. (rtdb disabledAccounts)';
                                console.warn('isAccountDisabled: RTDB disabledAccounts entry', r1.val());
                                return true;
                            }
                        } catch (e) { diagnostics.push({check: 'rtdb.disabledAccounts.error', error: String(e)}); sawError = e; }

                        try {
                            // scan a small prefix for email match (costly for large DBs; limited to debug)
                            const snap = await rdb.ref('disabledAccounts').orderByChild('email').equalTo(lower).limitToFirst(1).get();
                            diagnostics.push({check: 'rtdb.disabledAccounts.where.email', lower, exists: snap.exists()});
                            if (snap.exists()) {
                                const reasonEl = document.getElementById('disabledOverlayReason');
                                if (reasonEl) reasonEl.textContent = 'This account is totally disabled. (rtdb disabledAccounts by email)';
                                console.warn('isAccountDisabled: RTDB disabledAccounts entry for email', lower, snap.val());
                                return true;
                            }
                        } catch (e) { diagnostics.push({check: 'rtdb.disabledAccounts.where.error', error: String(e)}); sawError = e; }
                    }
                } catch (e) { diagnostics.push({check: 'rtdb.top.error', error: String(e)}); sawError = e; }
            }

            // If we had any Firestore/RTDB errors, decide based on FAIL_CLOSED_ON_ERROR
            if (sawError) {
                console.warn('isAccountDisabled: encountered errors during checks', sawError, diagnostics);
                const dbg = document.getElementById('disabledDebug');
                if (dbg) dbg.textContent = JSON.stringify(diagnostics, null, 2);
                if (FAIL_CLOSED_ON_ERROR) {
                    const reasonEl = document.getElementById('disabledOverlayReason');
                    if (reasonEl) reasonEl.textContent = 'Unable to verify account status; login blocked for safety.';
                    return true; // fail-closed
                }
                // fail-open: allow login when checks had errors
                return false;
            }

            // No disabled markers found and no errors
            const dbg = document.getElementById('disabledDebug');
            if (dbg) dbg.textContent = JSON.stringify(diagnostics, null, 2);
            console.debug('isAccountDisabled diagnostics:', diagnostics);
            return false;

        } catch (error) {
            console.warn('Error checking disabled status (outer):', error);
            const dbg = document.getElementById('disabledDebug');
            if (dbg) dbg.textContent = 'outer_error: ' + String(error);
            // By default we allow login on unexpected outer errors (fail-open)
            return false;
        }
    }

    // Function to redirect to appropriate page after successful validation
    async function redirectAfterValidation(user, normalizedEmail) {
        // Check if account is disabled BEFORE redirecting
    const isDisabled = await isAccountDisabled(user.uid, normalizedEmail);
        if (isDisabled) {
            const reasonEl = document.getElementById('disabledOverlayReason');
            if(reasonEl) reasonEl.textContent = 'This account is totally disabled.';
            document.getElementById('disabledOverlay').style.display = 'flex';
            await auth.signOut();
            localStorage.removeItem('fsmUser');
            return;
        }

        const idTokenResult = await user.getIdTokenResult();
        const isAdminClaim = !!(idTokenResult && idTokenResult.claims && idTokenResult.claims.admin === true);

        // If auth indicates admin -> treat as admin. Note: admin accounts are still subject to disabled checks.
        if (isAdminClaim) {
            let name = user.displayName || '';
            let role = 'admin';
            try {
                const doc = await db.collection('users').doc(user.uid).get();
                if (doc.exists) { 
                    const d = doc.data();
                    name = d.name || name; 
                    role = d.role || role; 
                }
            } catch (e) { /* ignore */ }

            const session = { uid: user.uid, email: normalizedEmail, name, role };
            localStorage.setItem('fsmUser', JSON.stringify(session));
            
            // Redirect based on admin type
            if (normalizedEmail === 'admin@stmichael.edu.ph') {
                window.location.href = 'accSecSetup.html';
            } else {
                window.location.href = 'settingsPage.html';
            }
            return;
        }

        // Auth sign-in succeeded but not admin -> treat as normal user
        try {
            const doc = await db.collection('users').doc(user.uid).get();
            if (doc.exists) {
                const d = doc.data();
                const session = { uid: user.uid, email: normalizedEmail, name: d.name || user.displayName || '', role: d.role || 'teacher' };
                localStorage.setItem('fsmUser', JSON.stringify(session));
                window.location.href = (session.role === 'admin') ? 'settingsPage.html' : 'studentList.html';
                return;
            }
        } catch (e) { /* ignore */ }

        // No Firestore doc found — create session from Auth and go to studentList
        localStorage.setItem('fsmUser', JSON.stringify({ uid: user.uid, email: normalizedEmail, name: user.displayName||'', role: 'teacher' }));
        window.location.href = 'studentList.html';
    }

    document.addEventListener('DOMContentLoaded', function() {
        const loginForm = document.getElementById('loginFormElement');

        loginForm.addEventListener('submit', async function(e) {
            e.preventDefault();

            const emailRaw = document.getElementById('loginEmail').value || '';
            const password = document.getElementById('loginPassword').value || '';
            const email = String(emailRaw).trim();
            const normalizedEmail = email.toLowerCase();

            // Clear previous errors
            document.getElementById('loginEmailError').textContent = '';
            document.getElementById('loginPasswordError').textContent = '';

            try {
                // Pre-check Firestore / disabledAccounts by email to block login early
                try {
                    const preDisabled = await isAccountDisabled(null, normalizedEmail);
                    if (preDisabled) {
                        document.getElementById('disabledOverlay').style.display = 'flex';
                        return;
                    }
                } catch(errPre){
                    console.warn('Pre-check for disabled user failed', errPre);
                }

                // Try Firebase Authentication sign-in first (admins stored in Auth)
                try {
                    const userCredential = await auth.signInWithEmailAndPassword(email, password);
                    const authUser = userCredential.user;

                    // Post-auth check: immediately verify Firestore disabled status for this uid/email.
                    // This prevents cases where Auth sign-in succeeds but Firestore marks the account disabled.
                    try {
                        const postDisabled = await isAccountDisabled(authUser.uid, normalizedEmail);
                        if (postDisabled) {
                            document.getElementById('disabledOverlay').style.display = 'flex';
                            // Ensure auth session is ended
                            await auth.signOut();
                            return;
                        }
                    } catch (e) {
                        console.warn('Post-auth disabled check failed', e);
                    }

                    // Use the validation and redirect function
                    await redirectAfterValidation(authUser, normalizedEmail);

                } catch (authErr) {
                    // If auth user not found -> fallback to Firestore-only accounts (teachers)
                    if (authErr && authErr.code === 'auth/user-not-found') {
                        const q = await db.collection('users').where('email','==', normalizedEmail).limit(1).get();
                        if (q.empty) {
                            document.getElementById('loginEmailError').textContent = 'User not found';
                            return;
                        }
                        
                        const doc = q.docs[0];
                        const user = doc.data();
                        
                        // Check if Firestore-only account is disabled
                        const isDisabled = await isAccountDisabled(doc.id, normalizedEmail);
                        if (isDisabled) {
                            const reasonEl = document.getElementById('disabledOverlayReason');
                            if(reasonEl) reasonEl.textContent = 'This account is totally disabled.';
                            document.getElementById('disabledOverlay').style.display = 'flex';
                            return;
                        }
                        
                        const pwHash = await sha256hex(password);
                        if (!user.passwordHash || user.passwordHash !== pwHash) {
                            document.getElementById('loginPasswordError').textContent = 'Incorrect password';
                            return;
                        }
                        
                        const session = { uid: doc.id, email: user.email, name: user.name || '', role: user.role || 'teacher' };
                        localStorage.setItem('fsmUser', JSON.stringify(session));
                        
                        // Redirect based on role
                        if (session.role === 'admin' || normalizedEmail === 'admin@stmichael.com') {
                            window.location.href = 'settingsPage.html';
                        } else if (normalizedEmail === 'admin@stmichael.edu.ph') {
                            window.location.href = 'accSecSetup.html';
                        } else {
                            window.location.href = 'studentList.html';
                        }
                        return;
                    }

                    // Wrong password or other auth error -> surface appropriate message
                    if (authErr && authErr.code === 'auth/wrong-password') {
                        document.getElementById('loginPasswordError').textContent = 'Incorrect password';
                        return;
                    }
                    
                    // Handle Firebase Auth disabled account error
                    if (authErr && authErr.code === 'auth/user-disabled') {
                        const reasonEl = document.getElementById('disabledOverlayReason');
                        if(reasonEl) reasonEl.textContent = 'This account is totally disabled.';
                        document.getElementById('disabledOverlay').style.display = 'flex';
                        return;
                    }
                    
                    throw authErr;
                }
            } catch (error) {
                alert('Login error: ' + (error.message || error));
            }
         });
     });
          </script>
</body>
</html>