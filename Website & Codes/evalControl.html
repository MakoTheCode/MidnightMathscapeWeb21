<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Evaluation & Control</title>

<link rel="stylesheet" href="dashboard.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"/>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

<script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-database-compat.js"></script>

<style>
body { font-family:'Inter', sans-serif; background:#f8f9fa; margin:0; }
.data-header { cursor:pointer; padding:12px; border-radius:8px; margin:6px 0; background:#fff; display:flex; justify-content:space-between; align-items:center; box-shadow:0 2px 4px rgba(0,0,0,0.05); transition:0.2s; }
.data-header.open { background:#fefefe; }
.data-header i { transition: transform 0.2s; }
.data-header.open i { transform: rotate(90deg); }

.chapter-body { display:none; padding:16px; background:#fff; border-radius:10px; margin-bottom:16px; box-shadow:0 2px 6px rgba(0,0,0,0.03); max-height:400px; overflow-y:auto; }
.chapter-body::-webkit-scrollbar { width:8px; }
.chapter-body::-webkit-scrollbar-thumb { background:#a72344; border-radius:10px; }
.chapter-body::-webkit-scrollbar-track { background:#f1f1f1; }

.tabs { display:flex; margin-bottom:15px; border-bottom:1px solid #ddd; }
.tab { padding:10px 20px; cursor:pointer; background:#f5f5f5; border:1px solid #ddd; border-bottom:none; border-radius:5px 5px 0 0; margin-right:5px; transition:0.2s; }
.tab.active { background:#fff; border-bottom:1px solid #fff; font-weight:600; color:#a72344; }

.question-item { background:#fefefe; padding:14px; border-radius:8px; margin-bottom:12px; border:1px solid #eee; }
.question-text { font-weight:600; color:#501121; margin-bottom:8px; }
.question-options { display:grid; grid-template-columns: repeat(2,1fr); gap:8px; margin-bottom:8px; }
.question-option { padding:8px 10px; background:#fff; border-radius:6px; border:1px solid #e7e7e7; }
.correct-answer { background: rgba(76,201,240,0.08); border-color:#4cc9f0; color:#4cc9f0; font-weight:600; }
.question-actions { display:flex; justify-content:flex-end; gap:10px; }

.progress-table { width:100%; border-collapse: collapse; margin-top:10px; }
.progress-table th, .progress-table td { border:1px solid #ddd; padding:8px; text-align:left; }
.progress-table th { background:#f2f2f2; font-weight:bold; }

.question-result.correct { border-left:6px solid #2b8a3e; padding-left:8px; }
.question-result.wrong { border-left:6px solid #d33; padding-left:8px; background:#fff6f6; }

.choice { padding:8px 10px; border-radius:6px; border:1px solid #e7e7e7; margin-top:6px; display:flex; justify-content:space-between; align-items:center; }
.choice.correct-choice { background: rgba(43,138,62,0.06); border-color:#2b8a3e; }
.choice.student-choice { box-shadow: inset 0 0 0 2px rgba(0,0,0,0.04); }
.choice .tag { font-size:12px; padding:4px 6px; border-radius:6px; }
.choice .tag.correct { background:#2b8a3e;color:#fff; }
.choice .tag.selected { background:#d33;color:#fff; }

.add-question-btn { background: linear-gradient(180deg,#a72344,#7a1024); color:#fff; padding:10px 16px; border-radius:10px; font-weight:700; border:none; cursor:pointer; margin-bottom:12px; transition:0.2s; }
.add-question-btn:hover { transform:scale(1.03); }

.save-question-btn { background: linear-gradient(180deg,#4cc9f0,#2aa6c8); color:#fff; padding:10px 18px; border-radius:10px; font-weight:700; border:none; cursor:pointer; transition:0.2s; }
.save-question-btn:hover { transform:scale(1.03); }

.cancel-btn { background:#fff; color:#a72344; padding:10px 16px; border-radius:8px; font-weight:600; border:1px solid #a72344; cursor:pointer; transition:0.2s; }
.cancel-btn:hover { background:#fef1f1; }

.edit-btn { background:#501121; color:#fff; padding:8px 12px; border-radius:8px; border:none; cursor:pointer; font-weight:700; transition:0.2s; }
.edit-btn:hover { opacity:0.85; }

.delete-btn { background: linear-gradient(180deg,#ff6b6b,#d32f2f); color:#fff; padding:8px 12px; border-radius:8px; border:none; cursor:pointer; font-weight:700; transition:0.2s; }
.delete-btn:hover { opacity:0.85; }

.modal { display:none; position:fixed; z-index:3000; left:0; top:0; width:100%; height:100%; background: rgba(0,0,0,0.45); align-items:center; justify-content:center; padding:20px; }
.modal-content { background:white; width:100%; max-width:600px; border-radius:12px; padding:25px; box-shadow:0 8px 20px rgba(0,0,0,0.15); animation:fadeIn 0.2s ease; }
@keyframes fadeIn { from{opacity:0; transform:translateY(-10px);} to{opacity:1; transform:translateY(0);} }

.modal-header { display:flex; justify-content:space-between; align-items:center; margin-bottom:18px; }
.modal-header h2 { color:#501121; font-size:22px; margin:0; }
.close { font-size:24px; cursor:pointer; color:#6c757d; transition:0.2s; }
.close:hover { color:#a72344; }

.question-form input[type=text] { width:100%; padding:10px; margin-bottom:10px; border-radius:8px; border:1px solid #ddd; }
.question-form select { width:100%; padding:10px; margin-bottom:12px; border-radius:8px; border:1px solid #ddd; }

#mcFields input[type=radio] { margin-right:6px; }
#tfFields label { margin-right:20px; }

/* Toggle switch */
.switch { display:inline-flex; align-items:center; gap:8px; cursor:pointer; }
.switch input[type=checkbox] { width:0; height:0; opacity:0; position:absolute; }
.switch .slider { width:44px; height:24px; background:#ccc; border-radius:20px; position:relative; transition:background 0.18s ease; display:inline-block; vertical-align:middle; }
.switch .slider::after { content:''; width:18px; height:18px; background:#fff; border-radius:50%; position:absolute; left:3px; top:3px; transition:transform 0.18s ease; box-shadow:0 1px 3px rgba(0,0,0,0.2); }
.switch input[type=checkbox]:checked + .slider { background:#4cc9f0; }
.switch input[type=checkbox]:checked + .slider::after { transform:translateX(20px); }
.switch .switch-label { margin-left:6px; display:inline-block; vertical-align:middle; color:#333; }
.settings-row { display:flex; gap:12px; align-items:center; margin-bottom:8px; flex-wrap:wrap; }

.chapters-scroll { max-height:600px; overflow-y:auto; padding-right:6px; }
.chapters-scroll::-webkit-scrollbar { width:8px; }
.chapters-scroll::-webkit-scrollbar-thumb { background:#a72344; border-radius:10px; }
.chapters-scroll::-webkit-scrollbar-track { background:#f1f1f1; }
</style>
</head>
<body>
<div class="container-wrap">
  <div class="-main">
    <div class="main-menu">
      <img src="images/profile logo.PNG" width="60" height="60">
      <p>Math teacher</p>
      <div class="main-section">
        <p>Main</p>
        <a href="studentList.html">Student List</a>
        <a href="studentProgress.html">Student Progress</a>
        <a href="evalControl.html">Evaluation & Control</a>
        <a href="accSecSetup.html">Account & Section Setup</a>
      </div>
    </div>
  </div>

<div class="-side">
    <div class="top-bar">
  <div style="flex:1"></div>
  <div class="logout" style="display:flex; align-items:center; gap:8px;">
    <!-- text link (keeps visible text) -->
    <a href="mainWeb.html" id="logoutLink" style="color:#333; text-decoration:none;">Logout</a>
    <!-- icon button you added — now clickable and accessible -->
    <button id="logoutBtn" class="icon-btn" title="Logout" aria-label="Logout" style="color:#333; background:transparent;border:0;padding:6px;cursor:pointer;">
      <i class="fas fa-sign-out-alt"></i>
    </button>
  </div>
    </div>

    <div class="dash-window">
      <div class="header-title"><h1>Evaluation & Control</h1></div>
      <div class="data-container">
        <p>Total Students: <span id="totalStudents">Loading...</span></p>
        <div style="margin-top:8px;margin-bottom:10px;">
          <button id="testModalBtn" class="save-question-btn" style="padding:8px 12px; font-size:14px;">Test Modal</button>
        </div>
        <div class="chapters-scroll">
          <div id="chaptersContainer"></div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Modal -->
<div class="modal" id="questionModal">
  <div class="modal-content">
    <div class="modal-header">
      <h2 id="modalTitle">Add New Question</h2>
      <span class="close" onclick="closeQuestionModal()">&times;</span>
    </div>
    <div class="question-form">
      <input type="text" id="questionText" placeholder="Enter your question">
      <select id="questionType" onchange="toggleQuestionType()">
        <option value="multipleChoice">Multiple Choice</option>
        <option value="identification">Identification</option>
        <option value="true_false">True/False</option>
      </select>
      <div id="mcFields">
        <div style="display:flex;flex-direction:column;gap:8px;margin-bottom:8px;">
          <label><input type="radio" name="correctOption" value="0"> <input type="text" id="optionText0" placeholder="Option A"></label>
          <label><input type="radio" name="correctOption" value="1"> <input type="text" id="optionText1" placeholder="Option B"></label>
          <label><input type="radio" name="correctOption" value="2"> <input type="text" id="optionText2" placeholder="Option C"></label>
          <label><input type="radio" name="correctOption" value="3"> <input type="text" id="optionText3" placeholder="Option D"></label>
        </div>
        <div class="settings-row">
          <label class="switch"><input type="checkbox" id="optCaseSensitive"><span class="slider"></span><span class="switch-label" style="font-size:13px;">Case sensitive</span></label>
          <label class="switch"><input type="checkbox" id="optOrderMatters"><span class="slider"></span><span class="switch-label" style="font-size:13px;">Order matters</span></label>
          <label class="switch"><input type="checkbox" id="optRandomizeOptions"><span class="slider"></span><span class="switch-label" style="font-size:13px;">Randomize options</span></label>
        </div>
      </div>
      <div id="idFields" style="display:none;">
        <input type="text" id="identificationAnswer" placeholder="Correct answer">
        <div style="margin-top:8px;" class="settings-row">
          <label class="switch"><input type="checkbox" id="idCaseSensitive"><span class="slider"></span><span class="switch-label" style="font-size:13px;">Case sensitive</span></label>
          <label class="switch"><input type="checkbox" id="idOrderMatters"><span class="slider"></span><span class="switch-label" style="font-size:13px;">Order matters</span></label>
        </div>
      </div>
      <div id="tfFields" style="display:none;">
        <label><input type="radio" name="trueFalseAnswer" value="True"> True</label>
        <label><input type="radio" name="trueFalseAnswer" value="False"> False</label>
      </div>
      <div style="text-align:right; margin-top:12px;">
        <button class="save-question-btn" onclick="saveQuestion()">Save</button>
        <button class="cancel-btn" onclick="closeQuestionModal()">Cancel</button>
      </div>
    </div>
  </div>
</div>

<script>
const firebaseConfig = {
  apiKey: "AIzaSyBkmM4hueT7PlnvV8FeRdp8g4rk0qQQrn4",
  authDomain: "midnightmathscape.firebaseapp.com",
  databaseURL: "https://midnightmathscape-e8e70-default-rtdb.firebaseio.com/",
  projectId: "midnightmathscape",
  storageBucket: "midnightmathscape.appspot.com",
  messagingSenderId: "1038485290511",
  appId: "1:1038485290511:web:c8aa78fbcd5266b706ed7a"
};
firebase.initializeApp(firebaseConfig);
const rtdb = firebase.database();

// Safe HTML escape helper
function escapeHtml(str){
  if(str === null || str === undefined) return '';
  return String(str)
    .replace(/&/g,'&amp;')
    .replace(/</g,'&lt;')
    .replace(/>/g,'&gt;')
    .replace(/"/g,'&quot;')
    .replace(/'/g,'&#39;');
}

// Count students from StudentAccount in realtime
const totalStudentsEl = document.getElementById('totalStudents');
rtdb.ref('StudentAccount').on('value', snap => {
  if (!snap.exists()) {
    totalStudentsEl.textContent = '0';
    return;
  }
  const students = snap.val();
  totalStudentsEl.textContent = Object.keys(students).length;
});

let editingQuestionId = null;
let currentChapter = null;

const chapterTitles = {
  chapter1:"Chapter 1: Midnight Hideout ", chapter2:"Chapter 2: Whispering Shelves", chapter3:"Chapter 3: Shattered Glass",
  chapter4:"Chapter 4: Silent Halls", chapter5:"Chapter 5: Echoes of Lunch", chapter6:"Chapter 6: Rooftop Rush",
  chapter7:"Chapter 7: Creaking Scaffold", chapter8:"Chapter 8: Flickering Screens", chapter9:"Chapter 9: Whispering Papers",
  chapter10:"Chapter 10: Creeping Silence", chapter11:"Chapter 11: Locked Secrets", chapter12:"Chapter 12: Freedom’s Edge"
};

// Build chapters UI
const container = document.getElementById('chaptersContainer');
Object.keys(chapterTitles).forEach(ch => {
  const header = document.createElement('div');
  header.className = 'data-header';
  header.dataset.chapter = ch;
  header.innerHTML = `<h3>${chapterTitles[ch]}</h3><i class="fa-solid fa-chevron-right"></i>`;
  const body = document.createElement('div');
  body.className = 'chapter-body';
  body.id = 'body-'+ch;
  body.innerHTML = `
    <div class="tabs">
      <div class="tab active" data-tab="questions">Question Management</div>
      <div class="tab" data-tab="progress">Student Progress</div>
    </div>
    <div id="questions-tab-${ch}"></div>
    <div id="progress-tab-${ch}" style="display:none;"></div>
  `;
  container.appendChild(header);
  container.appendChild(body);

  header.addEventListener('click', () => {
    const open = header.classList.contains('open');
    document.querySelectorAll('.data-header').forEach(h=>h.classList.remove('open'));
    document.querySelectorAll('.chapter-body').forEach(b=>b.style.display='none');
    if(!open){ header.classList.add('open'); body.style.display='block'; loadChapterQuestions(ch); }
  });
});

// Tabs
document.addEventListener('click', e=>{
  if(e.target.classList.contains('tab')){
    const tab=e.target, ch=tab.closest('.chapter-body').id.replace('body-','');
    tab.parentNode.querySelectorAll('.tab').forEach(t=>t.classList.remove('active'));
    tab.classList.add('active');
    document.getElementById(`questions-tab-${ch}`).style.display=tab.dataset.tab==='questions'?'block':'none';
    document.getElementById(`progress-tab-${ch}`).style.display=tab.dataset.tab==='progress'?'block':'none';
    if(tab.dataset.tab==='progress'){ subscribeStudentProgress(ch); }
  }
});

// Get next sequential question index
async function getNextQuestionIndex(ch){
  const snap = await rtdb.ref(`quizzes/${ch}/questions`).get();
  if(!snap.exists()) return 1;
  const indexes = [];
  snap.forEach(child=>indexes.push(parseInt(child.key)));
  return Math.max(...indexes)+1;
}

// Load questions
async function loadChapterQuestions(ch){
  currentChapter = ch;
  const container = document.getElementById(`questions-tab-${ch}`);
  container.innerHTML = `<button class="add-question-btn" onclick="openQuestionModal('${ch}')"><i class="fas fa-plus"></i> Add Question</button><div id="questions-list-${ch}">Loading...</div>`;
  const list = document.getElementById(`questions-list-${ch}`);
  const snap = await rtdb.ref(`quizzes/${ch}/questions`).get();
  if(!snap.exists()){ list.innerHTML="<p>No questions yet</p>"; return; }
  list.innerHTML = "";
    snap.forEach(child=>{
    const q = child.val(), id = child.key;
    let optionsHtml="";
    if(q.type==="multiple_choice"){
      // respect randomizeOptions: when randomizing, we must still mark correct answer
      const choices = Array.isArray(q.choices) ? q.choices.slice() : [];
      let displayChoices = choices.slice();
      if(q.randomizeOptions){ displayChoices = shuffle(displayChoices); }
      displayChoices.forEach(opt=>{
        const correct = (q.orderMatters) ? (q.answer===opt) : (q.answer===opt);
        optionsHtml += `<div class="question-option ${correct?'correct-answer':''}">${opt}</div>`;
      });
      optionsHtml += `<p style="font-size:12px;color:#666;margin-top:6px">Case sensitive: ${q.caseSensitive? 'Yes':'No'} &nbsp; | &nbsp; Order matters: ${q.orderMatters? 'Yes':'No'} &nbsp; | &nbsp; Randomize: ${q.randomizeOptions? 'Yes':'No'}</p>`;
    } else {
      optionsHtml = `<div class="question-option"><b>Answer:</b> ${q.answer}</div>`;
    }
    list.innerHTML += `
      <div class="question-item">
        <div class="question-text">[${q.questionIndex}] ${q.question}</div>
        <div class="question-options">${optionsHtml}</div>
        <p><b>Show Answer:</b> ${q.showAnswer}</p>
        <div class="question-actions">
          <button class="edit-btn" onclick="openEditModal('${ch}','${id}')">Edit</button>
          <button class="delete-btn" onclick="deleteQuestion('${ch}','${id}')">Delete</button>
        </div>
      </div>`;
  });
}

// --- Preview / Evaluation helper (instructor testing) ---
// Render a simple preview box at the bottom of the questions list for the current chapter
function renderPreviewBox(ch){
  const container = document.getElementById(`questions-tab-${ch}`);
  // append preview area if not present
  if(!document.getElementById('previewArea')){
    const preview = document.createElement('div');
    preview.id = 'previewArea';
    preview.style.marginTop = '12px';
    preview.innerHTML = `<div style="padding:12px;border-radius:8px;background:#fff;border:1px solid #eee;"><h4>Preview / Test</h4><div id='previewContent'>Select a question from the list to preview it here (click Edit then Close to return)</div></div>`;
    container.appendChild(preview);
  }
}

// Evaluate answer against a question object q and a provided response
// For multiple_choice: response can be the option text (string) or array of strings if multiple answers expected
function evaluateAnswer(q, response){
  if(!q) return false;
  if(q.type === 'multiple_choice'){
    // normalize based on caseSensitive
    const caseSensitive = !!q.caseSensitive;
    const normalize = v => caseSensitive ? v : String(v).toLowerCase().trim();
    // if orderMatters is used, comparing arrays (not typical for single-answer MC)
    if(Array.isArray(response) && Array.isArray(q.answer)){
      if(q.orderMatters){
        for(let i=0;i<q.answer.length;i++) if(normalize(response[i]) !== normalize(q.answer[i])) return false;
        return true;
      } else {
        // compare as sets
        const a = response.map(normalize).sort(), b = q.answer.map(normalize).sort();
        return JSON.stringify(a) === JSON.stringify(b);
      }
    }
    // single-answer multiple choice
    const resp = normalize(response);
    const ans = normalize(q.answer);
    return resp === ans;
  } else if(q.type === 'identification'){
    const caseSensitive = !!q.caseSensitive;
    const normalize = v => caseSensitive ? v.trim() : String(v).toLowerCase().trim();
    // orderMatters for identification could imply exact match on tokens order; default exact
    return normalize(response) === normalize(q.answer);
  } else if(q.type === 'true_false'){
    return String(response).toLowerCase() === String(q.answer).toLowerCase();
  }
  return false;
}

// Shuffle helper
function shuffle(array){
  for(let i = array.length -1; i>0; i--){
    const j = Math.floor(Math.random()*(i+1));
    [array[i], array[j]] = [array[j], array[i]];
  }
  return array;
}

// Robust extractor: get student response for a question key/index from various attempt shapes
function extractStudentResponse(attemptObj, qk, qIndex){
  if(!attemptObj) return undefined;
  // common shapes
  if(attemptObj.answers && attemptObj.answers[qk] !== undefined) return attemptObj.answers[qk];
  if(attemptObj.answers && attemptObj.answers['q'+qk] !== undefined) return attemptObj.answers['q'+qk];
  if(attemptObj.answers && attemptObj.answers['Q'+qk] !== undefined) return attemptObj.answers['Q'+qk];
  if(attemptObj.answers && attemptObj.answers[qIndex] !== undefined) return attemptObj.answers[qIndex];
  if(attemptObj.answers && attemptObj.answers['q'+qIndex] !== undefined) return attemptObj.answers['q'+qIndex];
  if(attemptObj.answers && attemptObj.answers['Q'+qIndex] !== undefined) return attemptObj.answers['Q'+qIndex];
  if(attemptObj.responses && attemptObj.responses[qk] !== undefined) return attemptObj.responses[qk];
  if(Array.isArray(attemptObj.responses) && attemptObj.responses.length >= qIndex) return attemptObj.responses[qIndex-1];
  if(attemptObj.responsesArray && Array.isArray(attemptObj.responsesArray) && attemptObj.responsesArray.length >= qIndex) return attemptObj.responsesArray[qIndex-1];
  if(attemptObj[qk] !== undefined) return attemptObj[qk];
  if(attemptObj['q'+qk] !== undefined) return attemptObj['q'+qk];
  if(attemptObj['Q'+qk] !== undefined) return attemptObj['Q'+qk];
  if(attemptObj['q'+qk] !== undefined) return attemptObj['q'+qk];
  if(attemptObj[String(qk)] !== undefined) return attemptObj[String(qk)];
  // some QuizResults store answers under a top-level 'answers' object with numeric keys as strings
  if(attemptObj.answers && typeof attemptObj.answers === 'object'){
    if(attemptObj.answers[String(qIndex)] !== undefined) return attemptObj.answers[String(qIndex)];
    // try to find keys like 'Q1', 'q1', or any key whose numeric part equals qIndex (robust matching)
    for(const k of Object.keys(attemptObj.answers)){
      if(!k) continue;
      const num = k.replace(/\D/g,'');
      if(num === String(qIndex)) return attemptObj.answers[k];
    }
  }
  return undefined;
}

// Fetch student name
async function getStudentName(sid){
  const snap = await rtdb.ref("StudentAccount/"+sid).get();
  if(!snap.exists()) return sid;
  const acc = snap.val();
  // prefer canonical camelCase keys, fallback to older lowercase ones
  const fn = acc.firstName || acc.firstname || acc.name || '';
  const ln = acc.lastName || acc.lastname || '';
  const full = (fn + ' ' + ln).trim();
  return full || sid;
}

// Subscribe to student progress (real-time)
function subscribeStudentProgress(ch){
  const container=document.getElementById(`progress-tab-${ch}`);
  container.innerHTML="<p>Loading...</p>";

  rtdb.ref().on("value", async snapshot=>{
    const allData = snapshot.val() || {};
    const quizResults = allData.QuizResults || {};
    const studentsProgress = allData.StudentsProgress || {};

    // Collect attempts per student: { sid: [ {score, date, timeSpent, source, attemptIndex}, ... ] }
    const attemptsByStudent = {};

    // Helper to push attempt
    function pushAttempt(sid, attempt){
      if(!attemptsByStudent[sid]) attemptsByStudent[sid] = [];
      attemptsByStudent[sid].push(attempt);
    }

    // QuizResults (structure: QuizResults[sid][chapter][attemptId] = {score,date,timeSpent})
    for(const sid in quizResults){
      if(!quizResults[sid] || !quizResults[sid][ch]) continue;
      const chapterEntries = quizResults[sid][ch];
      const keys = Object.keys(chapterEntries).sort();
      keys.forEach((key, idx) => {
        const res = chapterEntries[key] || {};
        pushAttempt(sid, { score: res.score || 0, date: res.date || '', timeSpent: res.timeSpent || 0, source: 'QuizResults', attemptIndex: idx+1 });
      });
    }

    // StudentsProgress (structure: StudentsProgress[sid][chapter][attemptId] = {keysFound,date,timeSpent})
    for(const sid in studentsProgress){
      if(!studentsProgress[sid] || !studentsProgress[sid][ch]) continue;
      const chapterEntries = studentsProgress[sid][ch];
      const keys = Object.keys(chapterEntries).sort();
      keys.forEach((key, idx) => {
        const res = chapterEntries[key] || {};
        pushAttempt(sid, { score: res.keysFound || 0, date: res.date || '', timeSpent: res.timeSpent || 0, source: 'StudentsProgress', attemptIndex: idx+1 });
      });
    }

    // Build HTML: per-student collapsible card with attempts table
    let html = '';
    const sids = Object.keys(attemptsByStudent).sort();
    for(const sid of sids){
      const studentName = await getStudentName(sid);
      const attempts = attemptsByStudent[sid] || [];
      // sort attempts by attemptIndex (already ordered) or date
      attempts.sort((a,b)=> (a.attemptIndex||0) - (b.attemptIndex||0));

      // build attempts table rows
      let attemptsRows = '';
      attempts.forEach(a => {
          attemptsRows += `<tr><td>${a.attemptIndex}</td><td>${a.score}</td><td>${a.date}</td><td>${a.timeSpent} mins</td><td>${a.source}</td><td><button class="btn btn-sm btn-primary" data-view-attempt="${sid}|${ch}|${a.attemptIndex}">View</button> <button class="btn btn-sm btn-outline-success" data-inline-answers="${sid}|${ch}|${a.attemptIndex}">Answers</button></td></tr>`;
      });

      html += `
        <div class="data-header progress-header" data-sid="${sid}" style="display:flex;justify-content:space-between;align-items:center;cursor:pointer;">
          <div><strong>${studentName}</strong> <span style="color:#666;margin-left:8px;">(${sid})</span></div>
          <div style="color:#666">Attempts: ${attempts.length}</div>
        </div>
        <div class="chapter-body attempts-body" style="display:none; padding:10px 14px; margin-bottom:12px;">
          <table class='progress-table'>
            <thead><tr><th>Attempt #</th><th>Score</th><th>Date</th><th>Time Spent</th><th>Source</th></tr></thead>
            <tbody>
              ${attemptsRows}
            </tbody>
          </table>
        </div>
      `;
    }

    if(!sids.length) html = '<p>No attempts found.</p>';
    container.innerHTML = html;

    // Attach click handlers to toggle attempts
    document.querySelectorAll('.progress-header').forEach(h => {
      h.addEventListener('click', ()=>{
        const next = h.nextElementSibling;
        if(!next) return;
        const isOpen = next.style.display && next.style.display !== 'none';
        next.style.display = isOpen ? 'none' : 'block';
      });
    });
  });
}

// View attempt details handler (delegated)
document.addEventListener('click', async (e)=>{
  const btn = e.target.closest && e.target.closest('[data-view-attempt]');
  if(!btn) return;
  const val = btn.getAttribute('data-view-attempt'); // sid|chapter|attemptIndex
  const [sid, ch, attemptIndex] = val.split('|');
  // fetch attempt object from StudentsProgress or QuizResults
  try{
    // First try StudentsProgress node
    const spSnap = await rtdb.ref(`StudentsProgress/${sid}/${ch}/${attemptIndex}`).get();
    let attemptObj = spSnap.exists() ? spSnap.val() : null;
    let source = 'StudentsProgress';
    if(!attemptObj){
      const qrSnap = await rtdb.ref(`QuizResults/${sid}/${ch}/${attemptIndex}`).get();
      attemptObj = qrSnap.exists() ? qrSnap.val() : null;
      source = qrSnap.exists() ? 'QuizResults' : source;
    }
    if(!attemptObj){
      // fallback: try to search StudentsProgress/[sid]/[ch] for any attempt matching attemptIndex by key
      const altSnap = await rtdb.ref(`StudentsProgress/${sid}/${ch}`).get();
      if(altSnap.exists()){
        const altVal = altSnap.val();
        if(altVal[attemptIndex]){ attemptObj = altVal[attemptIndex]; source='StudentsProgress'; }
      }
    }
    // If still missing, try to read chapter-level data and use it as attempt object
    if(!attemptObj){
      // try QuizResults at chapter level
      const chapterQrSnap = await rtdb.ref(`QuizResults/${sid}/${ch}`).get();
      if(chapterQrSnap.exists()){
        const chVal = chapterQrSnap.val();
        // If chVal looks like a direct answers object (has answers/responses or non-numeric keys), use it
        const chKeys = Object.keys(chVal || {});
        if(chVal && (chVal.answers || chVal.responses || chKeys.some(k=>isNaN(Number(k))))) {
          attemptObj = chVal; source = 'QuizResults(chapter)';
        } else if(chKeys.length){
          // otherwise pick the first child (older structures may nest by attempt id)
          attemptObj = chVal[chKeys[0]]; source = `QuizResults(chapter:${chKeys[0]})`; 
        }
      }
      // if still not found, try StudentsProgress at chapter level
      if(!attemptObj){
        const chapterSpSnap = await rtdb.ref(`StudentsProgress/${sid}/${ch}`).get();
        if(chapterSpSnap.exists()){
          const spVal = chapterSpSnap.val();
          const spKeys = Object.keys(spVal || {});
          if(spVal && (spVal.answers || spVal.responses || spKeys.some(k=>isNaN(Number(k))))) {
            attemptObj = spVal; source = 'StudentsProgress(chapter)';
          } else if(spKeys.length){
            attemptObj = spVal[spKeys[0]]; source = `StudentsProgress(chapter:${spKeys[0]})`;
          }
        }
      }
    }
    // If still missing, show a friendly modal indicating no stored answers were found (instead of an alert)
    if(!attemptObj){
      const fallbackHtml = `<div style="max-height:60vh;overflow:auto"><h3>No stored answers found</h3><p>There is no per-attempt record for this attempt and no chapter-level answers were found in the database for this student/chapter.</p><p>Check that the student's attempts were saved under <code>QuizResults/${sid}/${ch}</code> or <code>StudentsProgress/${sid}/${ch}</code>.</p></div>`;
      showAttemptModal(fallbackHtml);
      return;
    }

    // Load chapter quiz questions to compare answers
    const quizSnap = await rtdb.ref(`quizzes/${ch}/questions`).get();
    const questions = quizSnap.exists() ? quizSnap.val() : {};

    // Build modal content: iterate questions in numeric order by questionIndex
    const qKeys = Object.keys(questions || {}).sort((a,b)=> Number(a) - Number(b));
    let html = `<div style="max-height:60vh;overflow:auto">`;
    html += `<h3>Attempt ${escapeHtml(attemptIndex)} — Student ${escapeHtml(sid)} — Source: ${escapeHtml(source)}</h3>`;

    if(qKeys.length===0){ html += `<p>No question definitions found for this chapter.</p>`; }
    else {
      qKeys.forEach(qk => {
        const q = questions[qk];
        // Determine student's response for this question from attemptObj
        // Attempt shapes vary: could be {answers: {qIndex: value}} or {responses: [...] } or flat fields. We'll try several heuristics.
  // extract student response using helper (qk is key, qIndex = numeric index)
  const qIndex = Number(qk);
  let studentResp = extractStudentResponse(attemptObj, qk, qIndex);

        // evaluate correctness using evaluateAnswer
        const correct = evaluateAnswer(q, studentResp);

        const cls = correct ? 'question-result correct' : 'question-result wrong';
        html += `<div class="${cls}" style="padding:10px;border-bottom:1px solid #eee;margin-bottom:8px;">
          <div style="display:flex;justify-content:space-between;align-items:center"><div style="font-weight:700;color:#501121">Q${escapeHtml(q.questionIndex || qk)}: ${escapeHtml(q.question||'')}</div><div style="font-size:12px;color:#666">${escapeHtml(q.type||'')}</div></div>`;

        if(q.type === 'multiple_choice'){
          // render choices and highlight correct and student selection
          const choices = Array.isArray(q.choices) ? q.choices : (q.choices ? Object.values(q.choices) : []);
          html += `<div style="margin-top:8px;display:flex;flex-direction:column;">`;
          choices.forEach((opt, idx)=>{
            // isCorrect by value
            const isCorrect = (Array.isArray(q.answer) ? q.answer.indexOf(opt) !== -1 : q.answer === opt);
            // determine if student selected this option: handle text or numeric index
            let isSelected = false;
            if(Array.isArray(studentResp)){
              isSelected = studentResp.indexOf(opt) !== -1 || studentResp.indexOf(String(idx)) !== -1 || studentResp.indexOf(idx) !== -1;
            } else {
              isSelected = studentResp === opt || studentResp === String(opt) || studentResp === idx || studentResp === String(idx) || studentResp === (idx+1) || studentResp === String(idx+1);
            }
            // if attempt stored numeric index (0-based or 1-based), map to choice text for display later
            let displayStudent = studentResp;
            if(!Array.isArray(studentResp) && (typeof studentResp === 'number' || (!isNaN(Number(studentResp)) && String(studentResp).trim() !== ''))){
              const num = Number(studentResp);
              const mapIdx = (num === 0 || num === idx) ? num : (num-1);
              if(choices[mapIdx] !== undefined) displayStudent = choices[mapIdx];
            }
            // if array of numeric indices, map them
            let displayStudentForOpt = displayStudent;
            if(Array.isArray(studentResp)){
              const mapped = studentResp.map(x=>{ const n=Number(x); return (Number.isFinite(n) && choices[n]!==undefined) ? choices[n] : x; });
              displayStudentForOpt = mapped.join(', ');
            }
            const chCls = `choice ${isCorrect ? 'correct-choice':''} ${isSelected ? 'student-choice':''}`;
            const tag = isCorrect ? '<span class="tag correct">Correct</span>' : (isSelected ? '<span class="tag selected">Selected</span>' : '');
            html += `<div class="${chCls}"><div>${escapeHtml(opt)}</div><div>${tag}</div></div>`;
          });
          html += `</div>`;
          html += `<div style="margin-top:8px;">Result: <span style="font-weight:700;color:${correct? '#2b8a3e':'#d33'}">${correct? 'Correct' : 'Incorrect'}</span></div>`;
        } else {
          html += `<div style="margin-top:6px;">Expected: <span style='font-weight:600'>${escapeHtml(String(q.answer===undefined?JSON.stringify(q.choices||''): q.answer))}</span></div>`;
          html += `<div style="margin-top:6px;">Student answer: <span style='font-weight:600'>${escapeHtml(String(studentResp===undefined?'(no response)': studentResp))}</span></div>`;
          html += `<div style="margin-top:6px;color:${correct? '#2b8a3e':'#d33'};font-weight:700">${correct? 'Correct' : 'Incorrect'}</div>`;
        }
        html += `</div>`;
      });
    }
    html += `</div>`;

    // show custom modal (reuse simple modal pattern)
    showAttemptModal(html);
  }catch(err){ console.error(err); alert('Error loading attempt details: '+ (err && err.message ? err.message : err)); }
});

// Helper: fetch an attempt object with fallbacks (per-attempt nodes, chapter-level nodes)
async function fetchAttemptObject(sid, ch, attemptIndex){
  console.debug('fetchAttemptObject()', { sid, ch, attemptIndex });
  // try StudentsProgress per-attempt
  const spPath = `StudentsProgress/${sid}/${ch}/${attemptIndex}`;
  const spSnap = await rtdb.ref(spPath).get();
  console.debug('checked', spPath, 'exists=', spSnap.exists());
  if(spSnap.exists()) return { obj: spSnap.val(), source: spPath };
  const qrPath = `QuizResults/${sid}/${ch}/${attemptIndex}`;
  const qrSnap = await rtdb.ref(qrPath).get();
  console.debug('checked', qrPath, 'exists=', qrSnap.exists());
  if(qrSnap.exists()) return { obj: qrSnap.val(), source: qrPath };

  // try chapter-level QuizResults
  const chapterQrPath = `QuizResults/${sid}/${ch}`;
  const chapterQrSnap = await rtdb.ref(chapterQrPath).get();
  console.debug('checked', chapterQrPath, 'exists=', chapterQrSnap.exists());
  if(chapterQrSnap.exists()){
    const chVal = chapterQrSnap.val();
    const chKeys = Object.keys(chVal||{});
    console.debug('chapterQr keys sample=', chKeys.slice(0,5));
    if(chVal && (chVal.answers || chVal.responses || chKeys.some(k=>isNaN(Number(k))))) return { obj: chVal, source: chapterQrPath };
    if(chKeys.length) return { obj: chVal[chKeys[0]], source: `${chapterQrPath}:${chKeys[0]}` };
  }

  // try chapter-level StudentsProgress
  const chapterSpPath = `StudentsProgress/${sid}/${ch}`;
  const chapterSpSnap = await rtdb.ref(chapterSpPath).get();
  console.debug('checked', chapterSpPath, 'exists=', chapterSpSnap.exists());
  if(chapterSpSnap.exists()){
    const spVal = chapterSpSnap.val(); const spKeys = Object.keys(spVal||{});
    console.debug('chapterSp keys sample=', spKeys.slice(0,5));
    if(spVal && (spVal.answers || spVal.responses || spKeys.some(k=>isNaN(Number(k))))) return { obj: spVal, source: chapterSpPath };
    if(spKeys.length) return { obj: spVal[spKeys[0]], source: `${chapterSpPath}:${spKeys[0]}` };
  }
  return null;
}

// Delegated handler for inline answers button
document.addEventListener('click', async (e)=>{
  const btn = e.target.closest && e.target.closest('[data-inline-answers]');
  if(!btn) return;
  try{
    const val = btn.getAttribute('data-inline-answers'); // sid|chapter|attemptIndex
    const parts = val ? val.split('|') : [];
    const sid = parts[0], ch = parts[1], attemptIndex = parts[2];
    console.debug('Answers clicked', { val, sid, ch, attemptIndex });
    const tr = btn.closest('tr');
    if(!tr) console.debug('Answers handler: no enclosing <tr> found for button, continuing anyway');

    // fetch attempt object with logging
    let fetched = null;
    console.debug('Answers handler: calling fetchAttemptObject', { sid, ch, attemptIndex });
    try{
      fetched = await fetchAttemptObject(sid, ch, attemptIndex);
      console.debug('fetchAttemptObject returned', { fetchedSummary: fetched ? { source: fetched.source, sampleKeys: fetched.obj ? Object.keys(fetched.obj).slice(0,5) : null } : null });
    }catch(err){
      console.error('fetchAttemptObject threw', err);
      showAttemptModal(`<div style="padding:12px"><h3>Error fetching attempt</h3><pre>${escapeHtml(err && err.message ? err.message : String(err))}</pre></div>`);
      return;
    }

    if(!fetched || !fetched.obj){
      console.debug('No fetched attempt object, showing fallback modal', { fetched });
      const fallbackHtml = `<div style="max-height:60vh;overflow:auto;padding:12px"><h3>No stored answers found</h3><p>There is no stored answers for this attempt.</p><pre>Request: ${escapeHtml(val)}</pre></div>`;
      try{ showAttemptModal(fallbackHtml); } catch(showErr){ console.error('showAttemptModal failed', showErr); alert('No stored answers and failed to open modal. See console.'); }
      return;
    }

    const attemptObj = fetched.obj; const source = fetched.source;
    // load question definitions
    const quizSnap = await rtdb.ref(`quizzes/${ch}/questions`).get();
    const questions = quizSnap.exists() ? quizSnap.val() : {};
    const qKeys = Object.keys(questions||{}).sort((a,b)=>Number(a)-Number(b));

    // build inner content
    let inner = `<div style="padding:8px;">`;
    inner += `<div style="font-weight:700;margin-bottom:8px">Answers (source: ${escapeHtml(source)})</div>`;
    if(qKeys.length===0) inner += `<div>No question definitions found for this chapter.</div>`;
    else {
      qKeys.forEach(qk=>{
        const q = questions[qk]; const qIndex = Number(qk);
        const studentResp = extractStudentResponse(attemptObj, qk, qIndex);
        const correct = evaluateAnswer(q, studentResp);
        const cls = correct ? 'question-result correct' : 'question-result wrong';
        inner += `<div class="${cls}" style="padding:8px;margin-bottom:6px;border:1px solid #eee;border-radius:6px;">`;
        inner += `<div style="font-weight:700;color:#501121">Q${escapeHtml(q.questionIndex||qk)}: ${escapeHtml(q.question||'')}</div>`;
        if(q.type === 'multiple_choice'){
          const choices = Array.isArray(q.choices)? q.choices : (q.choices? Object.values(q.choices):[]);
          inner += `<div style="margin-top:6px;display:flex;flex-direction:column">`;
          choices.forEach((opt, idx)=>{
            const isCorrect = (Array.isArray(q.answer)? q.answer.indexOf(opt)!==-1 : q.answer===opt);
            let isSelected = false;
            if(Array.isArray(studentResp)) isSelected = studentResp.indexOf(opt)!==-1 || studentResp.indexOf(String(idx))!==-1 || studentResp.indexOf(idx)!==-1;
            else isSelected = studentResp===opt || studentResp===String(opt) || studentResp===idx || studentResp===String(idx) || studentResp===(idx+1) || studentResp===String(idx+1);
            const chCls = `choice ${isCorrect? 'correct-choice':''} ${isSelected? 'student-choice':''}`;
            const tag = isCorrect? '<span class="tag correct">Correct</span>' : (isSelected? '<span class="tag selected">Selected</span>' : '');
            inner += `<div class="${chCls}"><div>${escapeHtml(opt)}</div><div>${tag}</div></div>`;
          });
          inner += `</div>`;
        } else {
          inner += `<div style="margin-top:6px;">Expected: <span style='font-weight:600'>${escapeHtml(String(q.answer===undefined?JSON.stringify(q.choices||''): q.answer))}</span></div>`;
          inner += `<div style="margin-top:6px;">Student answer: <span style='font-weight:600'>${escapeHtml(String(studentResp===undefined?'(no response)': studentResp))}</span></div>`;
        }
        inner += `<div style="margin-top:6px;color:${correct? '#2b8a3e':'#d33'};font-weight:700">${correct? 'Correct' : 'Incorrect'}</div>`;
        inner += `</div>`;
      });
    }
    inner += `</div>`;

    // show modal with answers instead of inline row
    try{ console.debug('Showing modal with answers'); showAttemptModal(inner); }catch(err){ console.error('showAttemptModal failed', err); showAttemptModal(`<div style="padding:12px"><h3>Modal failed</h3><pre>${escapeHtml(err && err.message ? err.message : String(err))}</pre></div>`); }
  }catch(err){ console.error('Unhandled error in Answers handler', err); showAttemptModal(`<div style="padding:12px"><h3>Unhandled error</h3><pre>${escapeHtml(err && err.message ? err.message : String(err))}</pre></div>`); }
});

// Simple attempt modal implementation
function showAttemptModal(innerHtml){
  console.debug('showAttemptModal called, innerHtml length=', innerHtml ? innerHtml.length : 0);
  let modal = document.getElementById('attemptDetailsModal');
  if(!modal){
    modal = document.createElement('div'); modal.id='attemptDetailsModal'; modal.className='modal';
  const content = document.createElement('div'); content.className='modal-content'; content.style.maxWidth='900px';
  // limit modal height and keep its content scrollable when large
  content.style.maxHeight = '80vh';
  content.style.overflow = 'hidden';
    content.innerHTML = `
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:12px;">
        <div style="display:flex;flex-direction:column;">
          <div style="display:flex;align-items:center;gap:12px"><h3 id="attemptModalTitle">Attempt Details</h3><span id="wrongSummary" style="color:#d33;font-weight:700"></span></div>
          <div style="font-size:13px;color:#666" id="attemptModalSub"></div>
        </div>
        <div style="display:flex;gap:8px;align-items:center;">
          <button id="filterWrongBtn" class="btn" style="background:#fff;border:1px solid #ccc;padding:6px 10px;border-radius:6px;">Show Wrong Only</button>
          <button style="background:#fff;border:1px solid #ccc;padding:6px 10px;border-radius:6px;" id="closeAttemptModal">Close</button>
        </div>
      </div>
      <div id="attemptDetailsContent"></div>`;
    modal.appendChild(content); document.body.appendChild(modal);
    // Attach handlers after appending
    try{ document.getElementById('closeAttemptModal').addEventListener('click', ()=>{ modal.style.display='none'; }); }catch(e){ console.error('attach closeAttemptModal failed', e); }
    try{ document.getElementById('filterWrongBtn').addEventListener('click', ()=>{
      const btn = document.getElementById('filterWrongBtn'); const showing = btn.dataset.showing === '1';
      btn.dataset.showing = showing ? '0' : '1'; btn.textContent = showing ? 'Show Wrong Only' : 'Show All';
      document.querySelectorAll('#attemptDetailsContent .question-result').forEach(el=>{
        if(showing){ el.style.display='block'; } else { if(el.classList.contains('wrong')) el.style.display='block'; else el.style.display='none'; }
      });
    }); }catch(e){ console.error('attach filterWrongBtn failed', e); }
  }
  // ensure modal is attached to body and visible with inline styles in case external CSS hides it
  if(!modal.parentNode || modal.parentNode !== document.body) document.body.appendChild(modal);
  // Force important inline styles to override page CSS
  modal.style.setProperty('position','fixed','important');
  modal.style.setProperty('left','0','important'); modal.style.setProperty('top','0','important'); modal.style.setProperty('width','100%','important'); modal.style.setProperty('height','100%','important');
  modal.style.setProperty('display','flex','important'); modal.style.setProperty('align-items','center','important'); modal.style.setProperty('justify-content','center','important');
  modal.style.setProperty('z-index','2147483647','important');
  modal.style.setProperty('background','rgba(0,0,0,0.65)','important');
  // ensure content container exists and make it scrollable (so long answers don't expand modal)
  let contentEl = modal.querySelector('#attemptDetailsContent');
  if(!contentEl){
    const cont = document.createElement('div'); cont.id='attemptDetailsContent';
    const wrapper = modal.querySelector('.modal-content') || modal.firstChild;
    if(wrapper) wrapper.appendChild(cont); contentEl = cont;
  }
  // set scrollable area inside modal
  contentEl.style.maxHeight = 'calc(80vh - 120px)';
  contentEl.style.overflowY = 'auto';
  contentEl.style.padding = contentEl.style.padding || '8px';
  try{
    contentEl.innerHTML = innerHtml;
  }catch(e){ console.error('Failed to set attemptDetailsContent.innerHTML', e); }
  // update wrong count and default state
  const modalEl = document.getElementById('attemptDetailsModal');
  const wrongEls = modalEl ? modalEl.querySelectorAll('.question-result.wrong') : [];
  const wrongSummary = document.getElementById('wrongSummary');
  wrongSummary.textContent = wrongEls.length ? `Wrong: ${wrongEls.length}` : '';
  // reset filter button
  const filterBtn = document.getElementById('filterWrongBtn'); if(filterBtn){ filterBtn.dataset.showing='0'; filterBtn.textContent='Show Wrong Only'; }
  // focus for accessibility after a tiny delay
  setTimeout(()=>{
    try{ const first = modal.querySelector('.modal-content'); if(first) first.focus(); }catch(e){}
  },50);
}

// Modal helpers
function openQuestionModal(ch){ currentChapter=ch; editingQuestionId=null; resetModal(); document.getElementById('questionModal').style.display='flex'; }
function closeQuestionModal(){ document.getElementById('questionModal').style.display='none'; }
function toggleQuestionType(){ const t=document.getElementById('questionType').value; document.getElementById('mcFields').style.display=t==='multipleChoice'?'block':'none'; document.getElementById('idFields').style.display=t==='identification'?'block':'none'; document.getElementById('tfFields').style.display=t==='true_false'?'block':'none'; }
function resetModal(){ document.getElementById('modalTitle').innerText="Add New Question"; document.getElementById('questionText').value=""; document.getElementById('questionType').value="multipleChoice"; toggleQuestionType(); ["0","1","2","3"].forEach(i=>{document.getElementById('optionText'+i).value=""; document.querySelector(`input[name='correctOption'][value='${i}']`).checked=false;}); document.getElementById('identificationAnswer').value=""; document.querySelectorAll("input[name='trueFalseAnswer']").forEach(r=>r.checked=false); }

// Reset extended settings
function resetExtendedSettings(){
  document.getElementById('optCaseSensitive').checked = false;
  document.getElementById('optOrderMatters').checked = false;
  document.getElementById('optRandomizeOptions').checked = false;
  document.getElementById('idCaseSensitive').checked = false;
  document.getElementById('idOrderMatters').checked = false;
}

// Save question
async function saveQuestion(){
  const text=document.getElementById('questionText').value.trim();
  const type=document.getElementById('questionType').value;
  if(!text){alert("Enter question"); return;}
  let payload={question:text, showAnswer:true};
  if(type==="multipleChoice"){
    const opts=[0,1,2,3].map(i=>document.getElementById('optionText'+i).value.trim());
    const checked=document.querySelector("input[name='correctOption']:checked");
    if(!checked){alert("Select correct option"); return;}
    if(opts.some(o=>!o)){alert("Fill all options"); return;}
    payload.choices=opts; payload.answer=opts[checked.value]; payload.type="multiple_choice";
    // extended options
    payload.caseSensitive = !!document.getElementById('optCaseSensitive').checked;
    payload.orderMatters = !!document.getElementById('optOrderMatters').checked;
    payload.randomizeOptions = !!document.getElementById('optRandomizeOptions').checked;
  } else if(type==="identification"){
    const ans=document.getElementById('identificationAnswer').value.trim();
    if(!ans){alert("Enter answer"); return;}
    payload.answer=ans; payload.type="identification";
    payload.caseSensitive = !!document.getElementById('idCaseSensitive').checked;
    payload.orderMatters = !!document.getElementById('idOrderMatters').checked;
  } else if(type==="true_false"){
    const checked=document.querySelector("input[name='trueFalseAnswer']:checked");
    if(!checked){alert("Select True/False"); return;}
    payload.answer=checked.value; payload.type="true_false";
  }

  const ref=rtdb.ref(`quizzes/${currentChapter}/questions`);
  if(editingQuestionId){
    await ref.child(editingQuestionId).set(payload);
    alert("Question updated!");
  } else {
    const nextIndex = await getNextQuestionIndex(currentChapter);
    payload.questionIndex = nextIndex;
    await ref.child(nextIndex.toString()).set(payload);
    alert("Question added!");
  }
  closeQuestionModal();
  loadChapterQuestions(currentChapter);
}

// Edit
async function openEditModal(ch,id){
  currentChapter=ch; editingQuestionId=id; resetModal();
  const snap=await rtdb.ref(`quizzes/${ch}/questions/${id}`).get();
  if(!snap.exists()){alert("Missing"); return;}
  const q = snap.val();
  document.getElementById('modalTitle').innerText="Edit Question";
  document.getElementById('questionText').value=q.question;
  document.getElementById('questionType').value=q.type==="multiple_choice"?"multipleChoice":q.type;
  toggleQuestionType();
  if(q.type==="multiple_choice"){
    q.choices.forEach((opt,i)=>{document.getElementById('optionText'+i).value=opt; if(opt===q.answer) document.querySelector(`input[name='correctOption'][value='${i}']`).checked=true;});
    // populate extended settings
    document.getElementById('optCaseSensitive').checked = !!q.caseSensitive;
    document.getElementById('optOrderMatters').checked = !!q.orderMatters;
    document.getElementById('optRandomizeOptions').checked = !!q.randomizeOptions;
  } else if(q.type==="identification"){ document.getElementById('identificationAnswer').value=q.answer; }
  else if(q.type==="true_false"){ document.querySelector(`input[name='trueFalseAnswer'][value='${q.answer}']`).checked=true; }
  document.getElementById('questionModal').style.display='flex';
}

// Delete
async function deleteQuestion(ch,id){
  if(confirm("Delete this question?")){
    await rtdb.ref(`quizzes/${ch}/questions/${id}`).remove();
    loadChapterQuestions(ch);
  }
}

// Wire test modal button after DOM ready
document.addEventListener('DOMContentLoaded', ()=>{
  try{
    const tb = document.getElementById('testModalBtn');
    if(tb){ tb.addEventListener('click', ()=>{
      console.debug('Test Modal clicked');
      const sample = `<div style="max-height:60vh;overflow:auto;padding:12px;"><h3>Debug Modal</h3><p>If you see this, the modal rendering path is working. Next: test the Answers button to confirm data flow.</p></div>`;
      try{ showAttemptModal(sample); }catch(e){ console.error('showAttemptModal threw', e); alert('Modal test failed; see console.'); }
    }); }
  }catch(e){ console.error('Failed to attach Test Modal handler', e); }
});




</script>
</body>
</html>
