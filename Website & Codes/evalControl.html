<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Evaluation & Control</title>

<link rel="stylesheet" href="dashboard.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"/>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

<script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-database-compat.js"></script>

<style>
body { font-family:'Inter', sans-serif; background:#f8f9fa; margin:0; }
.data-header { cursor:pointer; padding:12px; border-radius:8px; margin:6px 0; background:#fff; display:flex; justify-content:space-between; align-items:center; box-shadow:0 2px 4px rgba(0,0,0,0.05); transition:0.2s; }
.data-header.open { background:#fefefe; }
.data-header i { transition: transform 0.2s; }
.data-header.open i { transform: rotate(90deg); }

.chapter-body { display:none; padding:16px; background:#fff; border-radius:10px; margin-bottom:16px; box-shadow:0 2px 6px rgba(0,0,0,0.03); max-height:400px; overflow-y:auto; }
.chapter-body::-webkit-scrollbar { width:8px; }
.chapter-body::-webkit-scrollbar-thumb { background:#a72344; border-radius:10px; }
.chapter-body::-webkit-scrollbar-track { background:#f1f1f1; }

.tabs { display:flex; margin-bottom:15px; border-bottom:1px solid #ddd; }
.tab { padding:10px 20px; cursor:pointer; background:#f5f5f5; border:1px solid #ddd; border-bottom:none; border-radius:5px 5px 0 0; margin-right:5px; transition:0.2s; }
.tab.active { background:#fff; border-bottom:1px solid #fff; font-weight:600; color:#a72344; }

.question-item { background:#fefefe; padding:14px; border-radius:8px; margin-bottom:12px; border:1px solid #eee; }
.question-text { font-weight:600; color:#501121; margin-bottom:8px; }
.question-options { display:grid; grid-template-columns: repeat(2,1fr); gap:8px; margin-bottom:8px; }
.question-option { padding:8px 10px; background:#fff; border-radius:6px; border:1px solid #e7e7e7; }
.correct-answer { background: rgba(76,201,240,0.08); border-color:#501121; color:#501121; font-weight:600; }
.question-actions { display:flex; justify-content:flex-end; gap:10px; }

.progress-table { width:100%; border-collapse: collapse; margin-top:10px; }
.progress-table th, .progress-table td { border:1px solid #ddd; padding:8px; text-align:left; }
.progress-table th { background:#f2f2f2; font-weight:bold; }

.question-result.correct { border-left:6px solid #2b8a3e; padding-left:8px; }
.question-result.wrong { border-left:6px solid #d33; padding-left:8px; background:#fff6f6; }

.choice { padding:8px 10px; border-radius:6px; border:1px solid #e7e7e7; margin-top:6px; display:flex; justify-content:space-between; align-items:center; }
.choice.correct-choice { background: rgba(43,138,62,0.06); border-color:#2b8a3e; }
.choice.student-choice { box-shadow: inset 0 0 0 2px rgba(0,0,0,0.04); }
.choice .tag { font-size:12px; padding:4px 6px; border-radius:6px; }
.choice .tag.correct { background:#2b8a3e;color:#fff; }
.choice .tag.selected { background:#d33;color:#fff; }

/* Additional evaluation-specific styles (ensure clear instructor highlights) */
.choice.correct-choice { background: rgba(75, 181, 112, 0.08); border-color: #2b8a3e; }
.choice.student-choice { box-shadow: inset 0 0 0 2px rgba(0,0,0,0.04); }
.choice .tag.correct { background: #2b8a3e; color: #fff; }
.choice .tag.selected { background: #a72344; color: #fff; }
.question-result.correct { background: rgba(43,138,62,0.04); border-left:6px solid #2b8a3e; }
.question-result.wrong { background: rgba(211,51,51,0.04); border-left:6px solid #d33; }
.question-result { transition: background .12s ease, border-color .12s ease; }

.add-question-btn { background: linear-gradient(180deg,#a72344,#7a1024); color:#fff; padding:10px 16px; border-radius:10px; font-weight:700; border:none; cursor:pointer; margin-bottom:12px; transition:0.2s; }
.add-question-btn:hover { transform:scale(1.03); }

.save-question-btn { background: linear-gradient(180deg,#4cc9f0,#501121); color:#fff; padding:10px 18px; border-radius:10px; font-weight:700; border:none; cursor:pointer; transition:0.2s; }
.save-question-btn:hover { transform:scale(1.03); }

.cancel-btn { background:#fff; color:#a72344; padding:10px 16px; border-radius:8px; font-weight:600; border:1px solid #a72344; cursor:pointer; transition:0.2s; }
.cancel-btn:hover { background:#fef1f1; }

.edit-btn { background:#501121; color:#fff; padding:8px 12px; border-radius:8px; border:none; cursor:pointer; font-weight:700; transition:0.2s; }
.edit-btn:hover { opacity:0.85; }

.delete-btn { background: linear-gradient(180deg,#ff6b6b,#d32f2f); color:#fff; padding:8px 12px; border-radius:8px; border:none; cursor:pointer; font-weight:700; transition:0.2s; }
.delete-btn:hover { opacity:0.85; }

/* Instructor action buttons in attempts table */
.view-btn, .answers-btn {
  display:inline-flex; align-items:center; gap:8px; padding:6px 10px; border-radius:8px; border:none; cursor:pointer; font-weight:700; font-size:13px; transition:transform .12s ease, box-shadow .12s ease;
}
.view-btn { background: linear-gradient(180deg,#501121,#501121); color:#fff; }
.view-btn:hover { transform:translateY(-1px); box-shadow:0 6px 14px rgba(42,166,200,0.12); }
.answers-btn { background: transparent; color:#501121; border:1px solid #501121; }
.answers-btn:hover { transform:translateY(-1px); box-shadow:0 6px 14px rgba(80,17,33,0.12); background:#fff; }
.view-btn .ico, .answers-btn .ico { width:14px; height:14px; display:inline-block; }

/* make sure FontAwesome icons inherit the button color */
.answers-btn .ico i, .view-btn .ico i { color: inherit; }

/* Section Answers button style */
.view-section-answers-btn {
  display:inline-flex; align-items:center; gap:8px; padding:8px 12px; border-radius:10px; border:none; cursor:pointer; font-weight:700; font-size:13px; background: linear-gradient(180deg,#501121,#7a1024); color:#fff; transition: transform .12s ease, box-shadow .12s ease;
}
.view-section-answers-btn:hover { transform:translateY(-2px); box-shadow:0 10px 24px rgba(80,17,33,0.16); }
.view-section-answers-btn .ico { width:14px; height:14px; display:inline-block; }

/* Section Answers list styles */
.section-answers-list { display:flex; flex-direction:column; gap:12px; }
.student-card { background:#fff; border:1px solid #eee; border-radius:10px; padding:10px; box-shadow:0 2px 6px rgba(0,0,0,0.03); }
.student-header { display:flex; justify-content:space-between; align-items:center; gap:12px; }
.student-title { font-weight:700; color:#501121; }
.student-title .sid { font-weight:600; color:#666; margin-left:6px; font-size:13px; }
.student-meta { display:flex; gap:8px; align-items:center; }
.badge { padding:6px 8px; border-radius:8px; background:#f3f3f3; color:#333; font-weight:700; font-size:13px; }
.badge.score { background:linear-gradient(180deg,#f3f8ff,#eaf6ff); color:#0a53a0; }
.badge.ok { background:#e8f8ef; color:#2b8a3e; }
.badge.warn { background:#fff4f4; color:#c92a2a; }
.badge.muted { background:#fafafa; color:#666; font-weight:600 }
.toggle-details { background:transparent; border:1px solid #ddd; padding:6px 8px; border-radius:8px; cursor:pointer; font-weight:700; }
.student-details { margin-top:10px; padding-top:10px; border-top:1px dashed #eee; display:none; }
.qa-list { display:flex; flex-direction:column; gap:8px; }
.qa-row { display:flex; justify-content:space-between; gap:12px; align-items:center; padding:8px; border-radius:8px; background:#fff; border:1px solid #fbfbfb; }
.qa-question { flex:1; color:#333; }
.qa-status { min-width:110px; text-align:right; font-weight:800; }
.status-ok { color:#2b8a3e; }
.status-wrong { color:#c92a2a; }
.status-muted { color:#666; }
.qa-detail { margin-top:6px; padding:8px; background:#fff; border:1px dashed #eee; border-radius:6px; color:#444; font-size:13px; }
.debug-note { margin-top:8px; color:#777; font-size:12px; }


.modal { display:none; position:fixed; z-index:3000; left:0; top:0; width:100%; height:100%; background: rgba(0,0,0,0.45); align-items:center; justify-content:center; padding:20px; }
.modal-content { background:white; width:100%; max-width:600px; border-radius:12px; padding:25px; box-shadow:0 8px 20px rgba(0,0,0,0.15); animation:fadeIn 0.2s ease; }
@keyframes fadeIn { from{opacity:0; transform:translateY(-10px);} to{opacity:1; transform:translateY(0);} }

.modal-header { display:flex; justify-content:space-between; align-items:center; margin-bottom:18px; }
.modal-header h2 { color:#501121; font-size:22px; margin:0; }
.close { font-size:24px; cursor:pointer; color:#6c757d; transition:0.2s; }
.close:hover { color:#a72344; }

.question-form input[type=text] { width:100%; padding:10px; margin-bottom:10px; border-radius:8px; border:1px solid #ddd; }
.question-form select { width:100%; padding:10px; margin-bottom:12px; border-radius:8px; border:1px solid #ddd; }

#mcFields input[type=radio] { margin-right:6px; }
#tfFields label { margin-right:20px; }

/* Toggle switch */
.switch { display:inline-flex; align-items:center; gap:8px; cursor:pointer; }
.switch input[type=checkbox] { width:0; height:0; opacity:0; position:absolute; }
.switch .slider { width:44px; height:24px; background:#ccc; border-radius:20px; position:relative; transition:background 0.18s ease; display:inline-block; vertical-align:middle; }
.switch .slider::after { content:''; width:18px; height:18px; background:#fff; border-radius:50%; position:absolute; left:3px; top:3px; transition:transform 0.18s ease; box-shadow:0 1px 3px rgba(0,0,0,0.2); }
.switch input[type=checkbox]:checked + .slider { background:#4cc9f0; }
.switch input[type=checkbox]:checked + .slider::after { transform:translateX(20px); }
.switch .switch-label { margin-left:6px; display:inline-block; vertical-align:middle; color:#333; }
.settings-row { display:flex; gap:12px; align-items:center; margin-bottom:8px; flex-wrap:wrap; }

.chapters-scroll { max-height:600px; overflow-y:auto; padding-right:6px; }
.chapters-scroll::-webkit-scrollbar { width:8px; }
.chapters-scroll::-webkit-scrollbar-thumb { background:#a72344; border-radius:10px; }
</style>
<style>
/* Header action alignment */
.top-actions { display:flex; align-items:center; gap:8px; }
.top-actions .answers-btn, .top-actions #viewSectionsBtn { margin-left:6px; vertical-align:middle; padding:6px 10px; }
</style>
</head>
<body>
</style>
</head>
<body>
<div class="container-wrap">
  <div class="-main">
    <div class="main-menu">
      <img src="images/profile logo.PNG" width="60" height="60">
      <p>Math teacher</p>
      <div class="main-section">
        <p>Main</p>
        <a href="studentList.html">Student List</a>
        <a href="studentProgress.html">Student Progress</a>
        <a href="evalControl.html">Evaluation & Control</a>
        <a href="accSecSetup.html">Account & Section Setup</a>
      </div>
    </div>
  </div>

<div class="-side">
    <div class="top-bar">
  <div style="flex:1"></div>
  <div class="logout" style="display:flex; align-items:center; gap:8px;">
    <!-- text link (keeps visible text) -->
    <a href="mainWeb.html" id="logoutLink" style="color:#333; text-decoration:none;">Logout</a>
    <!-- icon button you added — now clickable and accessible -->
    <button id="logoutBtn" class="icon-btn" title="Logout" aria-label="Logout" style="color:#333; background:transparent;border:0;padding:6px;cursor:pointer;">
      <i class="fas fa-sign-out-alt"></i>
    </button>
  </div>
    </div>

    <div class="dash-window">
      <div class="header-title"><h1>Evaluation & Control</h1></div>
      <div class="data-container">
  <p style="display:flex;align-items:center;gap:10px;">Total Students: <span id="totalStudents">Loading...</span>
    <span class="top-actions">
          <button id="exportStudentsBtn" class="answers-btn"><span class="ico"><i class="fas fa-file-csv"></i></span> Export Students</button>
      <button id="viewSectionsBtn" class="answers-btn"><span class="ico"><i class="fas fa-layer-group"></i></span> View Sections</button>
          <button id="scanDbBtn" class="answers-btn" title="Scan RTDB root for quiz/chapter nodes"><span class="ico"><i class="fas fa-magnifying-glass"></i></span> Scan DB</button>
    </span>
  </p>
        <div style="margin-top:8px;margin-bottom:10px;"></div>
        <div class="chapters-scroll">
          <div id="chaptersContainer"></div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Modal -->
<div class="modal" id="questionModal">
  <div class="modal-content">
    <div class="modal-header">
      <h2 id="modalTitle">Add New Question</h2>
      <span class="close" onclick="closeQuestionModal()">&times;</span>
    </div>
    <div class="question-form">
      <input type="text" id="questionText" placeholder="Enter your question">
      <select id="questionType" onchange="toggleQuestionType()">
        <option value="multipleChoice">Multiple Choice</option>
        <option value="identification">Identification</option>
        <option value="true_false">True/False</option>
      </select>
      <div id="mcFields">
        <div style="display:flex;flex-direction:column;gap:8px;margin-bottom:8px;">
          <label><input type="radio" name="correctOption" value="0"> <input type="text" id="optionText0" placeholder="Option A"></label>
          <label><input type="radio" name="correctOption" value="1"> <input type="text" id="optionText1" placeholder="Option B"></label>
          <label><input type="radio" name="correctOption" value="2"> <input type="text" id="optionText2" placeholder="Option C"></label>
          <label><input type="radio" name="correctOption" value="3"> <input type="text" id="optionText3" placeholder="Option D"></label>
        </div>
        <div class="settings-row">
          <label class="switch"><input type="checkbox" id="optCaseSensitive"><span class="slider"></span><span class="switch-label" style="font-size:13px;">Case sensitive</span></label>
          <label class="switch"><input type="checkbox" id="optOrderMatters"><span class="slider"></span><span class="switch-label" style="font-size:13px;">Order matters</span></label>
          <label class="switch"><input type="checkbox" id="optRandomizeOptions"><span class="slider"></span><span class="switch-label" style="font-size:13px;">Randomize options</span></label>
        </div>
      </div>
      <div id="idFields" style="display:none;">
        <input type="text" id="identificationAnswer" placeholder="Correct answer">
        <div style="margin-top:8px;" class="settings-row">
          <label class="switch"><input type="checkbox" id="idCaseSensitive"><span class="slider"></span><span class="switch-label" style="font-size:13px;">Case sensitive</span></label>
          <label class="switch"><input type="checkbox" id="idOrderMatters"><span class="slider"></span><span class="switch-label" style="font-size:13px;">Order matters</span></label>
        </div>
      </div>
      <div id="tfFields" style="display:none;">
        <label><input type="radio" name="trueFalseAnswer" value="True"> True</label>
        <label><input type="radio" name="trueFalseAnswer" value="False"> False</label>
      </div>
        <div style="text-align:right; margin-top:12px;">
          <button class="save-question-btn" onclick="saveQuestion()">Save</button>
          <button class="cancel-btn" onclick="closeQuestionModal()">Close</button>
        </div>
    </div>
  </div>

      <!-- Sections Modal -->
      <div class="modal" id="sectionsModal" aria-hidden="true">
        <div class="modal-content" style="max-width:900px; max-height:85vh; overflow:hidden;">
          <div class="modal-header">
            <h2>Sections & Transferred Students</h2>
            <span class="close" id="closeSectionsModal">&times;</span>
          </div>
          <div id="sectionsModalContent" style="padding:8px; max-height:calc(85vh - 120px); overflow:auto;">
            <p>Loading sections...</p>
          </div>
          <div style="text-align:right; margin-top:8px;">
          <button class="cancel-btn" id="closeSectionsModalBtn">Close</button>
          </div>
        </div>
      </div>
</div>

<script>
const firebaseConfig = {
  apiKey: "AIzaSyBkmM4hueT7PlnvV8FeRdp8g4rk0qQQrn4",
  authDomain: "midnightmathscape.firebaseapp.com",
  databaseURL: "https://midnightmathscape-e8e70-default-rtdb.firebaseio.com/",
  projectId: "midnightmathscape",
  storageBucket: "midnightmathscape.appspot.com",
  messagingSenderId: "1038485290511",
  appId: "1:1038485290511:web:c8aa78fbcd5266b706ed7a"
};
firebase.initializeApp(firebaseConfig);
const rtdb = firebase.database();
// Toggle to show per-question normalization/debug info in attempt modal
let EVAL_DEBUG = false;

// Safe HTML escape helper
function escapeHtml(str){
  if(str === null || str === undefined) return '';
  return String(str)
    .replace(/&/g,'&amp;')
    .replace(/</g,'&lt;')
    .replace(/>/g,'&gt;')
    .replace(/"/g,'&quot;')
    .replace(/'/g,'&#39;');
}

// Count students from StudentAccount in realtime
const totalStudentsEl = document.getElementById('totalStudents');
rtdb.ref('StudentAccount').on('value', snap => {
  if (!snap.exists()) {
    totalStudentsEl.textContent = '0';
    return;
  }
  const students = snap.val();
  totalStudentsEl.textContent = Object.keys(students).length;
});

// CSV export helper for StudentAccount
async function exportStudentsCsv(){
  const snap = await rtdb.ref('StudentAccount').get();
  if(!snap.exists()){ alert('No students found'); return; }
  const data = snap.val();
  const rows = [];
  // header: include section and score summaries
  rows.push(['uid','firstname','lastname','section','totalAttempts','avgScore','lastScore','lastDate','exportedAt']);
  // fetch QuizResults to compute simple score summaries per student
  const qrSnap = await rtdb.ref('QuizResults').get();
  const quizResults = qrSnap.exists() ? qrSnap.val() : {};
  // try to read possible section mapping nodes (common names)
  const sectionsCandidates = ['Sections','Section','sections','sectionList','SectionList','SectionsList'];
  const sectionMap = {};
  // uid -> sectionName mapping (populated from SectionList if present)
  let uidToSection = {};
  try{
    const rootSnap = await rtdb.ref().get();
    const rootVal = rootSnap.exists() ? rootSnap.val() : {};
    for(const candidate of sectionsCandidates){
      if(rootVal[candidate] && typeof rootVal[candidate] === 'object'){
        Object.assign(sectionMap, rootVal[candidate]);
      }
    }
    // build uid -> sectionName map by scanning SectionList and common variants
    if(rootVal){
      const sectionNodes = ['SectionList','sectionList','Sections','sections'];
      sectionNodes.forEach(nodeName => {
        if(rootVal[nodeName] && typeof rootVal[nodeName] === 'object'){
          try{
            Object.keys(rootVal[nodeName]).forEach(sid => {
              const sec = rootVal[nodeName][sid] || {};
              const name = sec.name || sec.title || sid;
              if(sec.students && typeof sec.students === 'object'){
                Object.keys(sec.students).forEach(uid => { uidToSection[uid] = name; });
              }
            });
          }catch(e){ /* ignore */ }
        }
      });
    }
    // Also merge transferred students that may be stored under SectionList or similar nodes
    const transferredNodes = ['SectionList','sectionList','TransferredStudents','sectionTransfers','transferredStudents'];
    for(const nodeName of transferredNodes){
      if(rootVal && rootVal[nodeName] && typeof rootVal[nodeName] === 'object'){
        try{
          const node = rootVal[nodeName];
          // node may be sectionId -> { students: { uid: { ... } } } or flat uid -> { ... }
          Object.keys(node).forEach(key => {
            const sectionBlock = node[key];
            if(sectionBlock && sectionBlock.students && typeof sectionBlock.students === 'object'){
              Object.keys(sectionBlock.students).forEach(uid => {
                if(!data[uid]){
                  const stu = sectionBlock.students[uid] || {};
                  data[uid] = Object.assign({ firstname: stu.firstName || stu.firstname || stu.name || '', lastname: stu.lastName || stu.lastname || '', sectionId: stu.sectionId || stu.section || key }, stu);
                }
              });
            } else if(sectionBlock && sectionBlock.uid && sectionBlock.uid.students && typeof sectionBlock.uid.students === 'object'){
              // defensive: nested one deeper
              Object.keys(sectionBlock.uid.students).forEach(uid => {
                if(!data[uid]){
                  const stu = sectionBlock.uid.students[uid] || {};
                  data[uid] = Object.assign({ firstname: stu.firstName || stu.firstname || stu.name || '', lastname: stu.lastName || stu.lastname || '', sectionId: stu.sectionId || stu.section || key }, stu);
                }
              });
            } else if(sectionBlock && typeof sectionBlock === 'object' && Object.keys(sectionBlock).length>0){
              // fallback: maybe it's a flat map of uid -> student
              Object.keys(sectionBlock).forEach(uid => {
                const maybeStu = sectionBlock[uid];
                if(maybeStu && (maybeStu.firstname || maybeStu.firstName || maybeStu.lastName || maybeStu.lastname)){
                  if(!data[uid]){
                    data[uid] = Object.assign({ firstname: maybeStu.firstName || maybeStu.firstname || '', lastname: maybeStu.lastName || maybeStu.lastname || '', sectionId: maybeStu.sectionId || maybeStu.section || key }, maybeStu);
                  }
                }
              });
            }
          });
        }catch(e){ console.debug('failed merging transferred node', nodeName, e); }
      }
    }
  }catch(e){ console.debug('section map read failed', e); }
  for(const uid of Object.keys(data)){
    const s = data[uid] || {};
    // normalize name fields (various historical keys)
    const firstname = s.firstname || s.firstName || s.first || s.name || '';
    const lastname = s.lastname || s.lastName || s.surname || s.last || '';
    // aggregate scores from quizResults[uid]
    let totalAttempts = 0, sumScore = 0, lastScore = '', lastDate = '';
    const userQr = quizResults[uid] || {};
    for(const ch of Object.keys(userQr)){
      const chapter = userQr[ch] || {};
      for(const attemptKey of Object.keys(chapter)){
        const a = chapter[attemptKey] || {};
        if(a.score !== undefined && a.score !== null && !isNaN(Number(a.score))){ totalAttempts++; sumScore += Number(a.score); }
        const d = a.date || a.createdAt || a.time || '';
        if(d){
          // prefer ISO-parsable date, fall back to string compare
          try{
            const parsed = Date.parse(d);
            if(!isNaN(parsed)){
              if(!lastDate || parsed > Date.parse(lastDate)) { lastDate = d; lastScore = a.score !== undefined ? a.score : lastScore; }
            } else {
              if(!lastDate || String(d) > String(lastDate)) { lastDate = d; lastScore = a.score !== undefined ? a.score : lastScore; }
            }
          }catch(e){ /* ignore parse errors */ }
        }
      }
    }
    const avgScore = totalAttempts ? (sumScore / totalAttempts) : '';
    // resolve section name via sectionMap if possible, else pick stored sectionId from student record
    const sectionId = s.sectionId || s.section || s.sectionName || s.section_id || '';
  // prefer uid->section mapping (transfers), then sectionMap lookup, else raw id
  const sectionName = uidToSection[uid] || ((sectionId && sectionMap && sectionMap[sectionId]) ? (sectionMap[sectionId].title || sectionMap[sectionId].name || sectionMap[sectionId].sectionName || String(sectionMap[sectionId])) : (sectionId || ''));
    const exportedAt = new Date().toISOString();
    rows.push([
      uid,
      firstname,
      lastname,
      sectionName,
      totalAttempts,
      (avgScore === '' ? '' : Math.round(Number(avgScore) * 100)/100),
      lastScore,
      lastDate
      , exportedAt
    ]);
  }
  // convert to CSV string
  const csvContent = rows.map(r => r.map(cell => '"' + String(cell).replace(/"/g,'""') + '"').join(',')).join('\r\n');
  // add UTF-8 BOM so Excel on Windows recognizes encoding
  const bom = '\uFEFF';
  const blob = new Blob([bom + csvContent], { type: 'text/csv;charset=utf-8;' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  const ts = new Date().toISOString().replace(/[:\.]/g,'-');
  a.href = url; a.download = `students_${ts}.csv`; document.body.appendChild(a); a.click(); a.remove();
  setTimeout(()=> URL.revokeObjectURL(url), 5000);
}

// wire export button
document.addEventListener('click', (e)=>{
  const btn = e.target.closest && e.target.closest('#exportStudentsBtn');
  if(!btn) return;
  exportStudentsCsv().catch(err=>{ console.error('exportStudentsCsv failed', err); alert('Export failed: '+ (err && err.message?err.message:err)); });
});

// Sections modal handlers
let sectionsCache = {};
document.addEventListener('click', (e)=>{
  const b = e.target.closest && e.target.closest('#viewSectionsBtn');
  if(!b) return;
  openSectionsModal();
});
// DB scan button handler (opt-in root scan)
document.addEventListener('click', (e)=>{
  const btn = e.target.closest && e.target.closest('#scanDbBtn');
  if(!btn) return;
  // confirm with user
  if(!confirm('This will read the entire Realtime Database root to look for quiz/chapter nodes. Continue?')) return;
  scanDatabaseRootForQuizzes().catch(err=>{ console.error('DB scan failed', err); alert('DB scan failed: '+ (err && err.message? err.message:String(err))); });
});

// Create modal for scan results
if(!document.getElementById('dbScanModal')){
  const m = document.createElement('div'); m.id='dbScanModal'; m.className='modal'; m.style.display='none';
  m.innerHTML = `<div class="modal-content" style="max-width:900px;"><div class="modal-header"><h2>DB Scan Results</h2><span class="close" id="closeDbScan">&times;</span></div><div id="dbScanContent" style="max-height:60vh;overflow:auto;padding:8px">No results yet</div></div>`;
  document.body.appendChild(m);
  document.getElementById('closeDbScan').addEventListener('click', ()=>{ m.style.display='none'; });
}

// Scan the RTDB root for candidate quiz/chapter nodes and show results
async function scanDatabaseRootForQuizzes(){
  const modal = document.getElementById('dbScanModal'); const content = document.getElementById('dbScanContent');
  if(!modal || !content) return;
  content.innerHTML = '<p>Scanning root... this may take a moment.</p>';
  modal.style.display='flex'; modal.style.setProperty('position','fixed','important'); modal.style.setProperty('z-index','2147483647','important');
  try{
    const rootSnap = await rtdb.ref().get();
    if(!rootSnap.exists()){ content.innerHTML = '<p>Database root is empty.</p>'; return; }
    const root = rootSnap.val();
    const candidates = [];
    // top-level keys that look like quizzes/chapters
    for(const k of Object.keys(root)){
      const kl = String(k).toLowerCase();
      if(kl.includes('quiz') || kl.includes('quizzes') || kl.includes('chapter') || kl.includes('chapters') || kl==='quizzes' || kl==='quiz'){
        candidates.push({ path: k, reason: 'top-level name'});
      }
      // also scan one level deeper for 'questions' nodes and numeric chapter keys
      try{
        const node = root[k];
        if(node && typeof node === 'object'){
          for(const kk of Object.keys(node)){
            const kkl = String(kk).toLowerCase();
            const path = `${k}/${kk}`;
            if(kkl.includes('quiz') || kkl.includes('quizzes') || kkl.includes('chapter') || kkl.includes('questions') || /^chapter\s*\d+$/.test(kkl) || /^chapter\d+$/.test(kkl) || /^\d+$/.test(kkl)){
              candidates.push({ path, reason: 'second-level match' });
            }
            // look deeper one more level for '/questions' under candidate
            try{
              const sub = node[kk];
              if(sub && typeof sub === 'object'){
                if(Object.prototype.hasOwnProperty.call(sub,'questions')) candidates.push({ path:`${k}/${kk}/questions`, reason:'contains questions' });
                if(Object.prototype.hasOwnProperty.call(sub,'choices') || Object.prototype.hasOwnProperty.call(sub,'questionIndex')) candidates.push({ path:`${k}/${kk}`, reason:'looks like question objects' });
              }
            }catch(e){}
          }
        }
      }catch(e){}
    }
    // always check canonical 'quizzes' path
    try{ if(root.quizzes) candidates.push({ path:'quizzes', reason:'canonical path present' }); }catch(e){}
    // dedupe
    const byPath = {}; candidates.forEach(c=>{ byPath[c.path] = c; });
    const rows = Object.keys(byPath).map(p=> `<li><b>${escapeHtml(p)}</b> — ${escapeHtml(byPath[p].reason)}</li>` ).join('');
    content.innerHTML = `<p>Found ${Object.keys(byPath).length} candidate paths:</p><ul>${rows}</ul><p>Note: this is a heuristic scan. If you see a likely path, copy it and tell me and I'll make the UI try it directly.</p>`;
  }catch(err){ console.error('scanDatabaseRootForQuizzes failed', err); content.innerHTML = `<pre>${escapeHtml(String(err && err.message?err.message:String(err)))}</pre>`; }
}
document.getElementById('closeSectionsModal')?.addEventListener('click', closeSectionsModal);
document.getElementById('closeSectionsModalBtn')?.addEventListener('click', closeSectionsModal);

async function openSectionsModal(){
  const modal = document.getElementById('sectionsModal');
  const content = document.getElementById('sectionsModalContent');
  if(!modal || !content) return;
  content.innerHTML = '<p>Loading sections...</p>';
  try{
    const snap = await rtdb.ref('SectionList').get();
    if(!snap.exists()){ content.innerHTML = '<p>No SectionList found.</p>'; }
    else{
      const sections = snap.val();
      // cache for lookups (sectionId -> sectionObject)
      sectionsCache = sections || {};
      const keys = Object.keys(sections || {});
      if(keys.length===0){ content.innerHTML = '<p>No sections available.</p>'; }
      else{
        let html = '';
        for(const sid of keys){
          const s = sections[sid] || {};
          const name = s.name || s.title || sid;
          const students = s.students || {};
          const uids = Object.keys(students || {});
          // disable view button when there are no students to prevent opening an empty view
          const hasStudents = (uids && uids.length>0);
          html += `<div style="border:1px solid #eee;padding:10px;border-radius:8px;margin-bottom:8px;">
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px;"><div><strong>${escapeHtml(name)}</strong></div><div>`;
          if(hasStudents){
            html += `<button class="view-section-answers-btn" data-section-id="${escapeHtml(sid)}">View Section Answers</button>`;
          } else {
            html += `<button class="view-section-answers-btn" data-section-id="${escapeHtml(sid)}" disabled title="No students in this section">View Section Answers</button>`;
          }
          html += `</div></div>`;
          if(!hasStudents) html += `<div style="color:#666">No students</div>`;
          else{
            html += `<div style="display:flex;flex-direction:column;gap:6px;">`;
            for(const uid of uids){
              html += `<div style=\"display:flex;justify-content:space-between;align-items:center;gap:8px;\">
                <div><button class=\"answers-btn\" data-section-uid=\"${escapeHtml(sid+'|'+uid)}\">View</button> <strong>${escapeHtml(uid)}</strong></div>
                <div style=\"color:#666\">${escapeHtml(students[uid]===true?'-':String(students[uid]))}</div>
              </div>`;
            }
            html += `</div>`;
          }
          html += `</div>`;
        }
        content.innerHTML = html;
      }
    }
  }catch(err){ console.error('openSectionsModal failed', err); content.innerHTML = '<pre>'+escapeHtml(err && err.message?err.message:String(err))+'</pre>'; }
  // show modal (reuse styles used elsewhere)
  modal.style.display='flex';
  // append to body in case of CSS specificity hiding
  if(!modal.parentNode || modal.parentNode !== document.body) document.body.appendChild(modal);
  modal.style.setProperty('position','fixed','important'); modal.style.setProperty('z-index','2147483646','important');
}

function closeSectionsModal(){ const modal = document.getElementById('sectionsModal'); if(modal) modal.style.display='none'; }

// delegated click handler inside sections modal: when a 'View' button is clicked show student details
document.addEventListener('click', async (e)=>{
  const btn = e.target.closest && e.target.closest('[data-section-uid]');
  if(!btn) return;
  const v = btn.getAttribute('data-section-uid');
  if(!v) return;
  const [sectionId, uid] = v.split('|');
  const content = document.getElementById('sectionsModalContent');
  if(!content) return;
  content.innerHTML = `<p>Loading student ${escapeHtml(uid)}...</p>`;
  try{
    const accSnap = await rtdb.ref('StudentAccount/'+uid).get();
    const credSnap = await rtdb.ref('Cridentials/'+uid).get();
    const acc = accSnap.exists() ? accSnap.val() : null;
    const cred = credSnap.exists() ? credSnap.val() : null;
    let html = `<div style="padding:8px;max-width:820px;">
      <h3>${escapeHtml(uid)}</h3>
      <table style=\"width:100%;border-collapse:collapse;\">`;
    const fields = {};
    if(acc) Object.assign(fields, acc);
    if(cred) Object.assign(fields, cred);
    fields.sectionId = fields.sectionId || sectionId;
    // resolve sectionId to friendly name if available
    try{
      if(fields.sectionId && sectionsCache && sectionsCache[fields.sectionId]){
        fields.section = sectionsCache[fields.sectionId].name || sectionsCache[fields.sectionId].title || fields.sectionId;
      } else {
        fields.section = fields.section || fields.sectionId || '';
      }
    }catch(e){ fields.section = fields.section || fields.sectionId || ''; }
    for(const k of Object.keys(fields)){
      // hide raw sectionId now that we provide 'section'
      if(k === 'sectionId') continue;
      // hide sensitive fields
      if(['pass','password','sessionToken'].includes(k)) continue;
      html += `<tr><td style=\"padding:6px;border:1px solid #eee;width:30%;font-weight:600;\">${escapeHtml(k)}</td><td style=\"padding:6px;border:1px solid #eee;\">${escapeHtml(String(fields[k]===undefined? '': fields[k]))}</td></tr>`;
    }
  html += `</table></div>`;
    content.innerHTML = html;
  }catch(err){ console.error('failed loading student', err); content.innerHTML = '<pre>'+escapeHtml(err && err.message?err.message:String(err))+'</pre>'; }
});

let editingQuestionId = null;
let currentChapter = null;

const chapterTitles = {
  chapter1:"Chapter 1: Midnight Hideout ", chapter2:"Chapter 2: Whispering Shelves", chapter3:"Chapter 3: Shattered Glass",
  chapter4:"Chapter 4: Silent Halls", chapter5:"Chapter 5: Echoes of Lunch", chapter6:"Chapter 6: Rooftop Rush",
  chapter7:"Chapter 7: Creaking Scaffold", chapter8:"Chapter 8: Flickering Screens", chapter9:"Chapter 9: Whispering Papers",
  chapter10:"Chapter 10: Creeping Silence", chapter11:"Chapter 11: Locked Secrets", chapter12:"Chapter 12: Freedom’s Edge"
};

// Build chapters UI
const container = document.getElementById('chaptersContainer');
Object.keys(chapterTitles).forEach(ch => {
  const header = document.createElement('div');
  header.className = 'data-header';
  header.dataset.chapter = ch;
  header.innerHTML = `<h3>${chapterTitles[ch]}</h3><i class="fa-solid fa-chevron-right"></i>`;
  const body = document.createElement('div');
  body.className = 'chapter-body';
  body.id = 'body-'+ch;
  body.innerHTML = `
    <div class="tabs">
      <div class="tab active" data-tab="questions">Question Management</div>
      <div class="tab" data-tab="progress">Student Progress</div>
    </div>
    <div id="questions-tab-${ch}"></div>
    <div id="progress-tab-${ch}" style="display:none;"></div>
  `;
  container.appendChild(header);
  container.appendChild(body);

  header.addEventListener('click', () => {
    const open = header.classList.contains('open');
    document.querySelectorAll('.data-header').forEach(h=>h.classList.remove('open'));
    document.querySelectorAll('.chapter-body').forEach(b=>b.style.display='none');
    if(!open){ header.classList.add('open'); body.style.display='block'; loadChapterQuestions(ch); }
  });
});

// Tabs
document.addEventListener('click', e=>{
  if(e.target.classList.contains('tab')){
    const tab=e.target, ch=tab.closest('.chapter-body').id.replace('body-','');
    tab.parentNode.querySelectorAll('.tab').forEach(t=>t.classList.remove('active'));
    tab.classList.add('active');
    document.getElementById(`questions-tab-${ch}`).style.display=tab.dataset.tab==='questions'?'block':'none';
    document.getElementById(`progress-tab-${ch}`).style.display=tab.dataset.tab==='progress'?'block':'none';
    if(tab.dataset.tab==='progress'){ subscribeStudentProgress(ch); }
  }
});

// Get next sequential question index
async function getNextQuestionIndex(ch){
  try{
  let qFound = await findQuizQuestions(ch);
    if(!qFound || !qFound.snap || !qFound.snap.exists()) return 1;
    const snap = qFound.snap;
    const indexes = [];
    snap.forEach(child=>indexes.push(parseInt(child.key)));
    return Math.max(...indexes)+1;
  }catch(e){ console.debug('getNextQuestionIndex failed', e); return 1; }
}

// Load questions
async function loadChapterQuestions(ch){
  currentChapter = ch;
  const container = document.getElementById(`questions-tab-${ch}`);
  container.innerHTML = `<button class="add-question-btn" onclick="openQuestionModal('${ch}')"><i class="fas fa-plus"></i> Add Question</button><div id="questions-list-${ch}">Loading...</div>`;
  const list = document.getElementById(`questions-list-${ch}`);
  // try to load questions from any variant of the chapter key
  let qFound = await findQuizQuestions(ch);
  if(!qFound || !qFound.snap || !qFound.snap.exists()){ 
    const tried = (qFound && qFound.triedPaths) ? qFound.triedPaths.join(', ') : 'unknown paths';
    list.innerHTML = `<p>No questions yet. Tried: ${escapeHtml(tried)}</p>`; return; }
  list.innerHTML = "";
    qFound.snap.forEach(child=>{
    const q = child.val(), id = child.key;
    let optionsHtml="";
    if(q.type==="multiple_choice"){
      // respect randomizeOptions: when randomizing, we must still mark correct answer
      const choices = Array.isArray(q.choices) ? q.choices.slice() : [];
      let displayChoices = choices.slice();
      if(q.randomizeOptions){ displayChoices = shuffle(displayChoices); }
      // determine canonical correct options and mark accordingly
      const correctOptionsText = getCanonicalAnswers(q);
      const normCanonical = (correctOptionsText||[]).map(x=> typeof x === 'string' ? (q.caseSensitive ? String(x).trim() : String(x).toLowerCase().trim()) : String(x));
      displayChoices.forEach(opt=>{
        const normOpt = normalizeForCompare(q, opt);
        const correct = normOpt !== null && normCanonical.some(co => co === normOpt);
        optionsHtml += `<div class="question-option ${correct? 'correct-answer':''}">${escapeHtml(opt)}</div>`;
      });
      optionsHtml += `<p style="font-size:12px;color:#666;margin-top:6px">Case sensitive: ${q.caseSensitive? 'Yes':'No'} &nbsp; | &nbsp; Order matters: ${q.orderMatters? 'Yes':'No'} &nbsp; | &nbsp; Randomize: ${q.randomizeOptions? 'Yes':'No'}</p>`;
    } else {
      optionsHtml = `<div class="question-option"><b>Answer:</b> ${q.answer}</div>`;
    }
    list.innerHTML += `
      <div class="question-item">
        <div class="question-text">[${q.questionIndex}] ${q.question}</div>
        <div class="question-options">${optionsHtml}</div>
        <p><b>Show Answer:</b> ${q.showAnswer}</p>
        <div class="question-actions">
          <button class="edit-btn" onclick="openEditModal('${ch}','${id}')">Edit</button>
          <button class="delete-btn" onclick="deleteQuestion('${ch}','${id}')">Delete</button>
        </div>
      </div>`;
  });
}

// --- Preview / Evaluation helper (instructor testing) ---
// Render a simple preview box at the bottom of the questions list for the current chapter
function renderPreviewBox(ch){
  const container = document.getElementById(`questions-tab-${ch}`);
  // append preview area if not present
  if(!document.getElementById('previewArea')){
    const preview = document.createElement('div');
    preview.id = 'previewArea';
    preview.style.marginTop = '12px';
    preview.innerHTML = `<div style="padding:12px;border-radius:8px;background:#fff;border:1px solid #eee;"><h4>Preview / Test</h4><div id='previewContent'>Select a question from the list to preview it here (click Edit then Close to return)</div></div>`;
    container.appendChild(preview);
  }
}

// Evaluate answer against a question object q and a provided response
// For multiple_choice: response can be the option text (string) or array of strings if multiple answers expected
function evaluateAnswer(q, response){
  if(!q) return false;
  if(q.type === 'multiple_choice'){
    const caseSensitive = !!q.caseSensitive;
    const normalize = v => caseSensitive ? String(v).trim() : String(v).toLowerCase().trim();

    // Normalize student response into canonical display texts
    const respNorm = normalizeStudentResponse(q, response);
    const rArr = Array.isArray(respNorm) ? respNorm.map(x=>normalize(x)) : (respNorm===undefined||respNorm===null?[]:[normalize(respNorm)]);

    // Derive canonical correct answer(s) from the question definitions (from quizzes node)
    const ansArrRaw = getCanonicalAnswers(q);
    const aArr = (ansArrRaw||[]).map(x=> normalize(x));

    if(q.orderMatters){
      if(rArr.length !== aArr.length) return false;
      for(let i=0;i<rArr.length;i++) if(rArr[i] !== aArr[i]) return false;
      return true;
    } else {
      // compare as sets (order-insensitive)
      rArr.sort(); aArr.sort();
      return JSON.stringify(rArr) === JSON.stringify(aArr);
    }
  } else if(q.type === 'identification'){
    const caseSensitive = !!q.caseSensitive;
    const normalize = v => caseSensitive ? String(v).trim() : String(v).toLowerCase().trim();
    return normalize(response) === normalize(q.answer);
  } else if(q.type === 'true_false'){
    return String(response).toLowerCase() === String(q.answer).toLowerCase();
  }
  return false;
}

// Shuffle helper
function shuffle(array){
  for(let i = array.length -1; i>0; i--){
    const j = Math.floor(Math.random()*(i+1));
    [array[i], array[j]] = [array[j], array[i]];
  }
  return array;
}

// Map stored student response (possibly numeric index or array of indices) to choice text(s)
function normalizeStudentResponse(q, studentResp){
  if(!q) return studentResp;
  // If no choices available, return original
  // Support both array-form choices or object-form choices (e.g. {A: 'x', B: 'y'})
  const choices = Array.isArray(q.choices) ? q.choices : (q.choices ? Object.values(q.choices) : []);
  const rawChoicesObj = (q.choices && !Array.isArray(q.choices) && typeof q.choices === 'object') ? q.choices : null;
  // If choices are provided as an object keyed by letters (A/B/C...), build a letter->text map
  const letterMap = {};
  if(rawChoicesObj){
    try{
      Object.keys(rawChoicesObj).forEach(k => {
        if(!k) return;
        const m = String(k).trim().match(/^([A-Za-z])/);
        if(m){ letterMap[m[1].toUpperCase()] = rawChoicesObj[k]; }
      });
    }catch(e){ /* ignore */ }
  }
  // If no choices are defined (identification or TF), just return trimmed/raw student value
  if(!choices || choices.length===0){
    if(Array.isArray(studentResp)) return studentResp.map(x=> (x===null||x===undefined)?x:String(x).trim());
    return (studentResp===null||studentResp===undefined)?studentResp:String(studentResp).trim();
  }
  // helper to find the canonical choice text from choices array that matches a candidate
  const findChoiceMatch = (candidate) => {
    if(candidate === null || candidate === undefined) return null;
    const cand = String(candidate).trim();
    if(cand === '') return null;
    const candNorm = cand.toLowerCase();
    // If we have a letter-keyed choices map, prefer direct letter lookups
    const letterMatch = cand.match(/^([A-Za-z])\b|^([A-Za-z])(?=[\.\)\-\s])/);
    if(letterMatch){
      const L = (letterMatch[1] || letterMatch[2] || '').toUpperCase();
      if(L && letterMap && letterMap[L] !== undefined) return letterMap[L];
    }
    // direct exact or stripped matches
    for(const opt of choices){
      const optNorm = String(opt).toLowerCase().trim();
      if(optNorm === candNorm) return opt;
      const optStripped = String(opt).replace(/^[A-Za-z]\s*[\.\)]\s*/,'').replace(/^\d+\.\s*/,'').trim();
      if(optStripped.toLowerCase() === candNorm) return opt;
    }
    // letter to index match: single letter like 'A' -> index 0
    if(/^[A-Za-z]$/.test(cand)){
      const idx = cand.toUpperCase().charCodeAt(0) - 65;
      if(choices[idx] !== undefined) return choices[idx];
    }
    // numeric string index '1' -> index 0
    if(!isNaN(Number(cand))){
      const n = Number(cand);
      // prefer 1-based numeric answers (e.g., '1' -> choices[0]) but accept 0-based if present
      if(choices[n-1] !== undefined) return choices[n-1];
      if(choices[n] !== undefined) return choices[n];
    }
    return null;
  };

  // map a single token (try choices, letter, numeric)
  const mapToken = (tok) => {
    if(tok === null || tok === undefined) return undefined;
    const s = String(tok).trim();
    if(s === '') return undefined;
    const low = s.toLowerCase();
    if(['-','null','n/a','no response','none','na','invalid choice','.','invalid','(no response)'].indexOf(low) !== -1) return undefined;
  // try direct match / letter / number
  const m = findChoiceMatch(s);
  if(m) return m;
  // strip common single-letter prefixes only when they look like choice markers
  // e.g. 'D. √(-9)', 'D) √(-9)', or 'D √(-9)' where the char after space is non-alphanumeric
  let stripped = s;
  // case 1: letter followed by '.' or ')' then space
  stripped = stripped.replace(/^[A-Za-z][\.\)]\s+/, '');
  // case 2: letter followed by space then a non-alphanumeric (e.g., 'D √...')
  stripped = stripped.replace(/^[A-Za-z]\s+(?=[^A-Za-z0-9\s])/, '');
  // case 3: numeric list prefix like '1. '
  stripped = stripped.replace(/^\d+\.\s*/, '').trim();
  if(stripped && stripped !== s){ const m2 = findChoiceMatch(stripped); if(m2) return m2; }
    return stripped || s;
  };

  // helper that maps one value (number/string) to canonical choice text or undefined
  const mapOne = (v) => {
    if(v === null || v === undefined) return undefined;
    if(typeof v === 'number'){
      // prefer interpreting numeric answers as 1-based (1 -> first choice)
      if(choices[v-1] !== undefined) return choices[v-1];
      if(choices[v] !== undefined) return choices[v];
      return undefined;
    }
    // if it's an array encoded as JSON in a string, try parse
    if(typeof v === 'string' && (v.trim().startsWith('[') || v.trim().startsWith('{'))){
      try{ const parsed = JSON.parse(v); if(Array.isArray(parsed)) return parsed.map(p=>mapToken(p)).filter(x=>x!==undefined); }catch(e){}
    }
    if(Array.isArray(v)){
      const mapped = v.map(x=>mapToken(x)).filter(x=> x !== undefined && x !== null && String(x).trim() !== '');
      return mapped.length ? mapped : [];
    }
    return mapToken(v);
  };

  if(Array.isArray(studentResp)){
    const mapped = studentResp.map(mapOne).filter(x=> x !== undefined && x !== null && (Array.isArray(x) ? x.length>0 : String(x).trim() !== ''));
    return mapped.length ? mapped : [];
  }
  return mapOne(studentResp);
}

// Derive the canonical correct answer(s) for a question as display text(s)
function getCanonicalAnswers(q){
  if(!q) return [];
  try{
    const ansNorm = normalizeStudentResponse(q, q.answer);
    if(ansNorm === undefined || ansNorm === null) return [];
    if(Array.isArray(ansNorm)) return ansNorm.filter(x=> x!==undefined && x!==null);
    return [ansNorm];
  }catch(e){ console.debug('getCanonicalAnswers failed', e); return []; }
}

// Helper: normalize a value into a comparable string (or array of strings) for comparisons
// Returns either a single normalized string, an array of normalized strings, or null
function normalizeForCompare(q, val){
  if(val === undefined || val === null) return null;
  try{
    if(q && q.type === 'multiple_choice'){
      // normalizeStudentResponse maps indices/letters/encoded arrays to canonical choice text(s)
      const mapped = normalizeStudentResponse(q, val);
      const caseSensitive = !!q.caseSensitive;
      const norm = v => caseSensitive ? String(v).trim() : String(v).toLowerCase().trim();
      if(mapped === undefined || mapped === null) return null;
      // further normalize numeric/currency formats so '₱200' and '200' match, and '3.50' normalizes to '3.5'
      const clean = (s) => {
        if(s === undefined || s === null) return null;
        let t = String(s).trim();
        // remove common currency symbols and thousands separators
        t = t.replace(/[₱$£€,\s]/g,'');
        // if it's a pure number after stripping, return canonical numeric string
        if(/^[-+]?\d*(?:\.\d+)?$/.test(t)){
          const n = Number(t);
          if(!isNaN(n)) return String(n);
        }
        return caseSensitive ? String(s).trim() : String(s).toLowerCase().trim();
      };
      if(Array.isArray(mapped)) return mapped.map(x=> clean(x)).filter(x=> x !== undefined && x !== null && String(x)!='');
      return clean(mapped);
    }
    // fallback for non-multiple choice
    const caseSensitive = q && q.caseSensitive;
    let t = caseSensitive ? String(val).trim() : String(val).toLowerCase().trim();
    // strip currency for non-MC as well
    t = t.replace(/[₱$£€,]/g,'');
    return t;
  }catch(e){ console.debug('normalizeForCompare failed', e); return null; }
}

// Robust extractor: get student response for a question key/index from various attempt shapes
function extractStudentResponse(attemptObj, qk, qIndex){
  if(!attemptObj) return undefined;
  // common shapes
  if(attemptObj.answers && attemptObj.answers[qk] !== undefined) return attemptObj.answers[qk];
  if(attemptObj.answers && attemptObj.answers['q'+qk] !== undefined) return attemptObj.answers['q'+qk];
  if(attemptObj.answers && attemptObj.answers['Q'+qk] !== undefined) return attemptObj.answers['Q'+qk];
  if(attemptObj.answers && attemptObj.answers[qIndex] !== undefined) return attemptObj.answers[qIndex];
  if(attemptObj.answers && attemptObj.answers['q'+qIndex] !== undefined) return attemptObj.answers['q'+qIndex];
  if(attemptObj.answers && attemptObj.answers['Q'+qIndex] !== undefined) return attemptObj.answers['Q'+qIndex];
  if(attemptObj.responses && attemptObj.responses[qk] !== undefined) return attemptObj.responses[qk];
  if(Array.isArray(attemptObj.responses) && attemptObj.responses.length >= qIndex) return attemptObj.responses[qIndex-1];
  if(attemptObj.responsesArray && Array.isArray(attemptObj.responsesArray) && attemptObj.responsesArray.length >= qIndex) return attemptObj.responsesArray[qIndex-1];
  if(attemptObj[qk] !== undefined) return attemptObj[qk];
  if(attemptObj['q'+qk] !== undefined) return attemptObj['q'+qk];
  if(attemptObj['Q'+qk] !== undefined) return attemptObj['Q'+qk];
  if(attemptObj['q'+qk] !== undefined) return attemptObj['q'+qk];
  if(attemptObj[String(qk)] !== undefined) return attemptObj[String(qk)];
  // some QuizResults store answers under a top-level 'answers' object with numeric keys as strings
  if(attemptObj.answers && typeof attemptObj.answers === 'object'){
    if(attemptObj.answers[String(qIndex)] !== undefined) return attemptObj.answers[String(qIndex)];
    // try to find keys like 'Q1', 'q1', or any key whose numeric part equals qIndex (robust matching)
    for(const k of Object.keys(attemptObj.answers)){
      if(!k) continue;
      const num = k.replace(/\D/g,'');
      if(num === String(qIndex)) return attemptObj.answers[k];
    }
    // tolerant matching: some exports store question numbers 1-based while our questions map may be 0-based (or vice versa).
    // Try matching numeric part equal to qIndex+1 or qIndex-1 as fallback.
    for(const k of Object.keys(attemptObj.answers)){
      if(!k) continue;
      const num = k.replace(/\D/g,'');
      if(num === String(qIndex+1)) return attemptObj.answers[k];
      if(qIndex>0 && num === String(qIndex-1)) return attemptObj.answers[k];
    }
  }
  return undefined;
}

// Fetch student name
async function getStudentName(sid){
  const snap = await rtdb.ref("StudentAccount/"+sid).get();
  if(!snap.exists()) return sid;
  const acc = snap.val();
  // prefer canonical camelCase keys, fallback to older lowercase ones
  const fn = acc.firstName || acc.firstname || acc.name || '';
  const ln = acc.lastName || acc.lastname || '';
  const full = (fn + ' ' + ln).trim();
  return full || sid;
}

// Subscribe to student progress (real-time)
function subscribeStudentProgress(ch){
  const container=document.getElementById(`progress-tab-${ch}`);
  container.innerHTML="<p>Loading...</p>";

  rtdb.ref().on("value", async snapshot=>{
    const allData = snapshot.val() || {};
  const quizResults = allData.QuizResults || {};

    // Collect attempts per student: { sid: [ {score, date, timeSpent, source, attemptIndex}, ... ] }
    const attemptsByStudent = {};

    // Helper to push attempt
    function pushAttempt(sid, attempt){
      if(!attemptsByStudent[sid]) attemptsByStudent[sid] = [];
      attemptsByStudent[sid].push(attempt);
    }

    // QuizResults (structure: QuizResults[sid][chapter][attemptKey] = {score,date,timeSpent})
    for(const sid in quizResults){
      if(!quizResults[sid] || !quizResults[sid][ch]) continue;
      const chapterEntries = quizResults[sid][ch];
      const keys = Object.keys(chapterEntries).sort();
      keys.forEach((key, idx) => {
        const res = chapterEntries[key] || {};
        // store the real attempt key so we can fetch the exact child later
        pushAttempt(sid, { score: res.score || 0, date: res.date || '', timeSpent: res.timeSpent || 0, source: 'QuizResults', attemptKey: key, displayIndex: idx+1 });
      });
    }

    // Note: StudentsProgress is legacy; prefer QuizResults which stores per-attempt answers.

    // Build HTML: per-student collapsible card with attempts table
    let html = '';
    const sids = Object.keys(attemptsByStudent).sort();
    for(const sid of sids){
      const studentName = await getStudentName(sid);
      const attempts = attemptsByStudent[sid] || [];
      // sort attempts by attemptIndex (already ordered) or date
      attempts.sort((a,b)=> (a.attemptIndex||0) - (b.attemptIndex||0));

      // build attempts table rows
      let attemptsRows = '';
    attempts.forEach(a => {
        const displayLabel = a.displayIndex ? a.displayIndex : (a.attemptKey || '1');
        const attemptKeyEsc = a.attemptKey ? a.attemptKey : String(a.displayIndex || '1');
          attemptsRows += `<tr><td>${escapeHtml(displayLabel)}</td><td>${a.score}</td><td>${escapeHtml(a.date)}</td><td>${escapeHtml(a.timeSpent)} mins</td><td>${escapeHtml(a.source)}</td><td><button class="view-btn" data-view-attempt="${sid}|${ch}|${attemptKeyEsc}"><span class="ico"><i class="fas fa-eye"></i></span> View</button> <button class="answers-btn" data-inline-answers="${sid}|${ch}|${attemptKeyEsc}"><span class="ico"><i class="fas fa-file-lines"></i></span> Answers</button></td></tr>`;
      });

      html += `
        <div class="data-header progress-header" data-sid="${sid}" style="display:flex;justify-content:space-between;align-items:center;cursor:pointer;">
          <div><strong>${studentName}</strong> <span style="color:#666;margin-left:8px;">(${sid})</span></div>
          <div style="color:#666">Attempts: ${attempts.length}</div>
        </div>
        <div class="chapter-body attempts-body" style="display:none; padding:10px 14px; margin-bottom:12px;">
          <table class='progress-table'>
            <thead><tr><th>Attempt #</th><th>Score</th><th>Date</th><th>Time Spent</th><th>Source</th></tr></thead>
            <tbody>
              ${attemptsRows}
            </tbody>
          </table>
        </div>
      `;
    }

    if(!sids.length) html = '<p>No attempts found.</p>';
    container.innerHTML = html;

    // Attach click handlers to toggle attempts
    document.querySelectorAll('.progress-header').forEach(h => {
      h.addEventListener('click', ()=>{
        const next = h.nextElementSibling;
        if(!next) return;
        const isOpen = next.style.display && next.style.display !== 'none';
        next.style.display = isOpen ? 'none' : 'block';
      });
    });
  });
}

// View attempt details handler (delegated)
document.addEventListener('click', async (e)=>{
  const btn = e.target.closest && e.target.closest('[data-view-attempt]');
  if(!btn) return;
  const val = btn.getAttribute('data-view-attempt'); // sid|chapter|attemptIndex
  const [sid, ch, attemptIndex] = val.split('|');
  // fetch attempt object from QuizResults (answers stored under QuizResults/{sid}/{chapter})
  try{
    // attemptIndex is actually the attemptKey (random push id) or numeric index; use fetchAttemptObject which tries exact keys first
    const attemptKey = attemptIndex;
    const fetched = await fetchAttemptObject(sid, ch, attemptKey);
    let attemptObj = fetched && fetched.obj ? fetched.obj : null;
    let source = fetched && fetched.source ? fetched.source : 'unknown';
    if(!attemptObj){
  const fallbackHtml = `<div style="max-height:60vh;overflow:auto"><h3>No stored answers found</h3><p>There is no per-attempt record for this attempt and no chapter-level answers were found in the database for this student/chapter.</p><p>Check that the student's attempts were saved under <code>QuizResults/${sid}/${ch}</code>.</p></div>`;
      showAttemptModal(fallbackHtml);
      return;
    }

    // Load chapter quiz questions to compare answers (try variants)
    let questions = {};
    try{
  let qFound = await findQuizQuestions(ch);
      if(qFound && qFound.snap && qFound.snap.exists()){ questions = normalizeQuestionsMap(qFound.snap.val()); console.debug('Loaded questions from', qFound.path); }
      else {
        const tried = (qFound && qFound.triedPaths) ? qFound.triedPaths.join(', ') : 'unknown paths';
        const fallbackSnap = await rtdb.ref(`quizzes/${ch}/questions`).get(); if(fallbackSnap && fallbackSnap.exists()) questions = normalizeQuestionsMap(fallbackSnap.val());
        else { console.debug('No questions found; attempted paths:', tried); }
      }
    }catch(e){ console.debug('Failed to load questions for', ch, e); }

    // Build modal content: iterate questions in numeric order by questionIndex
    const qKeys = Object.keys(questions || {}).sort((a,b)=> Number(a) - Number(b));
    let html = `<div style="max-height:60vh;overflow:auto">`;
  html += `<h3>Attempt ${escapeHtml(attemptIndex)} — Student ${escapeHtml(sid)} — Source: ${escapeHtml(source)}</h3>`;
  // show which questions path was used to load the quiz definitions (helps verify we're reading /quizzes/...)
  try{ if(typeof qFound !== 'undefined' && qFound && qFound.path){ html += `<div style="font-size:12px;color:#666;margin-bottom:8px">Loaded questions path: <code>${escapeHtml(qFound.path)}</code></div>`; } }catch(e){}

    if(qKeys.length===0){ html += `<p>No question definitions found for this chapter.</p>`; }
    else {
      qKeys.forEach(qk => {
        const q = questions[qk];
        // Determine student's response for this question from attemptObj
        // Attempt shapes vary: could be {answers: {qIndex: value}} or {responses: [...] } or flat fields. We'll try several heuristics.
  // extract student response using helper (qk is key, qIndex = numeric index)
  const qIndex = Number(qk);
  let studentResp = extractStudentResponse(attemptObj, qk, qIndex);
  // normalize stored responses (map numeric indices to choice text) so evaluation compares like-with-like
  const normResp = normalizeStudentResponse(q, studentResp);

  // evaluate correctness using evaluateAnswer (use normalized response)
  const correct = evaluateAnswer(q, normResp);
  // detect explicit no-response (undefined/null/empty string/empty array)
  const isNoResponse = (normResp === undefined || normResp === null || (Array.isArray(normResp) && normResp.length===0) || (typeof normResp === 'string' && String(normResp).trim()===''));
  // result state: 'Correct', 'Incorrect' or 'No response' (no-response should not be shown as wrong)
  let cls = 'question-result';
  let resultText = '';
  let resultColor = '#d33';
  if(isNoResponse){ resultText = 'No response'; cls = 'question-result'; resultColor = '#666'; }
  else if(correct){ resultText = 'Correct'; cls = 'question-result correct'; resultColor = '#2b8a3e'; }
  else { resultText = 'Incorrect'; cls = 'question-result wrong'; resultColor = '#d33'; }
        html += `<div class="${cls}" style="padding:10px;border-bottom:1px solid #eee;margin-bottom:8px;">
          <div style="display:flex;justify-content:space-between;align-items:center"><div style="font-weight:700;color:#501121">Q${escapeHtml(q.questionIndex || qk)}: ${escapeHtml(q.question||'')}</div><div style="font-size:12px;color:#666">${escapeHtml(q.type||'')}</div></div>`;

        if(q.type === 'multiple_choice'){
          // render choices and highlight correct and student selection
          const choices = Array.isArray(q.choices) ? q.choices : (q.choices ? Object.values(q.choices) : []);
          // derive canonical correct options text(s) from the question definition
          const correctOptionsText = getCanonicalAnswers(q);

          // student selections normalized to array for easy checks
          let studentSelections = [];
          if(Array.isArray(normResp)) studentSelections = normResp.slice();
          else if(normResp !== undefined && normResp !== null && String(normResp).trim() !== '') studentSelections = [String(normResp)];

          html += `<div style="margin-top:8px;display:flex;flex-direction:column;">`;
          let anySelected = false;
          // precompute normalized canonical answers and student selections
          const normCanonical = (correctOptionsText||[]).map(x=> typeof x === 'string' ? (q.caseSensitive ? String(x).trim() : String(x).toLowerCase().trim()) : String(x));
          const normStudentSel = studentSelections.map(s => (normalizeForCompare(q, s))).filter(x=> x!==null && x!==undefined);
          choices.forEach((opt, idx)=>{
            const normOpt = normalizeForCompare(q, opt);
            // is this option one of the correct options by value (compare normalized strings)
            const isCorrectOpt = normOpt !== null && normCanonical.some(co => co === normOpt);
            // determine if student selected this option; allow selections that map to indices as well
            const selMatchesOpt = normStudentSel.some(sel => {
              if(sel === null || sel === undefined) return false;
              if(Array.isArray(sel)) return sel.some(s=> s === normOpt);
              if(normOpt !== null && sel === normOpt) return true;
              // allow numeric index comparisons (0-based and 1-based)
              if(String(sel) === String(idx) || String(sel) === String(idx+1)) return true;
              return false;
            });
            const isSelected = selMatchesOpt;
            if(isSelected) anySelected = true;
            const chCls = `choice ${isCorrectOpt ? 'correct-choice':''} ${isSelected ? 'student-choice':''}`;
            const tags = [];
            if(isCorrectOpt) tags.push('<span class="tag correct">Correct</span>');
            if(isSelected) tags.push('<span class="tag selected">Selected</span>');
            html += `<div class="${chCls}"><div>${escapeHtml(opt)}</div><div>${tags.join(' ')}</div></div>`;
          });
          html += `</div>`;
          // if student provided a response but it didn't match any choice, show that explicitly
          if(!anySelected && studentSelections.length>0){
            const rawDisplay = Array.isArray(studentResp) ? studentResp.join(', ') : String(studentResp);
            html += `<div style="margin-top:6px;color:#a23">Student answered (not in choices): <span style="font-weight:600">${escapeHtml(rawDisplay)}</span></div>`;
          }
          // if student didn't select anything, show explicit no response
          if(!anySelected){ html += `<div style="margin-top:6px;font-style:italic;color:#666">Student answer: <span style="font-weight:600">(no response)</span></div>`; }
          // show raw stored response and normalized mapping for instructor clarity
          try{
            const rawDisplay = (studentResp === undefined || studentResp === null || (Array.isArray(studentResp) && studentResp.length===0) || (typeof studentResp === 'string' && String(studentResp).trim()==='')) ? '(no response)' : (Array.isArray(studentResp) ? studentResp.join(', ') : String(studentResp));
            const normDisplay = (normResp === undefined || normResp === null || (Array.isArray(normResp) && normResp.length===0) || (typeof normResp === 'string' && String(normResp).trim()==='')) ? '(no response)' : (Array.isArray(normResp) ? normResp.join(', ') : String(normResp));
            html += `<div style="margin-top:6px;color:#444">Student response (raw): <span style="font-weight:600">${escapeHtml(rawDisplay)}</span></div>`;
            html += `<div style="margin-top:4px;color:#444">Normalized: <span style="font-weight:600">${escapeHtml(normDisplay)}</span></div>`;
          }catch(e){ /* ignore display errors */ }
          // if student is incorrect, show which option(s) are correct
          if(!correct && correctOptionsText.length){
            const mappedCorrect = correctOptionsText.join(', ');
            html += `<div style="margin-top:8px;">Correct answer: <span style="font-weight:700">${escapeHtml(mappedCorrect)}</span></div>`;
          }
          html += `<div style="margin-top:8px;">Result: <span style="font-weight:700;color:${resultColor}">${escapeHtml(resultText)}</span></div>`;
        } else {
          html += `<div style="margin-top:6px;">Expected: <span style='font-weight:600'>${escapeHtml(String(q.answer===undefined?JSON.stringify(q.choices||''): q.answer))}</span></div>`;
          html += `<div style="margin-top:6px;">Student answer: <span style='font-weight:600'>${escapeHtml(String(studentResp===undefined?'(no response)': studentResp))}</span></div>`;
          html += `<div style="margin-top:6px;color:${resultColor};font-weight:700">${escapeHtml(resultText)}</div>`;
        }
        html += `</div>`;
      });
    }
    html += `</div>`;

    // show custom modal (reuse simple modal pattern)
    showAttemptModal(html);
  }catch(err){ console.error(err); alert('Error loading attempt details: '+ (err && err.message ? err.message : err)); }
});

// Helper: fetch an attempt object with fallbacks (per-attempt nodes, chapter-level nodes)
async function fetchAttemptObject(sid, ch, attemptIndex){
  console.debug('fetchAttemptObject()', { sid, ch, attemptIndex });
  // attemptIndex may actually be a push-key (random id) or a numeric index. Try exact key paths first.
  // Prefer QuizResults exact path first (you store answers there)
  const qrExactFound = await findFirstChapterSnapshot('QuizResults', sid, ch);
  if(qrExactFound){
    const qrSnapExact = await rtdb.ref(`${qrExactFound.path}/${attemptIndex}`).get();
    console.debug('checked QuizResults exact (variant)', `${qrExactFound.path}/${attemptIndex}`, 'exists=', qrSnapExact.exists());
    if(qrSnapExact.exists()) return { obj: qrSnapExact.val(), source: `${qrExactFound.path}/${attemptIndex}` };
  }
  // legacy StudentsProgress exact path removed - relying on QuizResults only

  // If not found by exact key, fall back to previous numeric-index logic (attemptIndex may be numeric)
  // try numeric-index paths using chapter variants - prefer QuizResults then StudentsProgress
  const qrVariant = await findFirstChapterSnapshot('QuizResults', sid, ch);
  if(qrVariant){
    try{ const qrSnap = await rtdb.ref(`${qrVariant.path}/${attemptIndex}`).get(); console.debug('checked QuizResults numeric (variant)', `${qrVariant.path}/${attemptIndex}`, 'exists=', qrSnap.exists()); if(qrSnap.exists()) return { obj: qrSnap.val(), source: `${qrVariant.path}/${attemptIndex}` }; }catch(e){ console.debug('QuizResults numeric check failed', e); }
  }
  // StudentsProgress numeric variant checks removed - relying on QuizResults only

  // try chapter-level QuizResults (prefer this: answers are stored here)
  const chapterQrFound = await findFirstChapterSnapshot('QuizResults', sid, ch);
  if(chapterQrFound){
    try{
      const chapterQrSnap = chapterQrFound.snap;
      const chapterQrPath = chapterQrFound.path;
      const chVal = chapterQrSnap.val(); const chKeys = Object.keys(chVal||{});
      console.debug('checked', chapterQrPath, 'exists=', chapterQrSnap.exists(), 'keys=', chKeys.slice(0,5));
      if(chVal && (chVal.answers || chVal.responses || chKeys.some(k=>isNaN(Number(k))))) return { obj: chVal, source: chapterQrPath };
      if(chKeys.length) return { obj: chVal[chKeys[0]], source: `${chapterQrPath}:${chKeys[0]}` };
    }catch(e){ console.debug('chapter-level QuizResults check failed', e); }
  }

  // StudentsProgress chapter-level fallback removed - relying on QuizResults only
  return null;
}

// Helper: generate likely chapter key variants to tolerate DB naming differences
function chapterVariants(ch){
  const out = new Set();
  if(!ch) return [];
  const raw = String(ch).trim();
  out.add(raw);
  out.add(raw.toLowerCase());
  out.add(raw.replace(/\s+/g, ''));
  // split alpha+digits like 'chapter1' -> 'chapter 1'
  const m = raw.match(/^([a-zA-Z]+)(\d+)$/);
  if(m){ out.add(`${m[1]} ${m[2]}`); out.add(`${m[1].toLowerCase()} ${m[2]}`); out.add(`${m[1].charAt(0).toUpperCase() + m[1].slice(1).toLowerCase()} ${m[2]}`); }
  // if it's like 'chapter 1', also add no-space variant
  const m2 = raw.match(/^([a-zA-Z]+)\s+(\d+)$/);
  if(m2){ out.add(`${m2[1]}${m2[2]}`); out.add(`${m2[1].toLowerCase()}${m2[2]}`); }
  // explicit chapter forms for numeric chapters
  const digits = raw.match(/(\d+)/);
  if(digits){ const d = digits[0]; out.add(`chapter${d}`); out.add(`chapter ${d}`); out.add(`Chapter ${d}`); out.add(`Chapter${d}`); out.add(d); }
  return Array.from(out);
}

// Helper: find the first existing RTDB snapshot for a root path that includes student id and chapter variant
async function findFirstChapterSnapshot(root, sid, ch){
  const variants = chapterVariants(ch);
  for(const v of variants){
    const path = `${root}/${sid}/${v}`;
    try{
      const snap = await rtdb.ref(path).get();
      if(snap && snap.exists()) return { snap, path, variant: v };
    }catch(e){ console.debug('findFirstChapterSnapshot read failed for', path, e); }
  }
  return null;
}

// Helper: find quiz questions node for any chapter variant
async function findQuizQuestions(ch){
  const variants = chapterVariants(ch);
  const triedPaths = [];
  for(const v of variants){
    // try the common shape: quizzes/{chapter}/questions
    const path1 = `quizzes/${v}/questions`;
    triedPaths.push(path1);
    try{
      const snap = await rtdb.ref(path1).get();
      if(snap && snap.exists()) return { snap, path: path1, variant: v, triedPaths };
    }catch(e){ console.debug('findQuizQuestions read failed for', path1, e); }
    // some exports store questions directly under quizzes/{chapter} as an object with a 'questions' array or map
    const path2 = `quizzes/${v}`;
    triedPaths.push(path2);
    try{
      const snap2 = await rtdb.ref(path2).get();
      if(snap2 && snap2.exists()){
        const val = snap2.val() || {};
        // if it already contains a 'questions' child, return that
        if(val.questions){
          // return a synthetic snapshot-like object for compatibility
          const fakeSnap = { exists: () => true, val: () => val.questions };
          return { snap: fakeSnap, path: path2 + '/questions', variant: v, triedPaths };
        }
        // if the node itself looks like questions (contains numeric keys or '1','2' etc), return it
        const keys = Object.keys(val || {});
        const looksLikeQuestions = keys.length && keys.some(k => /^\d+$/.test(k) || /^q?\d+$/i.test(k) || (val[k] && (val[k].question || val[k].choices || val[k].answer)));
        if(looksLikeQuestions){ const fakeSnap2 = { exists: () => true, val: () => val }; return { snap: fakeSnap2, path: path2, variant: v, triedPaths }; }
      }
    }catch(e){ console.debug('findQuizQuestions read failed for', path2, e); }
  }
  return { triedPaths };
}

// Normalize a questions value (array or map) into a map with numeric-string keys
function normalizeQuestionsMap(raw){
  if(!raw) return {};
  // if it's an array (some exports use arrays with null at index 0), convert to map '1'..'n'
  if(Array.isArray(raw)){
    const out = {};
    for(let i=0;i<raw.length;i++){
      const item = raw[i];
      if(item === null || item === undefined) continue;
      // prefer an explicit questionIndex if present, otherwise use 1-based array position
      const idx = (item && (item.questionIndex !== undefined && item.questionIndex !== null)) ? Number(item.questionIndex) : (i + 1);
      const key = String(idx);
      out[key] = item;
    }
    // If the questions map uses 0-based numeric keys (0..n-1), shift all keys to 1-based so they align with common 'Q1' answer keys
    try{
      const numericKeys = Object.keys(out).map(k=>{ const n = Number(k); return isNaN(n)?null:n; }).filter(x=>x!==null);
      if(numericKeys.length && Math.min(...numericKeys) === 0){
        const shifted = {};
        Object.keys(out).forEach(k => {
          const n = Number(k);
          const newKey = String(isNaN(n) ? k : (n + 1));
          const item = out[k];
          try{ if(item && (item.questionIndex !== undefined && item.questionIndex !== null)) item.questionIndex = Number(item.questionIndex) + 1; }catch(e){}
          shifted[newKey] = item;
        });
        return shifted;
      }
    }catch(e){}
    return out;
  }
  // if it's an object, try to map numeric-like keys to numeric-string keys
  if(typeof raw === 'object'){
    const out = {};
    // track used numeric keys to assign fallbacks
    const used = new Set();
    let nextFallback = 1;
    // iterate keys in insertion order but prefer explicit questionIndex inside items
    Object.keys(raw).forEach(k => {
      const v = raw[k];
      let idx = null;
      try{
        if(v && (v.questionIndex !== undefined && v.questionIndex !== null)) idx = Number(v.questionIndex);
      }catch(e){}
      if(idx === null){
        const m = String(k).match(/(\d+)$/);
        if(m) idx = Number(m[1]);
      }
      if(idx === null || isNaN(idx)){
        // find next unused fallback numeric index
        while(used.has(nextFallback)) nextFallback++;
        idx = nextFallback;
      }
      used.add(idx);
      // ensure questionIndex property exists on item for downstream code
      try{ if(v && (v.questionIndex === undefined || v.questionIndex === null)) v.questionIndex = idx; }catch(e){}

      // If choices is an object with numeric-like keys, convert to an array so ordering is stable
      try{
        if(v && v.choices && !Array.isArray(v.choices) && typeof v.choices === 'object'){
          const ck = Object.keys(v.choices || {});
          const allNumeric = ck.length>0 && ck.every(kc => /^\d+$/.test(kc));
          if(allNumeric){
            const numericKeys = ck.map(kc => Number(kc)).filter(n=>!isNaN(n));
            const minKey = Math.min(...numericKeys);
            const arr = [];
            ck.forEach(kc => {
              const pos = Number(kc);
              if(isNaN(pos)) return;
              // If keys start at 0 use 0-based; otherwise assume 1-based and shift to 0-based index
              const targetIndex = (minKey === 0) ? pos : (pos - 1);
              if(targetIndex >= 0) arr[targetIndex] = v.choices[kc];
            });
            // remove undefined holes but preserve order
            v.choices = arr.filter(x => x !== undefined);
          }
        }
      }catch(e){}

      out[String(idx)] = v;
    });
    return out;
  }
  return {};
}

// Helper: find a key in an in-memory map object that matches any chapter variant
function findVariantKeyInMap(obj, ch){
  if(!obj || !ch) return null;
  const variants = chapterVariants(ch) || [];
  // direct check first
  for(const v of variants){ if(Object.prototype.hasOwnProperty.call(obj, v)) return v; }
  // normalized fallback: compare keys after lowercasing and removing spaces
  const normVariants = new Set(variants.map(v=>String(v).trim().toLowerCase().replace(/\s+/g,'')));
  for(const k of Object.keys(obj||{})){
    const nk = String(k).trim().toLowerCase().replace(/\s+/g,'');
    if(normVariants.has(nk)) return k;
  }
  return null;
}

// Export section answers CSV
async function exportSectionAnswersCSV(sectionId, ch){
  const modal = document.getElementById('sectionAnswersModal'); if(!modal) return;
  const content = document.getElementById('sectionAnswersContent'); if(!content) return;
  // gather questions
  let qFound = await findQuizQuestions(ch);
  const questionsRaw = (qFound && qFound.snap && qFound.snap.exists()) ? qFound.snap.val() : {};
  const questions = normalizeQuestionsMap(questionsRaw);
  const qKeys = Object.keys(questions||{}).sort((a,b)=>Number(a)-Number(b));
  // find student cards inside content
  const cards = Array.from(content.querySelectorAll('.student-card'));
  if(cards.length===0){ alert('No student data to export. Load the section answers first.'); return; }
  // CSV header
  const exportedAt = new Date().toISOString();
  const headers = ['uid','name','attempts','latest','best','avg','date','exportedAt'];
  qKeys.forEach(qk => headers.push('Q'+qk));
  const rows = [headers];
  for(const card of cards){
    const uid = card.dataset.uid || '';
    const nameSpan = card.querySelector('.sid');
    const name = nameSpan ? nameSpan.textContent : '';
    const cache = card._attemptCache || { attempts: [], fetched: {} };
    const attempts = cache.attempts || [];
    const attemptsCount = attempts.length;
    const scoresArr = attempts.map(a=>{ const s = a && a.score!==undefined && a.score!==null ? Number(a.score) : NaN; return isNaN(s)?null:s; }).filter(x=>x!==null);
    const best = scoresArr.length ? Math.max(...scoresArr) : '';
    const avg = scoresArr.length ? Math.round((scoresArr.reduce((s,t)=>s+t,0)/scoresArr.length)*10)/10 : '';
    // determine selected attempt (look at selector if present)
    const selector = card.querySelector('.attempt-selector');
    let chosenKey = null;
    if(selector){ const val = selector.value; if(val === 'latest') chosenKey = attempts[0] && attempts[0].key; else if(val === 'best'){ let bestKey = attempts[0] && attempts[0].key; let bestScore=-Infinity; for(const a of attempts){ const s = a && a.score!==undefined && a.score!==null ? Number(a.score) : NaN; if(!isNaN(s) && s>bestScore){ bestScore=s; bestKey=a.key; } } chosenKey = bestKey; } else chosenKey = val; }
    if(!chosenKey && attempts[0]) chosenKey = attempts[0].key;
    const fetched = cache.fetched && cache.fetched[chosenKey] ? cache.fetched[chosenKey] : null;
    const attemptObj = fetched && fetched.obj ? fetched.obj : null;
    const date = attempts[0] ? attempts[0].date || '' : '';
    const latestScore = attempts[0] ? attempts[0].score || '' : '';
    const row = [uid, name, attemptsCount, latestScore, best, avg, date];
    // per-question values
    for(const qk of qKeys){ const q = questions[qk]; let studentResp = undefined; if(attemptObj) studentResp = extractStudentResponse(attemptObj, qk, Number(qk)); const norm = normalizeStudentResponse(q, studentResp); const out = (norm === undefined || norm === null) ? '' : (Array.isArray(norm) ? norm.join(' | ') : String(norm)); row.push(out); }
    row.push(exportedAt);
    rows.push(row);
  }
  // convert to CSV
  const csv = rows.map(r => r.map(c => '"'+String(c).replace(/"/g,'""')+'"').join(',')).join('\r\n');
  downloadTextFile(csv, `section_${sectionId}_${ch}_answers_${exportedAt.replace(/[:\.]/g,'-')}.csv`);
}

function downloadTextFile(text, filename){
  const blob = new Blob([text], { type: 'text/csv;charset=utf-8;' });
  if(window.navigator && window.navigator.msSaveOrOpenBlob){ window.navigator.msSaveOrOpenBlob(blob, filename); }
  else {
    const link = document.createElement('a');
    const url = URL.createObjectURL(blob);
    link.setAttribute('href', url);
    link.setAttribute('download', filename);
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  }
}

// Return a list of attempts (keys) for a student/chapter with simple labels (date or key)
async function getAttemptList(sid, ch){
  const list = [];
  try{
    // try QuizResults with chapter key variants
    const qrFound = await findFirstChapterSnapshot('QuizResults', sid, ch);
    if(qrFound && qrFound.snap && qrFound.snap.exists()){
      const val = qrFound.snap.val();
      Object.keys(val||{}).forEach(k=>{
        const item = val[k] || {};
        const label = item.date ? `${item.date} (${k.substr(0,6)})` : `${k}`;
        list.push({ key: k, source: `QuizResults (${qrFound.variant})`, date: item.date || '', score: item.score || null, label });
      });
    }
  }catch(e){ console.debug('getAttemptList QuizResults read failed', e); }
  // Note: StudentsProgress removed - relying on QuizResults only
  // Sort by date desc if available, else keep insertion order
  list.sort((a,b)=>{
    if(a.date && b.date) return (a.date < b.date) ? 1 : -1;
    return 0;
  });
  return list;
}

// Render the questions block HTML for an attempt object
function renderAttemptQuestionsHtml(attemptObj, source, questions, sourcePath){
  // Build normalized, instructor-friendly HTML for a single attempt object.
  const qKeys = Object.keys(questions || {}).sort((a,b)=> Number(a) - Number(b));
  let html = `<div style="max-height:60vh;overflow:auto">`;
  html += `<h3>Source: ${escapeHtml(source || 'unknown')}</h3>`;
  if(sourcePath){ html += `<div style="font-size:12px;color:#666;margin-bottom:8px">Loaded questions path: <code>${escapeHtml(sourcePath)}</code></div>`; }

  // Some attempt objects are raw maps (Q1/Q2/1/2) instead of {answers: {...}}
  let effectiveAttempt = attemptObj || {};
  try{
    if(!attemptObj) effectiveAttempt = {};
    else if(!attemptObj.answers){
      const keys = Object.keys(attemptObj||{});
      const looksLikeAnswers = keys.length>0 && keys.some(k => /^q?\d+$/i.test(k) || /^Q\d+$/i.test(k));
      if(looksLikeAnswers){ effectiveAttempt = { answers: attemptObj }; }
    }
  }catch(e){ effectiveAttempt = attemptObj || {}; }

  if(qKeys.length===0){ html += `<p>No question definitions found for this chapter.</p>`; }
  else {
    const _mismatches = [];
    qKeys.forEach(qk => {
      const q = questions[qk] || {};
      const qIndex = Number(qk);
      // extract stored student response using robust helper
      const rawResp = extractStudentResponse(effectiveAttempt, qk, qIndex);
      const normResp = normalizeStudentResponse(q, rawResp);
      const correct = evaluateAnswer(q, normResp);
      const isNoResponse = (normResp === undefined || normResp === null || (Array.isArray(normResp) && normResp.length===0) || (typeof normResp === 'string' && String(normResp).trim()===''));

      let cls = 'question-result';
      let resultText = '';
      let resultColor = '#d33';
      if(isNoResponse){ resultText = 'No response'; cls = 'question-result'; resultColor = '#666'; }
      else if(correct){ resultText = 'Correct'; cls = 'question-result correct'; resultColor = '#2b8a3e'; }
      else { resultText = 'Incorrect'; cls = 'question-result wrong'; resultColor = '#d33'; }

      html += `<div class="${cls}" style="padding:10px;border-bottom:1px solid #eee;margin-bottom:8px;">`;
      html += `<div style="display:flex;justify-content:space-between;align-items:center"><div style="font-weight:700;color:#501121">Q${escapeHtml(q.questionIndex || qk)}: ${escapeHtml(q.question||'')}</div><div style="font-size:12px;color:#666">${escapeHtml(q.type||'')}</div></div>`;

      if(q.type === 'multiple_choice'){
        const choices = Array.isArray(q.choices) ? q.choices.slice() : (q.choices ? Object.values(q.choices) : []);
        // canonical correct options (display texts)
        const canonical = getCanonicalAnswers(q) || [];
        // normalized canonical for fast comparison
  const normCanonical = canonical.map(x => normalizeForCompare(q, x)).filter(x=> x!==null && x!==undefined);

        // student selections: produce array of normalized strings for comparison
        let studentSelections = [];
        if(Array.isArray(normResp)) studentSelections = normResp.map(x=> normalizeForCompare(q, x));
        else if(normResp !== undefined && normResp !== null && String(normResp).trim() !== '') studentSelections = [ normalizeForCompare(q, normResp) ];
        studentSelections = studentSelections.filter(x=> x!==null && x!==undefined);

        html += `<div style="margin-top:8px;display:flex;flex-direction:column;">`;
        let anySelected = false;

        // Precompute per-choice normalized values for debug
        const perChoiceNorm = choices.map((opt, idx) => ({ idx, opt, norm: normalizeForCompare(q, opt) }));

        choices.forEach((opt, idx) => {
          const normOpt = normalizeForCompare(q, opt);
          const isCorrectOpt = normOpt !== null && normCanonical.some(co => co === normOpt);
          // allow student selection matching by normalized value or by index (0/1-based)
          const isSelected = studentSelections.some(sel => {
            if(sel === null || sel === undefined) return false;
            if(Array.isArray(sel)) return sel.some(s=> s === normOpt);
            if(normOpt !== null && sel === normOpt) return true;
            if(String(sel) === String(idx) || String(sel) === String(idx+1)) return true;
            return false;
          });
          if(isSelected) anySelected = true;
          const chCls = `choice ${isCorrectOpt ? 'correct-choice':''} ${isSelected ? 'student-choice':''}`;
          const tags = [];
          if(isCorrectOpt) tags.push('<span class="tag correct">Correct</span>');
          if(isSelected) tags.push('<span class="tag selected">Selected</span>');
          html += `<div class="${chCls}"><div>${escapeHtml(opt)}</div><div>${tags.join(' ')}</div></div>`;
        });

        html += `</div>`;

        if(!anySelected && Array.isArray(normResp) && normResp.length>0){ const rawDisplay = Array.isArray(rawResp) ? rawResp.join(', ') : String(rawResp); html += `<div style="margin-top:6px;color:#a23">Student answered (not in choices): <span style="font-weight:600">${escapeHtml(rawDisplay)}</span></div>`; }
        if(!anySelected && isNoResponse){ html += `<div style="margin-top:6px;font-style:italic;color:#666">Student answer: <span style="font-weight:600">(no response)</span></div>`; }

        try{
          const rawDisplay = (rawResp === undefined || rawResp === null || (Array.isArray(rawResp) && rawResp.length===0) || (typeof rawResp === 'string' && String(rawResp).trim()==='')) ? '(no response)' : (Array.isArray(rawResp) ? rawResp.join(', ') : String(rawResp));
          const normDisplay = (normResp === undefined || normResp === null || (Array.isArray(normResp) && normResp.length===0) || (typeof normResp === 'string' && String(normResp).trim()==='')) ? '(no response)' : (Array.isArray(normResp) ? normResp.join(', ') : String(normResp));
          html += `<div style="margin-top:6px;color:#444">Student response (raw): <span style="font-weight:600">${escapeHtml(rawDisplay)}</span></div>`;
          html += `<div style="margin-top:4px;color:#444">Normalized: <span style="font-weight:600">${escapeHtml(normDisplay)}</span></div>`;
        }catch(e){}

        if(!correct && canonical.length && !isNoResponse){ const mappedCorrect = canonical.join(', '); html += `<div style="margin-top:8px;">Correct answer: <span style="font-weight:700">${escapeHtml(mappedCorrect)}</span></div>`; }
        // Debug section: show normalized canonical and student selections and per-choice normalized values
        if(EVAL_DEBUG){
          try{
            const dbgCanonical = normCanonical.join(' | ') || '(none)';
            const dbgStudent = studentSelections.join(' | ') || '(none)';
            const dbgPerChoice = perChoiceNorm.map(p=>`${p.idx}: ${p.norm === null ? '(null)' : p.norm}`).join(' | ');
            html += `<div style="margin-top:8px;padding:8px;border:1px dashed #eee;background:#fafafa;font-size:12px;color:#333">`;
            html += `<div style="font-weight:700;margin-bottom:6px">DEBUG</div>`;
            html += `<div><b>Normalized canonical:</b> ${escapeHtml(dbgCanonical)}</div>`;
            html += `<div><b>Normalized student selections:</b> ${escapeHtml(dbgStudent)}</div>`;
            html += `<div style="margin-top:6px"><b>Per-choice normalized:</b> ${escapeHtml(dbgPerChoice)}</div>`;
            html += `</div>`;
          }catch(e){}
        }
        html += `<div style="margin-top:8px;">Result: <span style="font-weight:700;color:${resultColor}">${escapeHtml(resultText)}</span></div>`;

      } else {
        // identification / true_false fallback
        html += `<div style="margin-top:6px;">Expected: <span style='font-weight:600'>${escapeHtml(String(q.answer===undefined?JSON.stringify(q.choices||''): q.answer))}</span></div>`;
        html += `<div style="margin-top:6px;">Student answer: <span style='font-weight:600'>${escapeHtml(String(rawResp===undefined?'(no response)': rawResp))}</span></div>`;
        html += `<div style="margin-top:6px;color:${resultColor};font-weight:700">${escapeHtml(resultText)}</div>`;
      }

      html += `</div>`;
      // collect mismatch info for console debugging: student provided something but evaluated incorrect or no selection
      try{
        if(!isNoResponse && !correct){
          // generate quick suggestion: check numeric/currency mismatch
          let suggestion = null;
          try{
            const nNormResp = Array.isArray(normResp) ? normResp.join('|') : String(normResp);
            const nCanon = (normCanonical||[]).join('|');
            if(nNormResp && nCanon){
              if(nNormResp.replace(/[₱$£€,\.]/g,'') === nCanon.replace(/[₱$£€,\.]/g,'')) suggestion = 'Numeric/currency formatting mismatch (try stripping currency/separators)';
              else if(/^[0-9\.\-]+$/.test(nNormResp) && !/^[0-9\.\-]+$/.test(nCanon)) suggestion = 'Student answered numeric while canonical is text (or vice versa)';
            }
          }catch(e){}
          _mismatches.push({ qk: qk, question: q.question||'', rawResp: rawResp, normResp: normResp, canonical: canonical, normCanonical: normCanonical, perChoiceNorm: (typeof perChoiceNorm !== 'undefined' ? perChoiceNorm : null), suggestion });
        }
      }catch(e){}
    });
    // print concise mismatch summary to console to aid debugging
    try{ if(_mismatches.length){ console.debug('Attempt render mismatches:', _mismatches.map(m => ({ q: m.qk, question: m.question, raw: m.rawResp, normalized: m.normResp, canonical: m.canonical, normCanonical: m.normCanonical })) ); } }catch(e){}
  }
  html += `</div>`;
  return html;
}

// Delegated handler for inline answers button
document.addEventListener('click', async (e)=>{
  const btn = e.target.closest && e.target.closest('[data-inline-answers]');
  if(!btn) return;
  try{
    const val = btn.getAttribute('data-inline-answers'); // sid|chapter|attemptIndex
  const parts = val ? val.split('|') : [];
  const sid = parts[0], ch = parts[1], attemptKey = parts[2];
  console.debug('Answers clicked', { val, sid, ch, attemptKey });
    const tr = btn.closest('tr');
    if(!tr) console.debug('Answers handler: no enclosing <tr> found for button, continuing anyway');

    // fetch attempt object with logging (uses chapter-variant lookups internally)
    let fetched = null;
    console.debug('Answers handler: calling fetchAttemptObject', { sid, ch, attemptKey });
    try{
      fetched = await fetchAttemptObject(sid, ch, attemptKey);
      console.debug('fetchAttemptObject returned', { fetchedSummary: fetched ? { source: fetched.source, sampleKeys: fetched.obj ? Object.keys(fetched.obj).slice(0,5) : null } : null });
    }catch(err){
      console.error('fetchAttemptObject threw', err);
      showAttemptModal(`<div style="padding:12px"><h3>Error fetching attempt</h3><pre>${escapeHtml(err && err.message ? err.message : String(err))}</pre></div>`);
      return;
    }

    if(!fetched || !fetched.obj){
      console.debug('No fetched attempt object, showing fallback modal', { fetched });
      const fallbackHtml = `<div style="max-height:60vh;overflow:auto;padding:12px"><h3>No stored answers found</h3><p>There is no stored answers for this attempt.</p><pre>Request: ${escapeHtml(val)}</pre></div>`;
      try{ showAttemptModal(fallbackHtml); } catch(showErr){ console.error('showAttemptModal failed', showErr); alert('No stored answers and failed to open modal. See console.'); }
      return;
    }

    // We will show a modal that contains a dropdown of attempts so the instructor can select any attempt (by key)
    // load quiz questions, trying chapter variants if necessary
    let questions = {};
    let qFound = null;
    try{
      qFound = await findQuizQuestions(ch);
      if(qFound && qFound.snap && qFound.snap.exists()){
        questions = normalizeQuestionsMap(qFound.snap.val());
        console.debug('Loaded questions from', qFound.path);
      } else {
        const fallbackSnap = await rtdb.ref(`quizzes/${ch}/questions`).get();
        if(fallbackSnap && fallbackSnap.exists()){ questions = normalizeQuestionsMap(fallbackSnap.val()); console.debug('Loaded questions from fallback quizzes/${ch}/questions'); }
      }
    }catch(e){ console.debug('Failed to load quiz questions for chapter', ch, e); }
    const attempts = await getAttemptList(sid, ch);
  if(attempts.length === 0){ showAttemptModal(`<div style="padding:12px"><h3>No attempts found</h3><p>There are no attempts in QuizResults for this student/chapter.</p></div>`); return; }
    // build modal content with select
    let inner = `<div style="padding:8px;max-height:70vh;overflow:auto">`;
    inner += `<div style="display:flex;gap:8px;align-items:center;margin-bottom:10px"><label style="font-weight:700">Choose attempt:</label><select id="attemptPicker">`;
    attempts.forEach(a=>{ inner += `<option value="${escapeHtml(a.key)}">${escapeHtml(a.label)}</option>`; });
    inner += `</select></div>`;
    // placeholder for questions content
    inner += `<div id="attemptQuestionsContainer">Loading...</div>`;
    inner += `</div>`;
    showAttemptModal(inner);
    // load first attempt
    const picker = document.getElementById('attemptPicker');
    const containerEl = document.getElementById('attemptQuestionsContainer');
    async function loadByKey(key){
      containerEl.innerHTML = 'Loading attempt...';
      try{
        const fetchedAttempt = await fetchAttemptObject(sid, ch, key);
        if(!fetchedAttempt || !fetchedAttempt.obj){ containerEl.innerHTML = `<div style="color:#a23">Attempt data not found for key: ${escapeHtml(key)}</div>`; return; }
          const html = renderAttemptQuestionsHtml(fetchedAttempt.obj, fetchedAttempt.source, questions, (qFound && qFound.path) ? qFound.path : null);
        containerEl.innerHTML = html;
      }catch(e){ containerEl.innerHTML = `<div style="color:#a23">Error loading attempt: ${escapeHtml(e && e.message? e.message : String(e))}</div>`; }
    }
    // initial load
    await loadByKey(attempts[0].key);
    // change handler
    picker.addEventListener('change', async (ev)=>{ await loadByKey(ev.target.value); });
  }catch(err){ console.error('Unhandled error in Answers handler', err); showAttemptModal(`<div style="padding:12px"><h3>Unhandled error</h3><pre>${escapeHtml(err && err.message ? err.message : String(err))}</pre></div>`); }
});

// Simple attempt modal implementation
function showAttemptModal(innerHtml){
  console.debug('showAttemptModal called, innerHtml length=', innerHtml ? innerHtml.length : 0);
  let modal = document.getElementById('attemptDetailsModal');
  if(!modal){
    modal = document.createElement('div'); modal.id='attemptDetailsModal'; modal.className='modal';
  const content = document.createElement('div'); content.className='modal-content'; content.style.maxWidth='900px';
  // limit modal height and keep its content scrollable when large
  content.style.maxHeight = '80vh';
  content.style.overflow = 'hidden';
    content.innerHTML = `
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:12px;">
        <div style="display:flex;flex-direction:column;">
          <div style="display:flex;align-items:center;gap:12px"><h3 id="attemptModalTitle">Attempt Details</h3><span id="wrongSummary" style="color:#d33;font-weight:700"></span></div>
          <div style="font-size:13px;color:#666" id="attemptModalSub"></div>
        </div>
        <div style="display:flex;gap:8px;align-items:center;">
          <button id="debugToggleBtn" class="btn" style="background:#fff;border:1px solid #ccc;padding:6px 10px;border-radius:6px;">Debug: Off</button>
          <button id="filterWrongBtn" class="btn" style="background:#fff;border:1px solid #ccc;padding:6px 10px;border-radius:6px;">Show Wrong Only</button>
          <button style="background:#fff;border:1px solid #ccc;padding:6px 10px;border-radius:6px;" id="closeAttemptModal">Close</button>
        </div>
      </div>
      <div id="attemptDetailsContent"></div>`;
    modal.appendChild(content); document.body.appendChild(modal);
    // Attach handlers after appending
    try{ document.getElementById('closeAttemptModal').addEventListener('click', ()=>{ modal.style.display='none'; }); }catch(e){ console.error('attach closeAttemptModal failed', e); }
    try{ document.getElementById('debugToggleBtn').addEventListener('click', ()=>{
      EVAL_DEBUG = !EVAL_DEBUG; const btn = document.getElementById('debugToggleBtn'); if(btn) btn.textContent = `Debug: ${EVAL_DEBUG ? 'On' : 'Off'}`;
      // if content visible, re-render the attempt details (naive approach: find container and re-run existing innerHTML string if available)
      const contentEl = document.getElementById('attemptDetailsContent'); if(contentEl){
        // look for the currently displayed pickers/containers and trigger a change event to reload if present
        const picker = document.getElementById('attemptPicker'); if(picker){ const ev = new Event('change'); picker.dispatchEvent(ev); }
      }
    }); }catch(e){ console.error('attach debugToggleBtn failed', e); }
    try{ document.getElementById('filterWrongBtn').addEventListener('click', ()=>{
      const btn = document.getElementById('filterWrongBtn'); const showing = btn.dataset.showing === '1';
      btn.dataset.showing = showing ? '0' : '1'; btn.textContent = showing ? 'Show Wrong Only' : 'Show All';
      document.querySelectorAll('#attemptDetailsContent .question-result').forEach(el=>{
        if(showing){ el.style.display='block'; } else { if(el.classList.contains('wrong')) el.style.display='block'; else el.style.display='none'; }
      });
    }); }catch(e){ console.error('attach filterWrongBtn failed', e); }
  }
  // ensure modal is attached to body and visible with inline styles in case external CSS hides it
  if(!modal.parentNode || modal.parentNode !== document.body) document.body.appendChild(modal);
  // Force important inline styles to override page CSS
  modal.style.setProperty('position','fixed','important');
  modal.style.setProperty('left','0','important'); modal.style.setProperty('top','0','important'); modal.style.setProperty('width','100%','important'); modal.style.setProperty('height','100%','important');
  modal.style.setProperty('display','flex','important'); modal.style.setProperty('align-items','center','important'); modal.style.setProperty('justify-content','center','important');
  modal.style.setProperty('z-index','2147483647','important');
  modal.style.setProperty('background','rgba(0,0,0,0.65)','important');
  // ensure content container exists and make it scrollable (so long answers don't expand modal)
  let contentEl = modal.querySelector('#attemptDetailsContent');
  if(!contentEl){
    const cont = document.createElement('div'); cont.id='attemptDetailsContent';
    const wrapper = modal.querySelector('.modal-content') || modal.firstChild;
    if(wrapper) wrapper.appendChild(cont); contentEl = cont;
  }
  // set scrollable area inside modal
  contentEl.style.maxHeight = 'calc(80vh - 120px)';
  contentEl.style.overflowY = 'auto';
  contentEl.style.padding = contentEl.style.padding || '8px';
  try{
    contentEl.innerHTML = innerHtml;
  }catch(e){ console.error('Failed to set attemptDetailsContent.innerHTML', e); }
  // update wrong count and default state
  const modalEl = document.getElementById('attemptDetailsModal');
  const wrongEls = modalEl ? modalEl.querySelectorAll('.question-result.wrong') : [];
  const wrongSummary = document.getElementById('wrongSummary');
  wrongSummary.textContent = wrongEls.length ? `Wrong: ${wrongEls.length}` : '';
  // reset filter button
  const filterBtn = document.getElementById('filterWrongBtn'); if(filterBtn){ filterBtn.dataset.showing='0'; filterBtn.textContent='Show Wrong Only'; }
  // focus for accessibility after a tiny delay
  setTimeout(()=>{
    try{ const first = modal.querySelector('.modal-content'); if(first) first.focus(); }catch(e){}
  },50);
}

// Modal helpers
function openQuestionModal(ch){ currentChapter=ch; editingQuestionId=null; resetModal(); document.getElementById('questionModal').style.display='flex'; }
function closeQuestionModal(){ document.getElementById('questionModal').style.display='none'; }
function toggleQuestionType(){ const t=document.getElementById('questionType').value; document.getElementById('mcFields').style.display=t==='multipleChoice'?'block':'none'; document.getElementById('idFields').style.display=t==='identification'?'block':'none'; document.getElementById('tfFields').style.display=t==='true_false'?'block':'none'; }
function resetModal(){ document.getElementById('modalTitle').innerText="Add New Question"; document.getElementById('questionText').value=""; document.getElementById('questionType').value="multipleChoice"; toggleQuestionType(); ["0","1","2","3"].forEach(i=>{document.getElementById('optionText'+i).value=""; document.querySelector(`input[name='correctOption'][value='${i}']`).checked=false;}); document.getElementById('identificationAnswer').value=""; document.querySelectorAll("input[name='trueFalseAnswer']").forEach(r=>r.checked=false); }

// Reset extended settings
function resetExtendedSettings(){
  document.getElementById('optCaseSensitive').checked = false;
  document.getElementById('optOrderMatters').checked = false;
  document.getElementById('optRandomizeOptions').checked = false;
  document.getElementById('idCaseSensitive').checked = false;
  document.getElementById('idOrderMatters').checked = false;
}

// Save question
async function saveQuestion(){
  const text=document.getElementById('questionText').value.trim();
  const type=document.getElementById('questionType').value;
  if(!text){alert("Enter question"); return;}
  let payload={question:text, showAnswer:true};
  if(type==="multipleChoice"){
    const opts=[0,1,2,3].map(i=>document.getElementById('optionText'+i).value.trim());
    const checked=document.querySelector("input[name='correctOption']:checked");
    if(!checked){alert("Select correct option"); return;}
    if(opts.some(o=>!o)){alert("Fill all options"); return;}
    payload.choices=opts; payload.answer=opts[checked.value]; payload.type="multiple_choice";
    // extended options
    payload.caseSensitive = !!document.getElementById('optCaseSensitive').checked;
    payload.orderMatters = !!document.getElementById('optOrderMatters').checked;
    payload.randomizeOptions = !!document.getElementById('optRandomizeOptions').checked;
  } else if(type==="identification"){
    const ans=document.getElementById('identificationAnswer').value.trim();
    if(!ans){alert("Enter answer"); return;}
    payload.answer=ans; payload.type="identification";
    payload.caseSensitive = !!document.getElementById('idCaseSensitive').checked;
    payload.orderMatters = !!document.getElementById('idOrderMatters').checked;
  } else if(type==="true_false"){
    const checked=document.querySelector("input[name='trueFalseAnswer']:checked");
    if(!checked){alert("Select True/False"); return;}
    payload.answer=checked.value; payload.type="true_false";
  }

  // Save to whichever quiz questions path exists for the chapter, or default to canonical path
  try{
  let qFound = await findQuizQuestions(currentChapter);
    if(qFound && qFound.snap && qFound.snap.exists()){
      const base = qFound.path;
      if(editingQuestionId){ await rtdb.ref(`${base}/${editingQuestionId}`).set(payload); alert('Question updated!'); }
      else { const nextIndex = await getNextQuestionIndex(currentChapter); payload.questionIndex = nextIndex; await rtdb.ref(`${base}/${nextIndex}`).set(payload); alert('Question added!'); }
    } else {
      const base = `quizzes/${currentChapter}/questions`;
      if(editingQuestionId){ await rtdb.ref(`${base}/${editingQuestionId}`).set(payload); alert('Question updated!'); }
      else { const nextIndex = await getNextQuestionIndex(currentChapter); payload.questionIndex = nextIndex; await rtdb.ref(`${base}/${nextIndex}`).set(payload); alert('Question added!'); }
    }
  }catch(e){ console.error('Failed saving question', e); alert('Failed to save question: '+ (e && e.message? e.message : String(e))); }
  closeQuestionModal();
  loadChapterQuestions(currentChapter);
}

// Edit
async function openEditModal(ch,id){
  currentChapter=ch; editingQuestionId=id; resetModal();
  // try to locate the question across chapter variants
  let qFound = await findQuizQuestions(ch);
  let q = null;
  if(qFound && qFound.snap && qFound.snap.exists()){
    const childSnap = qFound.snap.child(id);
    if(childSnap && childSnap.exists()) q = childSnap.val();
  }
  if(!q){
    const snap = await rtdb.ref(`quizzes/${ch}/questions/${id}`).get();
    if(!snap.exists()){alert("Missing"); return;} q = snap.val();
  }
  document.getElementById('modalTitle').innerText="Edit Question";
  document.getElementById('questionText').value=q.question;
  document.getElementById('questionType').value=q.type==="multiple_choice"?"multipleChoice":q.type;
  toggleQuestionType();
  if(q.type==="multiple_choice"){
    (Array.isArray(q.choices) ? q.choices : (q.choices ? Object.values(q.choices) : [])).forEach((opt,i)=>{
      try{ document.getElementById('optionText'+i).value = opt; }catch(e){}
      try{
        const normOpt = normalizeForCompare(q, opt);
        const normAns = normalizeForCompare(q, q.answer);
        let match = false;
        if(normOpt !== null && normAns !== null){
          if(Array.isArray(normAns)) match = normAns.some(a=>a === normOpt);
          else match = normAns === normOpt;
        }
        if(match){ const el = document.querySelector(`input[name='correctOption'][value='${i}']`); if(el) el.checked = true; }
      }catch(e){}
    });
    // populate extended settings
    document.getElementById('optCaseSensitive').checked = !!q.caseSensitive;
    document.getElementById('optOrderMatters').checked = !!q.orderMatters;
    document.getElementById('optRandomizeOptions').checked = !!q.randomizeOptions;
  } else if(q.type==="identification"){ document.getElementById('identificationAnswer').value=q.answer; }
  else if(q.type==="true_false"){ document.querySelector(`input[name='trueFalseAnswer'][value='${q.answer}']`).checked=true; }
  document.getElementById('questionModal').style.display='flex';
}

// Delete
async function deleteQuestion(ch,id){
    if(confirm("Delete this question?")){
    // try to delete from the variant path if found, else fallback to the canonical path
  let qFound = await findQuizQuestions(ch);
    if(qFound && qFound.snap && qFound.snap.exists() && qFound.snap.child(id).exists()){
      await rtdb.ref(`${qFound.path}/${id}`).remove();
    } else {
      await rtdb.ref(`quizzes/${ch}/questions/${id}`).remove();
    }
    loadChapterQuestions(ch);
  }
}

// Wire test modal button after DOM ready
document.addEventListener('DOMContentLoaded', ()=>{
  try{
    // testModalBtn removed - no-op
  }catch(e){ console.error('Failed to attach Test Modal handler', e); }
});

// --- Section Answers Modal ---
// modal markup (injected once)
if(!document.getElementById('sectionAnswersModal')){
  const sModal = document.createElement('div'); sModal.id = 'sectionAnswersModal'; sModal.className = 'modal';
  sModal.style.display='none';
  sModal.innerHTML = `
    <div class="modal-content" style="max-width:1000px;">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:12px;">
        <div style="display:flex;flex-direction:column;">
          <div style="display:flex;align-items:center;gap:12px"><h3 id="sectionAnswersTitle">Section Answers</h3></div>
          <div style="font-size:13px;color:#666" id="sectionAnswersSub">Select chapter and load answers</div>
        </div>
        <div style="display:flex;gap:8px;align-items:center;">
          <select id="sectionAnswersChapterSelect"></select>
          <button id="loadSectionAnswersBtn" class="btn" style="background:#fff;border:1px solid #ccc;padding:6px 10px;border-radius:6px;">Load</button>
          <button id="exportSectionAnswersBtn" class="btn" style="background:#fff;border:1px solid #ccc;padding:6px 10px;border-radius:6px;">Export CSV</button>
          <button id="closeSectionAnswersModal" class="btn" style="background:#fff;border:1px solid #ccc;padding:6px 10px;border-radius:6px;">Close</button>
        </div>
      </div>
      <div id="sectionAnswersContent" style="max-height:70vh;overflow:auto;padding:8px;"></div>
    </div>`;
  document.body.appendChild(sModal);
  // attach handlers
  document.getElementById('closeSectionAnswersModal').addEventListener('click', ()=>{ sModal.style.display='none'; });
  document.getElementById('loadSectionAnswersBtn').addEventListener('click', async ()=>{
    const sel = document.getElementById('sectionAnswersChapterSelect'); const ch = sel.value; const sid = sModal.dataset.sectionId;
    if(!sid){ alert('No section selected'); return; }
    await loadSectionAnswers(sid, ch);
  });
  document.getElementById('exportSectionAnswersBtn').addEventListener('click', async ()=>{
    const sel = document.getElementById('sectionAnswersChapterSelect'); const ch = sel.value; const sid = sModal.dataset.sectionId;
    if(!sid){ alert('No section selected'); return; }
    await exportSectionAnswersCSV(sid, ch);
  });
}

// Populate chapter select helper
function populateSectionChapterSelect(){
  const sel = document.getElementById('sectionAnswersChapterSelect'); if(!sel) return;
  sel.innerHTML = '';
  Object.keys(chapterTitles).forEach(k => { const o = document.createElement('option'); o.value = k; o.textContent = chapterTitles[k]; sel.appendChild(o); });
}

// Open section answers modal for sectionId
async function openSectionAnswersModal(sectionId){
  const modal = document.getElementById('sectionAnswersModal'); if(!modal) return;
  modal.dataset.sectionId = sectionId;
  document.getElementById('sectionAnswersTitle').textContent = 'Section Answers: ' + (sectionsCache && sectionsCache[sectionId] ? (sectionsCache[sectionId].name || sectionsCache[sectionId].title || sectionId) : sectionId);
  populateSectionChapterSelect();
  // default to currentChapter if set, else first
  const sel = document.getElementById('sectionAnswersChapterSelect'); if(currentChapter) sel.value = currentChapter; else if(sel.options.length) sel.selectedIndex = 0;
  modal.style.display='flex'; modal.style.setProperty('position','fixed','important'); modal.style.setProperty('z-index','2147483647','important');
}

// Load and render section answers for a chapter (aggregates latest attempt per student for that chapter)
async function loadSectionAnswers(sectionId, ch){
  const content = document.getElementById('sectionAnswersContent'); if(!content) return; content.innerHTML = '<p>Loading...</p>';
  try{
    // fetch section students
    let sectionObj = sectionsCache && sectionsCache[sectionId];
    if(!sectionObj){ const snap = await rtdb.ref(`SectionList/${sectionId}`).get(); if(snap.exists()) sectionObj = snap.val(); }
    const studentMap = sectionObj && sectionObj.students ? sectionObj.students : {};
    let uids = Object.keys(studentMap||{});
    if(uids.length===0){ content.innerHTML = '<p>No students in this section.</p>'; return; }
    // filter UIDs to those that actually exist as StudentAccount or Cridentials entries
    try{
      const [accSnap, credSnap] = await Promise.all([ rtdb.ref('StudentAccount').get(), rtdb.ref('Cridentials').get() ]);
      const accounts = accSnap.exists() ? accSnap.val() : {};
      const creds = credSnap.exists() ? credSnap.val() : {};
      const valid = {};
      Object.keys(accounts||{}).forEach(k=> valid[k]=true);
      Object.keys(creds||{}).forEach(k=> valid[k]=true);
      const beforeCount = uids.length;
      uids = uids.filter(uid => !!valid[uid]);
      if(uids.length === 0){ content.innerHTML = `<p>No matching student accounts found for section (filtered ${beforeCount} -> 0)</p>`; return; }
    }catch(e){ console.debug('Failed to fetch StudentAccount/Cridentials for filtering', e); }

    // load chapter questions (variant-aware) and normalize into numeric-keyed map
    let qFound = await findQuizQuestions(ch);
    const questionsRaw = (qFound && qFound.snap && qFound.snap.exists()) ? qFound.snap.val() : {};
    if(!(qFound && qFound.snap && qFound.snap.exists())){
      const tried = (qFound && qFound.triedPaths) ? qFound.triedPaths.join(', ') : 'unknown paths';
      content.innerHTML = `<p>No questions found for ${escapeHtml(ch)}. Tried: ${escapeHtml(tried)}</p>`; return;
    }
    const questions = normalizeQuestionsMap(questionsRaw || {});
    const qKeys = Object.keys(questions||{}).sort((a,b)=>Number(a)-Number(b));

    const list = document.createElement('div'); list.className = 'section-answers-list';

    for(const uid of uids){
      const attempts = await getAttemptList(uid, ch);
      const card = document.createElement('div'); card.className = 'student-card';
      const header = document.createElement('div'); header.className = 'student-header';
      const title = document.createElement('div'); title.className = 'student-title'; title.innerHTML = `${escapeHtml(uid)} <span class="sid">${escapeHtml(studentMap[uid] && studentMap[uid].name ? studentMap[uid].name : '')}</span>`;
      const meta = document.createElement('div'); meta.className = 'student-meta';
      if(!attempts || attempts.length===0){ meta.innerHTML = `<span class="badge muted">No attempts</span>`; header.appendChild(title); header.appendChild(meta); card.appendChild(header); list.appendChild(card); continue; }
  const latest = attempts[0];
  // compute overall stats
  const scoresArr = attempts.map(a => { const s = a && a.score!==undefined && a.score!==null ? Number(a.score) : NaN; return isNaN(s) ? null : s; }).filter(x=>x!==null);
  const attemptsCount = attempts.length;
  const best = scoresArr.length ? Math.max(...scoresArr) : null;
  const avg = scoresArr.length ? (scoresArr.reduce((s,t)=>s+t,0)/scoresArr.length) : null;
  const scoreBadge = `<span class="badge score">Latest: ${escapeHtml(String(latest.score||''))}</span>`;
  const attemptsBadge = `<span class="badge muted">Attempts: ${escapeHtml(String(attemptsCount))}</span>`;
  const bestBadge = best !== null ? `<span class="badge muted">Best: ${escapeHtml(String(best))}</span>` : '';
  const avgBadge = avg !== null ? `<span class="badge muted">Avg: ${escapeHtml(String(Math.round(avg*10)/10))}</span>` : '';
  const dateBadge = `<span class="badge muted">${escapeHtml(latest.date||'')}</span>`;
  // attempt selector: latest / best / specific
  const selector = document.createElement('select'); selector.className = 'attempt-selector';
  // option: latest
  const optLatest = document.createElement('option'); optLatest.value = 'latest'; optLatest.textContent = 'Latest'; selector.appendChild(optLatest);
  // option: best
  const optBest = document.createElement('option'); optBest.value = 'best'; optBest.textContent = 'Best'; selector.appendChild(optBest);
  // specific attempts
  attempts.forEach(a=>{ const o = document.createElement('option'); o.value = a.key; o.textContent = a.date ? `${a.date} (${a.key.substr(0,6)})` : a.key; selector.appendChild(o); });
  const toggleBtn = document.createElement('button'); toggleBtn.className = 'toggle-details'; toggleBtn.textContent = 'Show answers';
  meta.innerHTML = attemptsBadge + scoreBadge + bestBadge + avgBadge + dateBadge; meta.appendChild(selector); meta.appendChild(toggleBtn);
      header.appendChild(title); header.appendChild(meta);
      card.appendChild(header);

      const detailsDiv = document.createElement('div'); detailsDiv.className = 'student-details';
  // fetch attempt objects for all listed attempts and cache per-student for quick switching
  const studentCache = { attempts: attempts, fetched: {} };
  for(const a of attempts){ try{ const f = await fetchAttemptObject(uid, ch, a.key); if(f && f.obj) studentCache.fetched[a.key] = f; }catch(e){ /* ignore fetch errors for non-latest */ } }
  const latestKey = latest.key;
  const attemptObj = (studentCache.fetched && studentCache.fetched[latestKey]) ? studentCache.fetched[latestKey].obj : null;
  const source = (studentCache.fetched && studentCache.fetched[latestKey]) ? studentCache.fetched[latestKey].source : 'unknown';
  // attach cache map to card for later reference
  card.dataset.uid = uid; card._attemptCache = studentCache;
      if(!attemptObj){ detailsDiv.innerHTML = `<div class="debug-note">No attempt object found (source: ${escapeHtml(source)})</div>`; card.appendChild(detailsDiv); list.appendChild(card); continue; }

      // build qa list
      const qaList = document.createElement('div'); qaList.className = 'qa-list';
      for(const qk of qKeys){ const q = questions[qk]; const qIndex = Number(qk); const studentResp = extractStudentResponse(attemptObj, qk, qIndex); const normResp = normalizeStudentResponse(q, studentResp); const correct = evaluateAnswer(q, normResp); const isNoResponse = (normResp === undefined || normResp === null || (Array.isArray(normResp) && normResp.length===0) || (typeof normResp === 'string' && String(normResp).trim()===''));
        const row = document.createElement('div'); row.className = 'qa-row';
        const qText = document.createElement('div'); qText.className = 'qa-question'; qText.innerHTML = `<strong>Q${escapeHtml(q.questionIndex || qk)}</strong>: ${escapeHtml((q.question||'').slice(0,140))}`;
        const status = document.createElement('div'); status.className = 'qa-status'; if(isNoResponse) { status.innerHTML = `<span class="badge muted">No response</span>`; status.classList.add('status-muted'); } else if(correct) { status.innerHTML = `<span class="badge ok">Correct</span>`; status.classList.add('status-ok'); } else { status.innerHTML = `<span class="badge warn">Wrong</span>`; status.classList.add('status-wrong'); }
        row.appendChild(qText); row.appendChild(status);
        qaList.appendChild(row);
        if(!correct && !isNoResponse){ const rawDisplay = (studentResp === undefined || studentResp === null) ? '(no response)' : (Array.isArray(studentResp) ? studentResp.join(', ') : String(studentResp)); const normDisplay = (normResp === undefined || normResp === null) ? '(no response)' : (Array.isArray(normResp) ? normResp.join(', ') : String(normResp)); const detail = document.createElement('div'); detail.className = 'qa-detail'; detail.innerHTML = `<div><b>Student response (raw):</b> ${escapeHtml(rawDisplay)}</div><div style="margin-top:6px"><b>Normalized:</b> ${escapeHtml(normDisplay)}</div>`; qaList.appendChild(detail); }
      }

      // debug summary hidden by default
      const debugSummary = document.createElement('div'); debugSummary.className = 'debug-note'; debugSummary.textContent = `Source: ${source}`;
      detailsDiv.appendChild(qaList); detailsDiv.appendChild(debugSummary);
      card.appendChild(detailsDiv);

      // wire toggle
      toggleBtn.addEventListener('click', ()=>{
        const open = detailsDiv.style.display && detailsDiv.style.display !== 'none';
        detailsDiv.style.display = open ? 'none' : 'block';
        toggleBtn.textContent = open ? 'Show answers' : 'Hide answers';
      });

      // handle attempt selection changes
      selector.addEventListener('change', ()=>{
        const val = selector.value;
        let keyToUse = latestKey;
        if(val === 'latest'){ keyToUse = latestKey; }
        else if(val === 'best'){ // pick best-scoring attempt
          let bestKey = latestKey; let bestScore = -Infinity;
          for(const a of attempts){ const s = a && a.score!==undefined && a.score!==null ? Number(a.score) : NaN; if(!isNaN(s) && s>bestScore){ bestScore=s; bestKey=a.key; } }
          keyToUse = bestKey;
        } else { keyToUse = val; }
        // replace detailsDiv content with selected attempt
        detailsDiv.innerHTML = '<p>Loading...</p>';
        const f = card._attemptCache && card._attemptCache.fetched && card._attemptCache.fetched[keyToUse];
        if(!f){ detailsDiv.innerHTML = `<div class="debug-note">No attempt found for selection</div>`; return; }
        // render QA list for this attempt
        const attemptObjSel = f.obj; const sourceSel = f.source;
        const qaListNew = document.createElement('div'); qaListNew.className = 'qa-list';
        for(const qk of qKeys){ const q = questions[qk]; const qIndex = Number(qk); const studentResp = extractStudentResponse(attemptObjSel, qk, qIndex); const normResp = normalizeStudentResponse(q, studentResp); const correct = evaluateAnswer(q, normResp); const isNoResponse = (normResp === undefined || normResp === null || (Array.isArray(normResp) && normResp.length===0) || (typeof normResp === 'string' && String(normResp).trim()===''));
          const row = document.createElement('div'); row.className = 'qa-row'; const qText = document.createElement('div'); qText.className = 'qa-question'; qText.innerHTML = `<strong>Q${escapeHtml(q.questionIndex || qk)}</strong>: ${escapeHtml((q.question||'').slice(0,140))}`; const status = document.createElement('div'); status.className = 'qa-status'; if(isNoResponse) { status.innerHTML = `<span class="badge muted">No response</span>`; status.classList.add('status-muted'); } else if(correct) { status.innerHTML = `<span class="badge ok">Correct</span>`; status.classList.add('status-ok'); } else { status.innerHTML = `<span class="badge warn">Wrong</span>`; status.classList.add('status-wrong'); } row.appendChild(qText); row.appendChild(status); qaListNew.appendChild(row); if(!correct && !isNoResponse){ const rawDisplay = (studentResp === undefined || studentResp === null) ? '(no response)' : (Array.isArray(studentResp) ? studentResp.join(', ') : String(studentResp)); const normDisplay = (normResp === undefined || normResp === null) ? '(no response)' : (Array.isArray(normResp) ? normResp.join(', ') : String(normResp)); const detail = document.createElement('div'); detail.className = 'qa-detail'; detail.innerHTML = `<div><b>Student response (raw):</b> ${escapeHtml(rawDisplay)}</div><div style="margin-top:6px"><b>Normalized:</b> ${escapeHtml(normDisplay)}</div>`; qaListNew.appendChild(detail); } }
        detailsDiv.innerHTML = ''; detailsDiv.appendChild(qaListNew); detailsDiv.appendChild(Object.assign(document.createElement('div'),{className:'debug-note', textContent:`Source: ${sourceSel}`}));
      });

      list.appendChild(card);
    }

    content.innerHTML = ''; content.appendChild(list);
  }catch(err){ console.error('loadSectionAnswers failed', err); content.innerHTML = '<pre>'+escapeHtml(err && err.message?err.message:String(err))+'</pre>'; }
}

// delegated handler to open section answers for a section
document.addEventListener('click', (e)=>{
  const b = e.target.closest && e.target.closest('.view-section-answers-btn');
  if(!b) return;
  const sectionId = b.getAttribute('data-section-id');
  if(!sectionId) return;
  // runtime validation: ensure section has students before opening modal
  try{
    const sec = sectionsCache && sectionsCache[sectionId] ? sectionsCache[sectionId] : null;
    const students = sec && sec.students ? Object.keys(sec.students||{}) : [];
    if(!students || students.length === 0){ alert('This section has no students.'); return; }
  }catch(e){ /* ignore and proceed */ }
  openSectionAnswersModal(sectionId);
});




</script>
</body>
</html>
