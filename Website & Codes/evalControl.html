<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Evaluation & Control</title>

<link rel="stylesheet" href="dashboard.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"/>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

<script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-database-compat.js"></script>

<style>
body { font-family:'Inter', sans-serif; background:#f8f9fa; margin:0; }
.data-header { cursor:pointer; padding:12px; border-radius:8px; margin:6px 0; background:#fff; display:flex; justify-content:space-between; align-items:center; box-shadow:0 2px 4px rgba(0,0,0,0.05); transition:0.2s; }
.data-header.open { background:#fefefe; }
.data-header i { transition: transform 0.2s; }
.data-header.open i { transform: rotate(90deg); }

.chapter-body { display:none; padding:16px; background:#fff; border-radius:10px; margin-bottom:16px; box-shadow:0 2px 6px rgba(0,0,0,0.03); max-height:400px; overflow-y:auto; }
.chapter-body::-webkit-scrollbar { width:8px; }
.chapter-body::-webkit-scrollbar-thumb { background:#a72344; border-radius:10px; }
.chapter-body::-webkit-scrollbar-track { background:#f1f1f1; }

.tabs { display:flex; margin-bottom:15px; border-bottom:1px solid #ddd; }
.tab { padding:10px 20px; cursor:pointer; background:#f5f5f5; border:1px solid #ddd; border-bottom:none; border-radius:5px 5px 0 0; margin-right:5px; transition:0.2s; }
.tab.active { background:#fff; border-bottom:1px solid #fff; font-weight:600; color:#a72344; }

.question-item { background:#fefefe; padding:14px; border-radius:8px; margin-bottom:12px; border:1px solid #eee; }
.question-text { font-weight:600; color:#501121; margin-bottom:8px; }
.question-options { display:grid; grid-template-columns: repeat(2,1fr); gap:8px; margin-bottom:8px; }
.question-option { padding:8px 10px; background:#fff; border-radius:6px; border:1px solid #e7e7e7; }
.correct-answer { background: rgba(76,201,240,0.08); border-color:#501121; color:#501121; font-weight:600; }
.question-actions { display:flex; justify-content:flex-end; gap:10px; }

.progress-table { width:100%; border-collapse: collapse; margin-top:10px; }
.progress-table th, .progress-table td { border:1px solid #ddd; padding:8px; text-align:left; }
.progress-table th { background:#f2f2f2; font-weight:bold; }

.question-result.correct { border-left:6px solid #2b8a3e; padding-left:8px; }
.question-result.wrong { border-left:6px solid #d33; padding-left:8px; background:#fff6f6; }

.choice { padding:8px 10px; border-radius:6px; border:1px solid #e7e7e7; margin-top:6px; display:flex; justify-content:space-between; align-items:center; }
.choice.correct-choice { background: rgba(43,138,62,0.06); border-color:#2b8a3e; }
.choice.student-choice { box-shadow: inset 0 0 0 2px rgba(0,0,0,0.04); }
.choice .tag { font-size:12px; padding:4px 6px; border-radius:6px; }
.choice .tag.correct { background:#2b8a3e;color:#fff; }
.choice .tag.selected { background:#d33;color:#fff; }

.add-question-btn { background: linear-gradient(180deg,#a72344,#7a1024); color:#fff; padding:10px 16px; border-radius:10px; font-weight:700; border:none; cursor:pointer; margin-bottom:12px; transition:0.2s; }
.add-question-btn:hover { transform:scale(1.03); }

.save-question-btn { background: linear-gradient(180deg,#4cc9f0,#501121); color:#fff; padding:10px 18px; border-radius:10px; font-weight:700; border:none; cursor:pointer; transition:0.2s; }
.save-question-btn:hover { transform:scale(1.03); }

.cancel-btn { background:#fff; color:#a72344; padding:10px 16px; border-radius:8px; font-weight:600; border:1px solid #a72344; cursor:pointer; transition:0.2s; }
.cancel-btn:hover { background:#fef1f1; }

.edit-btn { background:#501121; color:#fff; padding:8px 12px; border-radius:8px; border:none; cursor:pointer; font-weight:700; transition:0.2s; }
.edit-btn:hover { opacity:0.85; }

.delete-btn { background: linear-gradient(180deg,#ff6b6b,#d32f2f); color:#fff; padding:8px 12px; border-radius:8px; border:none; cursor:pointer; font-weight:700; transition:0.2s; }
.delete-btn:hover { opacity:0.85; }

/* Instructor action buttons in attempts table */
.view-btn, .answers-btn {
  display:inline-flex; align-items:center; gap:8px; padding:6px 10px; border-radius:8px; border:none; cursor:pointer; font-weight:700; font-size:13px; transition:transform .12s ease, box-shadow .12s ease;
}
.view-btn { background: linear-gradient(180deg,#501121,#501121); color:#fff; }
.view-btn:hover { transform:translateY(-1px); box-shadow:0 6px 14px rgba(42,166,200,0.12); }
.answers-btn { background: linear-gradient(180deg,#fff,#f7f7f7); color:#333; border:1px solid #ddd; }
.answers-btn:hover { transform:translateY(-1px); box-shadow:0 6px 14px rgba(0,0,0,0.06); }
.view-btn .ico, .answers-btn .ico { width:14px; height:14px; display:inline-block; }


.modal { display:none; position:fixed; z-index:3000; left:0; top:0; width:100%; height:100%; background: rgba(0,0,0,0.45); align-items:center; justify-content:center; padding:20px; }
.modal-content { background:white; width:100%; max-width:600px; border-radius:12px; padding:25px; box-shadow:0 8px 20px rgba(0,0,0,0.15); animation:fadeIn 0.2s ease; }
@keyframes fadeIn { from{opacity:0; transform:translateY(-10px);} to{opacity:1; transform:translateY(0);} }

.modal-header { display:flex; justify-content:space-between; align-items:center; margin-bottom:18px; }
.modal-header h2 { color:#501121; font-size:22px; margin:0; }
.close { font-size:24px; cursor:pointer; color:#6c757d; transition:0.2s; }
.close:hover { color:#a72344; }

.question-form input[type=text] { width:100%; padding:10px; margin-bottom:10px; border-radius:8px; border:1px solid #ddd; }
.question-form select { width:100%; padding:10px; margin-bottom:12px; border-radius:8px; border:1px solid #ddd; }

#mcFields input[type=radio] { margin-right:6px; }
#tfFields label { margin-right:20px; }

/* Toggle switch */
.switch { display:inline-flex; align-items:center; gap:8px; cursor:pointer; }
.switch input[type=checkbox] { width:0; height:0; opacity:0; position:absolute; }
.switch .slider { width:44px; height:24px; background:#ccc; border-radius:20px; position:relative; transition:background 0.18s ease; display:inline-block; vertical-align:middle; }
.switch .slider::after { content:''; width:18px; height:18px; background:#fff; border-radius:50%; position:absolute; left:3px; top:3px; transition:transform 0.18s ease; box-shadow:0 1px 3px rgba(0,0,0,0.2); }
.switch input[type=checkbox]:checked + .slider { background:#4cc9f0; }
.switch input[type=checkbox]:checked + .slider::after { transform:translateX(20px); }
.switch .switch-label { margin-left:6px; display:inline-block; vertical-align:middle; color:#333; }
.settings-row { display:flex; gap:12px; align-items:center; margin-bottom:8px; flex-wrap:wrap; }

.chapters-scroll { max-height:600px; overflow-y:auto; padding-right:6px; }
.chapters-scroll::-webkit-scrollbar { width:8px; }
.chapters-scroll::-webkit-scrollbar-thumb { background:#a72344; border-radius:10px; }
.chapters-scroll::-webkit-scrollbar-track { background:#f1f1f1; }
</style>
</head>
<body>
<div class="container-wrap">
  <div class="-main">
    <div class="main-menu">
      <img src="images/profile logo.PNG" width="60" height="60">
      <p>Math teacher</p>
      <div class="main-section">
        <p>Main</p>
        <a href="studentList.html">Student List</a>
        <a href="studentProgress.html">Student Progress</a>
        <a href="evalControl.html">Evaluation & Control</a>
        <a href="accSecSetup.html">Account & Section Setup</a>
      </div>
    </div>
  </div>

<div class="-side">
    <div class="top-bar">
  <div style="flex:1"></div>
  <div class="logout" style="display:flex; align-items:center; gap:8px;">
    <!-- text link (keeps visible text) -->
    <a href="mainWeb.html" id="logoutLink" style="color:#333; text-decoration:none;">Logout</a>
    <!-- icon button you added — now clickable and accessible -->
    <button id="logoutBtn" class="icon-btn" title="Logout" aria-label="Logout" style="color:#333; background:transparent;border:0;padding:6px;cursor:pointer;">
      <i class="fas fa-sign-out-alt"></i>
    </button>
  </div>
    </div>

    <div class="dash-window">
      <div class="header-title"><h1>Evaluation & Control</h1></div>
      <div class="data-container">
        <p>Total Students: <span id="totalStudents">Loading...</span></p>
        <div style="margin-top:8px;margin-bottom:10px;">
          <button id="testModalBtn" class="save-question-btn" style="padding:8px 12px; font-size:14px;">Test Modal</button>
        </div>
        <div class="chapters-scroll">
          <div id="chaptersContainer"></div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Modal -->
<div class="modal" id="questionModal">
  <div class="modal-content">
    <div class="modal-header">
      <h2 id="modalTitle">Add New Question</h2>
      <span class="close" onclick="closeQuestionModal()">&times;</span>
    </div>
    <div class="question-form">
      <input type="text" id="questionText" placeholder="Enter your question">
      <select id="questionType" onchange="toggleQuestionType()">
        <option value="multipleChoice">Multiple Choice</option>
        <option value="identification">Identification</option>
        <option value="true_false">True/False</option>
      </select>
      <div id="mcFields">
        <div style="display:flex;flex-direction:column;gap:8px;margin-bottom:8px;">
          <label><input type="radio" name="correctOption" value="0"> <input type="text" id="optionText0" placeholder="Option A"></label>
          <label><input type="radio" name="correctOption" value="1"> <input type="text" id="optionText1" placeholder="Option B"></label>
          <label><input type="radio" name="correctOption" value="2"> <input type="text" id="optionText2" placeholder="Option C"></label>
          <label><input type="radio" name="correctOption" value="3"> <input type="text" id="optionText3" placeholder="Option D"></label>
        </div>
        <div class="settings-row">
          <label class="switch"><input type="checkbox" id="optCaseSensitive"><span class="slider"></span><span class="switch-label" style="font-size:13px;">Case sensitive</span></label>
          <label class="switch"><input type="checkbox" id="optOrderMatters"><span class="slider"></span><span class="switch-label" style="font-size:13px;">Order matters</span></label>
          <label class="switch"><input type="checkbox" id="optRandomizeOptions"><span class="slider"></span><span class="switch-label" style="font-size:13px;">Randomize options</span></label>
        </div>
      </div>
      <div id="idFields" style="display:none;">
        <input type="text" id="identificationAnswer" placeholder="Correct answer">
        <div style="margin-top:8px;" class="settings-row">
          <label class="switch"><input type="checkbox" id="idCaseSensitive"><span class="slider"></span><span class="switch-label" style="font-size:13px;">Case sensitive</span></label>
          <label class="switch"><input type="checkbox" id="idOrderMatters"><span class="slider"></span><span class="switch-label" style="font-size:13px;">Order matters</span></label>
        </div>
      </div>
      <div id="tfFields" style="display:none;">
        <label><input type="radio" name="trueFalseAnswer" value="True"> True</label>
        <label><input type="radio" name="trueFalseAnswer" value="False"> False</label>
      </div>
      <div style="text-align:right; margin-top:12px;">
        <button class="save-question-btn" onclick="saveQuestion()">Save</button>
        <button class="cancel-btn" onclick="closeQuestionModal()">Cancel</button>
      </div>
    </div>
  </div>
</div>

<script>
const firebaseConfig = {
  apiKey: "AIzaSyBkmM4hueT7PlnvV8FeRdp8g4rk0qQQrn4",
  authDomain: "midnightmathscape.firebaseapp.com",
  databaseURL: "https://midnightmathscape-e8e70-default-rtdb.firebaseio.com/",
  projectId: "midnightmathscape",
  storageBucket: "midnightmathscape.appspot.com",
  messagingSenderId: "1038485290511",
  appId: "1:1038485290511:web:c8aa78fbcd5266b706ed7a"
};
firebase.initializeApp(firebaseConfig);
const rtdb = firebase.database();

// Safe HTML escape helper
function escapeHtml(str){
  if(str === null || str === undefined) return '';
  return String(str)
    .replace(/&/g,'&amp;')
    .replace(/</g,'&lt;')
    .replace(/>/g,'&gt;')
    .replace(/"/g,'&quot;')
    .replace(/'/g,'&#39;');
}

// Count students from StudentAccount in realtime
const totalStudentsEl = document.getElementById('totalStudents');
rtdb.ref('StudentAccount').on('value', snap => {
  if (!snap.exists()) {
    totalStudentsEl.textContent = '0';
    return;
  }
  const students = snap.val();
  totalStudentsEl.textContent = Object.keys(students).length;
});

let editingQuestionId = null;
let currentChapter = null;

const chapterTitles = {
  chapter1:"Chapter 1: Midnight Hideout ", chapter2:"Chapter 2: Whispering Shelves", chapter3:"Chapter 3: Shattered Glass",
  chapter4:"Chapter 4: Silent Halls", chapter5:"Chapter 5: Echoes of Lunch", chapter6:"Chapter 6: Rooftop Rush",
  chapter7:"Chapter 7: Creaking Scaffold", chapter8:"Chapter 8: Flickering Screens", chapter9:"Chapter 9: Whispering Papers",
  chapter10:"Chapter 10: Creeping Silence", chapter11:"Chapter 11: Locked Secrets", chapter12:"Chapter 12: Freedom’s Edge"
};

// Build chapters UI
const container = document.getElementById('chaptersContainer');
Object.keys(chapterTitles).forEach(ch => {
  const header = document.createElement('div');
  header.className = 'data-header';
  header.dataset.chapter = ch;
  header.innerHTML = `<h3>${chapterTitles[ch]}</h3><i class="fa-solid fa-chevron-right"></i>`;
  const body = document.createElement('div');
  body.className = 'chapter-body';
  body.id = 'body-'+ch;
  body.innerHTML = `
    <div class="tabs">
      <div class="tab active" data-tab="questions">Question Management</div>
      <div class="tab" data-tab="progress">Student Progress</div>
    </div>
    <div id="questions-tab-${ch}"></div>
    <div id="progress-tab-${ch}" style="display:none;"></div>
  `;
  container.appendChild(header);
  container.appendChild(body);

  header.addEventListener('click', () => {
    const open = header.classList.contains('open');
    document.querySelectorAll('.data-header').forEach(h=>h.classList.remove('open'));
    document.querySelectorAll('.chapter-body').forEach(b=>b.style.display='none');
    if(!open){ header.classList.add('open'); body.style.display='block'; loadChapterQuestions(ch); }
  });
});

// Tabs
document.addEventListener('click', e=>{
  if(e.target.classList.contains('tab')){
    const tab=e.target, ch=tab.closest('.chapter-body').id.replace('body-','');
    tab.parentNode.querySelectorAll('.tab').forEach(t=>t.classList.remove('active'));
    tab.classList.add('active');
    document.getElementById(`questions-tab-${ch}`).style.display=tab.dataset.tab==='questions'?'block':'none';
    document.getElementById(`progress-tab-${ch}`).style.display=tab.dataset.tab==='progress'?'block':'none';
    if(tab.dataset.tab==='progress'){ subscribeStudentProgress(ch); }
  }
});

// Get next sequential question index
async function getNextQuestionIndex(ch){
  const snap = await rtdb.ref(`quizzes/${ch}/questions`).get();
  if(!snap.exists()) return 1;
  const indexes = [];
  snap.forEach(child=>indexes.push(parseInt(child.key)));
  return Math.max(...indexes)+1;
}

// Load questions
async function loadChapterQuestions(ch){
  currentChapter = ch;
  const container = document.getElementById(`questions-tab-${ch}`);
  container.innerHTML = `<button class="add-question-btn" onclick="openQuestionModal('${ch}')"><i class="fas fa-plus"></i> Add Question</button><div id="questions-list-${ch}">Loading...</div>`;
  const list = document.getElementById(`questions-list-${ch}`);
  const snap = await rtdb.ref(`quizzes/${ch}/questions`).get();
  if(!snap.exists()){ list.innerHTML="<p>No questions yet</p>"; return; }
  list.innerHTML = "";
    snap.forEach(child=>{
    const q = child.val(), id = child.key;
    let optionsHtml="";
    if(q.type==="multiple_choice"){
      // respect randomizeOptions: when randomizing, we must still mark correct answer
      const choices = Array.isArray(q.choices) ? q.choices.slice() : [];
      let displayChoices = choices.slice();
      if(q.randomizeOptions){ displayChoices = shuffle(displayChoices); }
      displayChoices.forEach(opt=>{
        const correct = (q.orderMatters) ? (q.answer===opt) : (q.answer===opt);
        optionsHtml += `<div class="question-option ${correct?'correct-answer':''}">${opt}</div>`;
      });
      optionsHtml += `<p style="font-size:12px;color:#666;margin-top:6px">Case sensitive: ${q.caseSensitive? 'Yes':'No'} &nbsp; | &nbsp; Order matters: ${q.orderMatters? 'Yes':'No'} &nbsp; | &nbsp; Randomize: ${q.randomizeOptions? 'Yes':'No'}</p>`;
    } else {
      optionsHtml = `<div class="question-option"><b>Answer:</b> ${q.answer}</div>`;
    }
    list.innerHTML += `
      <div class="question-item">
        <div class="question-text">[${q.questionIndex}] ${q.question}</div>
        <div class="question-options">${optionsHtml}</div>
        <p><b>Show Answer:</b> ${q.showAnswer}</p>
        <div class="question-actions">
          <button class="edit-btn" onclick="openEditModal('${ch}','${id}')">Edit</button>
          <button class="delete-btn" onclick="deleteQuestion('${ch}','${id}')">Delete</button>
        </div>
      </div>`;
  });
}

// --- Preview / Evaluation helper (instructor testing) ---
// Render a simple preview box at the bottom of the questions list for the current chapter
function renderPreviewBox(ch){
  const container = document.getElementById(`questions-tab-${ch}`);
  // append preview area if not present
  if(!document.getElementById('previewArea')){
    const preview = document.createElement('div');
    preview.id = 'previewArea';
    preview.style.marginTop = '12px';
    preview.innerHTML = `<div style="padding:12px;border-radius:8px;background:#fff;border:1px solid #eee;"><h4>Preview / Test</h4><div id='previewContent'>Select a question from the list to preview it here (click Edit then Close to return)</div></div>`;
    container.appendChild(preview);
  }
}

// Evaluate answer against a question object q and a provided response
// For multiple_choice: response can be the option text (string) or array of strings if multiple answers expected
function evaluateAnswer(q, response){
  if(!q) return false;
  if(q.type === 'multiple_choice'){
    // For MCQs, normalize both the stored student response and the question's answer(s)
    // to handle legacy formats: letter prefixes ("A.", "B)"), numeric indices (0/1-based),
    // and braced lists.
    const caseSensitive = !!q.caseSensitive;
    const normalize = v => caseSensitive ? String(v).trim() : String(v).toLowerCase().trim();

    // Use normalizeStudentResponse to map numeric indices and strip prefixes when possible
    const respNorm = normalizeStudentResponse(q, response);
    const ansNorm = normalizeStudentResponse(q, q.answer);

    const toArray = x => Array.isArray(x) ? x : (x === undefined || x === null ? [] : [x]);
    const rArr = toArray(respNorm).map(x => normalize(x));
    const aArr = toArray(ansNorm).map(x => normalize(x));

    if(q.orderMatters){
      if(rArr.length !== aArr.length) return false;
      for(let i=0;i<rArr.length;i++) if(rArr[i] !== aArr[i]) return false;
      return true;
    } else {
      // compare as sets (order-insensitive)
      rArr.sort(); aArr.sort();
      return JSON.stringify(rArr) === JSON.stringify(aArr);
    }
  } else if(q.type === 'identification'){
    const caseSensitive = !!q.caseSensitive;
    const normalize = v => caseSensitive ? v.trim() : String(v).toLowerCase().trim();
    // orderMatters for identification could imply exact match on tokens order; default exact
    return normalize(response) === normalize(q.answer);
  } else if(q.type === 'true_false'){
    return String(response).toLowerCase() === String(q.answer).toLowerCase();
  }
  return false;
}

// Shuffle helper
function shuffle(array){
  for(let i = array.length -1; i>0; i--){
    const j = Math.floor(Math.random()*(i+1));
    [array[i], array[j]] = [array[j], array[i]];
  }
  return array;
}

// Map stored student response (possibly numeric index or array of indices) to choice text(s)
function normalizeStudentResponse(q, studentResp){
  if(!q) return studentResp;
  // If no choices available, return original
  const choices = Array.isArray(q.choices) ? q.choices : (q.choices ? Object.values(q.choices) : []);
  // If no choices are defined (identification or TF), just return trimmed/raw student value
  if(!choices || choices.length===0){
    if(Array.isArray(studentResp)) return studentResp.map(x=> (x===null||x===undefined)?x:String(x).trim());
    return (studentResp===null||studentResp===undefined)?studentResp:String(studentResp).trim();
  }
  // helper to map one value
  const mapOne = (v) => {
    if(v === null || v === undefined) return undefined;
    if(typeof v === 'number'){
      // try 0-based first, then 1-based
      const try0 = choices[v] !== undefined ? choices[v] : undefined;
      if(try0 !== undefined) return try0;
      const try1 = choices[v-1] !== undefined ? choices[v-1] : undefined;
      return try1;
    }
    let s = String(v).trim();
    if(s === '') return undefined;
    const lower = s.toLowerCase();
    // treat common placeholders as no-response
    if(['-','null','n/a','no response','none','na','invalid choice','.','invalid','(no response)'].indexOf(lower) !== -1) return undefined;

    // strip common choice prefixes like 'A. ', 'A) ', '1. ' (be generous: allow letters A-Z and lower/upper)
    let stripped = s.replace(/^[A-Za-z]\s*[\.\)]\s*/,'').replace(/^\d+\.\s*/,'').trim();
    if(stripped === '') return undefined;

    // Helper to find the canonical choice text from choices array that matches a candidate
    const findChoiceMatch = (candidate) => {
      const candNorm = String(candidate).toLowerCase().trim();
      for(const opt of choices){
        const optNorm = String(opt).toLowerCase().trim();
        if(optNorm === candNorm) return opt; // exact match
        // strip prefix from option and compare
        const optStripped = String(opt).replace(/^[A-Za-z]\s*[\.\)]\s*/,'').replace(/^\d+\.\s*/,'').trim();
        if(String(optStripped).toLowerCase().trim() === candNorm) return opt;
      }
      return null;
    };

    // If the stripped value exactly matches a defined choice (or matches after stripping prefixes), return the canonical choice
    const matchedChoice = findChoiceMatch(stripped);
    if(matchedChoice) return matchedChoice;
    const matchedChoiceRaw = findChoiceMatch(s);
    if(matchedChoiceRaw) return matchedChoiceRaw;

    // Handle set-like values: {a, b, c} or 'a, b, c'
    const isBraced = /^\{.*\}$/.test(stripped);
    if(isBraced || stripped.indexOf(',') !== -1){
      const inner = (isBraced ? stripped.slice(1, -1) : stripped).split(',').map(x=>String(x).trim()).filter(x=>x);
      if(inner.length === 0) return undefined;
      // If individual items match choices, return an array of matched choices
      const mappedItems = inner.map(item => {
        if(choices.indexOf(item) !== -1) return item;
        // try stripping prefixes from item
        const it = item.replace(/^[A-Da-d]\s*[\.|\)]\s*/,'').replace(/^\d+\.\s*/,'').trim();
        if(choices.indexOf(it) !== -1) return it;
        return item;
      });
      return mappedItems;
    }

    // numeric string -> index mapping (after stripping): try 0-based then 1-based
    if(!isNaN(Number(stripped))){
      const n = Number(stripped);
      if(choices[n] !== undefined) return choices[n];
      if(choices[n-1] !== undefined) return choices[n-1];
    }

    // fallback: return the stripped text
    return stripped;
  };

  if(Array.isArray(studentResp)){
    const mapped = studentResp.map(mapOne).filter(x=> x !== undefined && x !== null && String(x).trim() !== '');
    return mapped.length ? mapped : [];
  }
  return mapOne(studentResp);
}

// Robust extractor: get student response for a question key/index from various attempt shapes
function extractStudentResponse(attemptObj, qk, qIndex){
  if(!attemptObj) return undefined;
  // common shapes
  if(attemptObj.answers && attemptObj.answers[qk] !== undefined) return attemptObj.answers[qk];
  if(attemptObj.answers && attemptObj.answers['q'+qk] !== undefined) return attemptObj.answers['q'+qk];
  if(attemptObj.answers && attemptObj.answers['Q'+qk] !== undefined) return attemptObj.answers['Q'+qk];
  if(attemptObj.answers && attemptObj.answers[qIndex] !== undefined) return attemptObj.answers[qIndex];
  if(attemptObj.answers && attemptObj.answers['q'+qIndex] !== undefined) return attemptObj.answers['q'+qIndex];
  if(attemptObj.answers && attemptObj.answers['Q'+qIndex] !== undefined) return attemptObj.answers['Q'+qIndex];
  if(attemptObj.responses && attemptObj.responses[qk] !== undefined) return attemptObj.responses[qk];
  if(Array.isArray(attemptObj.responses) && attemptObj.responses.length >= qIndex) return attemptObj.responses[qIndex-1];
  if(attemptObj.responsesArray && Array.isArray(attemptObj.responsesArray) && attemptObj.responsesArray.length >= qIndex) return attemptObj.responsesArray[qIndex-1];
  if(attemptObj[qk] !== undefined) return attemptObj[qk];
  if(attemptObj['q'+qk] !== undefined) return attemptObj['q'+qk];
  if(attemptObj['Q'+qk] !== undefined) return attemptObj['Q'+qk];
  if(attemptObj['q'+qk] !== undefined) return attemptObj['q'+qk];
  if(attemptObj[String(qk)] !== undefined) return attemptObj[String(qk)];
  // some QuizResults store answers under a top-level 'answers' object with numeric keys as strings
  if(attemptObj.answers && typeof attemptObj.answers === 'object'){
    if(attemptObj.answers[String(qIndex)] !== undefined) return attemptObj.answers[String(qIndex)];
    // try to find keys like 'Q1', 'q1', or any key whose numeric part equals qIndex (robust matching)
    for(const k of Object.keys(attemptObj.answers)){
      if(!k) continue;
      const num = k.replace(/\D/g,'');
      if(num === String(qIndex)) return attemptObj.answers[k];
    }
  }
  return undefined;
}

// Fetch student name
async function getStudentName(sid){
  const snap = await rtdb.ref("StudentAccount/"+sid).get();
  if(!snap.exists()) return sid;
  const acc = snap.val();
  // prefer canonical camelCase keys, fallback to older lowercase ones
  const fn = acc.firstName || acc.firstname || acc.name || '';
  const ln = acc.lastName || acc.lastname || '';
  const full = (fn + ' ' + ln).trim();
  return full || sid;
}

// Subscribe to student progress (real-time)
function subscribeStudentProgress(ch){
  const container=document.getElementById(`progress-tab-${ch}`);
  container.innerHTML="<p>Loading...</p>";

  rtdb.ref().on("value", async snapshot=>{
    const allData = snapshot.val() || {};
    const quizResults = allData.QuizResults || {};
    const studentsProgress = allData.StudentsProgress || {};

    // Collect attempts per student: { sid: [ {score, date, timeSpent, source, attemptIndex}, ... ] }
    const attemptsByStudent = {};

    // Helper to push attempt
    function pushAttempt(sid, attempt){
      if(!attemptsByStudent[sid]) attemptsByStudent[sid] = [];
      attemptsByStudent[sid].push(attempt);
    }

    // QuizResults (structure: QuizResults[sid][chapter][attemptKey] = {score,date,timeSpent})
    for(const sid in quizResults){
      if(!quizResults[sid] || !quizResults[sid][ch]) continue;
      const chapterEntries = quizResults[sid][ch];
      const keys = Object.keys(chapterEntries).sort();
      keys.forEach((key, idx) => {
        const res = chapterEntries[key] || {};
        // store the real attempt key so we can fetch the exact child later
        pushAttempt(sid, { score: res.score || 0, date: res.date || '', timeSpent: res.timeSpent || 0, source: 'QuizResults', attemptKey: key, displayIndex: idx+1 });
      });
    }

    // StudentsProgress (structure: StudentsProgress[sid][chapter][attemptKey] = {keysFound,date,timeSpent})
    for(const sid in studentsProgress){
      if(!studentsProgress[sid] || !studentsProgress[sid][ch]) continue;
      const chapterEntries = studentsProgress[sid][ch];
      const keys = Object.keys(chapterEntries).sort();
      keys.forEach((key, idx) => {
        const res = chapterEntries[key] || {};
        pushAttempt(sid, { score: res.keysFound || 0, date: res.date || '', timeSpent: res.timeSpent || 0, source: 'StudentsProgress', attemptKey: key, displayIndex: idx+1 });
      });
    }

    // Build HTML: per-student collapsible card with attempts table
    let html = '';
    const sids = Object.keys(attemptsByStudent).sort();
    for(const sid of sids){
      const studentName = await getStudentName(sid);
      const attempts = attemptsByStudent[sid] || [];
      // sort attempts by attemptIndex (already ordered) or date
      attempts.sort((a,b)=> (a.attemptIndex||0) - (b.attemptIndex||0));

      // build attempts table rows
      let attemptsRows = '';
    attempts.forEach(a => {
        const displayLabel = a.displayIndex ? a.displayIndex : (a.attemptKey || '1');
        const attemptKeyEsc = a.attemptKey ? a.attemptKey : String(a.displayIndex || '1');
          attemptsRows += `<tr><td>${escapeHtml(displayLabel)}</td><td>${a.score}</td><td>${escapeHtml(a.date)}</td><td>${escapeHtml(a.timeSpent)} mins</td><td>${escapeHtml(a.source)}</td><td><button class="view-btn" data-view-attempt="${sid}|${ch}|${attemptKeyEsc}"><span class="ico"><i class="fas fa-eye"></i></span> View</button> <button class="answers-btn" data-inline-answers="${sid}|${ch}|${attemptKeyEsc}"><span class="ico"><i class="fas fa-file-lines"></i></span> Answers</button></td></tr>`;
      });

      html += `
        <div class="data-header progress-header" data-sid="${sid}" style="display:flex;justify-content:space-between;align-items:center;cursor:pointer;">
          <div><strong>${studentName}</strong> <span style="color:#666;margin-left:8px;">(${sid})</span></div>
          <div style="color:#666">Attempts: ${attempts.length}</div>
        </div>
        <div class="chapter-body attempts-body" style="display:none; padding:10px 14px; margin-bottom:12px;">
          <table class='progress-table'>
            <thead><tr><th>Attempt #</th><th>Score</th><th>Date</th><th>Time Spent</th><th>Source</th></tr></thead>
            <tbody>
              ${attemptsRows}
            </tbody>
          </table>
        </div>
      `;
    }

    if(!sids.length) html = '<p>No attempts found.</p>';
    container.innerHTML = html;

    // Attach click handlers to toggle attempts
    document.querySelectorAll('.progress-header').forEach(h => {
      h.addEventListener('click', ()=>{
        const next = h.nextElementSibling;
        if(!next) return;
        const isOpen = next.style.display && next.style.display !== 'none';
        next.style.display = isOpen ? 'none' : 'block';
      });
    });
  });
}

// View attempt details handler (delegated)
document.addEventListener('click', async (e)=>{
  const btn = e.target.closest && e.target.closest('[data-view-attempt]');
  if(!btn) return;
  const val = btn.getAttribute('data-view-attempt'); // sid|chapter|attemptIndex
  const [sid, ch, attemptIndex] = val.split('|');
  // fetch attempt object from StudentsProgress or QuizResults
  try{
    // attemptIndex is actually the attemptKey (random push id) or numeric index; use fetchAttemptObject which tries exact keys first
    const attemptKey = attemptIndex;
    const fetched = await fetchAttemptObject(sid, ch, attemptKey);
    let attemptObj = fetched && fetched.obj ? fetched.obj : null;
    let source = fetched && fetched.source ? fetched.source : 'unknown';
    if(!attemptObj){
      const fallbackHtml = `<div style="max-height:60vh;overflow:auto"><h3>No stored answers found</h3><p>There is no per-attempt record for this attempt and no chapter-level answers were found in the database for this student/chapter.</p><p>Check that the student's attempts were saved under <code>QuizResults/${sid}/${ch}</code> or <code>StudentsProgress/${sid}/${ch}</code>.</p></div>`;
      showAttemptModal(fallbackHtml);
      return;
    }

    // Load chapter quiz questions to compare answers
    const quizSnap = await rtdb.ref(`quizzes/${ch}/questions`).get();
    const questions = quizSnap.exists() ? quizSnap.val() : {};

    // Build modal content: iterate questions in numeric order by questionIndex
    const qKeys = Object.keys(questions || {}).sort((a,b)=> Number(a) - Number(b));
    let html = `<div style="max-height:60vh;overflow:auto">`;
    html += `<h3>Attempt ${escapeHtml(attemptIndex)} — Student ${escapeHtml(sid)} — Source: ${escapeHtml(source)}</h3>`;

    if(qKeys.length===0){ html += `<p>No question definitions found for this chapter.</p>`; }
    else {
      qKeys.forEach(qk => {
        const q = questions[qk];
        // Determine student's response for this question from attemptObj
        // Attempt shapes vary: could be {answers: {qIndex: value}} or {responses: [...] } or flat fields. We'll try several heuristics.
  // extract student response using helper (qk is key, qIndex = numeric index)
  const qIndex = Number(qk);
  let studentResp = extractStudentResponse(attemptObj, qk, qIndex);
  // normalize stored responses (map numeric indices to choice text) so evaluation compares like-with-like
  const normResp = normalizeStudentResponse(q, studentResp);

  // evaluate correctness using evaluateAnswer (use normalized response)
  const correct = evaluateAnswer(q, normResp);
  // detect explicit no-response (undefined/null/empty string/empty array)
  const isNoResponse = (normResp === undefined || normResp === null || (Array.isArray(normResp) && normResp.length===0) || (typeof normResp === 'string' && String(normResp).trim()===''));
  // result state: 'Correct', 'Incorrect' or 'No response' (no-response should not be shown as wrong)
  let cls = 'question-result';
  let resultText = '';
  let resultColor = '#d33';
  if(isNoResponse){ resultText = 'No response'; cls = 'question-result'; resultColor = '#666'; }
  else if(correct){ resultText = 'Correct'; cls = 'question-result correct'; resultColor = '#2b8a3e'; }
  else { resultText = 'Incorrect'; cls = 'question-result wrong'; resultColor = '#d33'; }
        html += `<div class="${cls}" style="padding:10px;border-bottom:1px solid #eee;margin-bottom:8px;">
          <div style="display:flex;justify-content:space-between;align-items:center"><div style="font-weight:700;color:#501121">Q${escapeHtml(q.questionIndex || qk)}: ${escapeHtml(q.question||'')}</div><div style="font-size:12px;color:#666">${escapeHtml(q.type||'')}</div></div>`;

        if(q.type === 'multiple_choice'){
          // render choices and highlight correct and student selection
          const choices = Array.isArray(q.choices) ? q.choices : (q.choices ? Object.values(q.choices) : []);
          const correctOptions = Array.isArray(q.answer) ? q.answer : (q.answer !== undefined ? [q.answer] : []);
          // map correct options to display text (handle numeric indices and prefixes)
          const correctOptionsText = correctOptions.map(co=>{
            if(co === undefined || co === null) return String(co);
            if(!isNaN(Number(co))){ const n=Number(co); const idx=(n===0?0:n-1); return choices[idx] !== undefined ? choices[idx] : String(co); }
            const sCo = String(co).trim().replace(/^[A-Da-d]\s*[\.|\)]\s*/,'').replace(/^\d+\.\s*/,'').trim();
            return sCo;
          });

          // student selections normalized to array for easy checks
          let studentSelections = [];
          if(Array.isArray(normResp)) studentSelections = normResp.slice();
          else if(normResp !== undefined && normResp !== null && String(normResp).trim() !== '') studentSelections = [String(normResp)];

          // comparison helper honoring case sensitivity
          const cmp = (a,b) => {
            if(a === undefined || b === undefined) return false;
            if(q.caseSensitive) return String(a).trim() === String(b).trim();
            return String(a).toLowerCase().trim() === String(b).toLowerCase().trim();
          };

          html += `<div style="margin-top:8px;display:flex;flex-direction:column;">`;
          let anySelected = false;
          choices.forEach((opt, idx)=>{
            // is this option one of the correct options by value
            const isCorrectOpt = correctOptionsText.some(co => cmp(opt, co));
            // determine if student selected this option
            const isSelected = studentSelections.some(sel => cmp(sel, opt) || cmp(sel, String(idx)) || cmp(sel, String(idx+1)));
            if(isSelected) anySelected = true;
            const chCls = `choice ${isCorrectOpt ? 'correct-choice':''} ${isSelected ? 'student-choice':''}`;
            const tags = [];
            if(isCorrectOpt) tags.push('<span class="tag correct">Correct</span>');
            if(isSelected) tags.push('<span class="tag selected">Selected</span>');
            html += `<div class="${chCls}"><div>${escapeHtml(opt)}</div><div>${tags.join(' ')}</div></div>`;
          });
          html += `</div>`;
          // if student provided a response but it didn't match any choice, show that explicitly
          if(!anySelected && studentSelections.length>0){
            const rawDisplay = Array.isArray(studentResp) ? studentResp.join(', ') : String(studentResp);
            html += `<div style="margin-top:6px;color:#a23">Student answered (not in choices): <span style="font-weight:600">${escapeHtml(rawDisplay)}</span></div>`;
          }
          // if student didn't select anything, show explicit no response
          if(!anySelected){ html += `<div style="margin-top:6px;font-style:italic;color:#666">Student answer: <span style="font-weight:600">(no response)</span></div>`; }
          // show raw stored response and normalized mapping for instructor clarity
          try{
            const rawDisplay = (studentResp === undefined || studentResp === null || (Array.isArray(studentResp) && studentResp.length===0) || (typeof studentResp === 'string' && String(studentResp).trim()==='')) ? '(no response)' : (Array.isArray(studentResp) ? studentResp.join(', ') : String(studentResp));
            const normDisplay = (normResp === undefined || normResp === null || (Array.isArray(normResp) && normResp.length===0) || (typeof normResp === 'string' && String(normResp).trim()==='')) ? '(no response)' : (Array.isArray(normResp) ? normResp.join(', ') : String(normResp));
            html += `<div style="margin-top:6px;color:#444">Student response (raw): <span style="font-weight:600">${escapeHtml(rawDisplay)}</span></div>`;
            html += `<div style="margin-top:4px;color:#444">Normalized: <span style="font-weight:600">${escapeHtml(normDisplay)}</span></div>`;
          }catch(e){ /* ignore display errors */ }
          // if student is incorrect, show which option(s) are correct
          if(!correct && correctOptions.length){
            const mappedCorrect = correctOptionsText.join(', ');
            html += `<div style="margin-top:8px;">Correct answer: <span style="font-weight:700">${escapeHtml(mappedCorrect)}</span></div>`;
          }
          html += `<div style="margin-top:8px;">Result: <span style="font-weight:700;color:${resultColor}">${escapeHtml(resultText)}</span></div>`;
        } else {
          html += `<div style="margin-top:6px;">Expected: <span style='font-weight:600'>${escapeHtml(String(q.answer===undefined?JSON.stringify(q.choices||''): q.answer))}</span></div>`;
          html += `<div style="margin-top:6px;">Student answer: <span style='font-weight:600'>${escapeHtml(String(studentResp===undefined?'(no response)': studentResp))}</span></div>`;
          html += `<div style="margin-top:6px;color:${resultColor};font-weight:700">${escapeHtml(resultText)}</div>`;
        }
        html += `</div>`;
      });
    }
    html += `</div>`;

    // show custom modal (reuse simple modal pattern)
    showAttemptModal(html);
  }catch(err){ console.error(err); alert('Error loading attempt details: '+ (err && err.message ? err.message : err)); }
});

// Helper: fetch an attempt object with fallbacks (per-attempt nodes, chapter-level nodes)
async function fetchAttemptObject(sid, ch, attemptIndex){
  console.debug('fetchAttemptObject()', { sid, ch, attemptIndex });
  // attemptIndex may actually be a push-key (random id) or a numeric index. Try exact key paths first.
  const spPathExact = `StudentsProgress/${sid}/${ch}/${attemptIndex}`;
  const spSnapExact = await rtdb.ref(spPathExact).get();
  console.debug('checked exact', spPathExact, 'exists=', spSnapExact.exists());
  if(spSnapExact.exists()) return { obj: spSnapExact.val(), source: spPathExact };
  const qrPathExact = `QuizResults/${sid}/${ch}/${attemptIndex}`;
  const qrSnapExact = await rtdb.ref(qrPathExact).get();
  console.debug('checked exact', qrPathExact, 'exists=', qrSnapExact.exists());
  if(qrSnapExact.exists()) return { obj: qrSnapExact.val(), source: qrPathExact };

  // If not found by exact key, fall back to previous numeric-index logic (attemptIndex may be numeric)
  // try StudentsProgress per-attempt (numeric)
  const spPath = `StudentsProgress/${sid}/${ch}/${attemptIndex}`;
  const spSnap = await rtdb.ref(spPath).get();
  console.debug('checked numeric', spPath, 'exists=', spSnap.exists());
  if(spSnap.exists()) return { obj: spSnap.val(), source: spPath };
  const qrPath = `QuizResults/${sid}/${ch}/${attemptIndex}`;
  const qrSnap = await rtdb.ref(qrPath).get();
  console.debug('checked numeric', qrPath, 'exists=', qrSnap.exists());
  if(qrSnap.exists()) return { obj: qrSnap.val(), source: qrPath };

  // try chapter-level QuizResults
  const chapterQrPath = `QuizResults/${sid}/${ch}`;
  const chapterQrSnap = await rtdb.ref(chapterQrPath).get();
  console.debug('checked', chapterQrPath, 'exists=', chapterQrSnap.exists());
  if(chapterQrSnap.exists()){
    const chVal = chapterQrSnap.val();
    const chKeys = Object.keys(chVal||{});
    console.debug('chapterQr keys sample=', chKeys.slice(0,5));
    if(chVal && (chVal.answers || chVal.responses || chKeys.some(k=>isNaN(Number(k))))) return { obj: chVal, source: chapterQrPath };
    if(chKeys.length) return { obj: chVal[chKeys[0]], source: `${chapterQrPath}:${chKeys[0]}` };
  }

  // try chapter-level StudentsProgress
  const chapterSpPath = `StudentsProgress/${sid}/${ch}`;
  const chapterSpSnap = await rtdb.ref(chapterSpPath).get();
  console.debug('checked', chapterSpPath, 'exists=', chapterSpSnap.exists());
  if(chapterSpSnap.exists()){
    const spVal = chapterSpSnap.val(); const spKeys = Object.keys(spVal||{});
    console.debug('chapterSp keys sample=', spKeys.slice(0,5));
    if(spVal && (spVal.answers || spVal.responses || spKeys.some(k=>isNaN(Number(k))))) return { obj: spVal, source: chapterSpPath };
    if(spKeys.length) return { obj: spVal[spKeys[0]], source: `${chapterSpPath}:${spKeys[0]}` };
  }
  return null;
}

// Return a list of attempts (keys) for a student/chapter with simple labels (date or key)
async function getAttemptList(sid, ch){
  const list = [];
  try{
    const qrSnap = await rtdb.ref(`QuizResults/${sid}/${ch}`).get();
    if(qrSnap.exists()){
      const val = qrSnap.val();
      Object.keys(val||{}).forEach(k=>{
        const item = val[k] || {};
        const label = item.date ? `${item.date} (${k.substr(0,6)})` : `${k}`;
        list.push({ key: k, source: 'QuizResults', date: item.date || '', score: item.score || null, label });
      });
    }
  }catch(e){ console.debug('getAttemptList QuizResults read failed', e); }
  try{
    const spSnap = await rtdb.ref(`StudentsProgress/${sid}/${ch}`).get();
    if(spSnap.exists()){
      const val = spSnap.val();
      Object.keys(val||{}).forEach(k=>{
        // only add if not already present (prefer QuizResults)
        if(list.some(x=>x.key === k)) return;
        const item = val[k] || {};
        const label = item.date ? `${item.date} (${k.substr(0,6)})` : `${k}`;
        list.push({ key: k, source: 'StudentsProgress', date: item.date || '', score: item.keysFound || null, label });
      });
    }
  }catch(e){ console.debug('getAttemptList StudentsProgress read failed', e); }
  // Sort by date desc if available, else keep insertion order
  list.sort((a,b)=>{
    if(a.date && b.date) return (a.date < b.date) ? 1 : -1;
    return 0;
  });
  return list;
}

// Render the questions block HTML for an attempt object
function renderAttemptQuestionsHtml(attemptObj, source, questions){
  const qKeys = Object.keys(questions || {}).sort((a,b)=> Number(a) - Number(b));
  let html = `<div style="max-height:60vh;overflow:auto">`;
  html += `<h3>Source: ${escapeHtml(source)}</h3>`;
  // If the attempt object looks like a direct answers map (keys like 'Q1', '1', etc), wrap it so extractor finds it
  let effectiveAttempt = attemptObj || {};
  try{
    if(!attemptObj) effectiveAttempt = {};
    else if(!attemptObj.answers){
      const keys = Object.keys(attemptObj||{});
      const looksLikeAnswers = keys.length > 0 && keys.some(k => /^q?\d+$/i.test(k) || /^Q\d+$/i.test(k) || /^Q\d+$/.test(k));
      if(looksLikeAnswers){ effectiveAttempt = { answers: attemptObj }; }
    }
  }catch(e){ effectiveAttempt = attemptObj; }
  if(qKeys.length===0){ html += `<p>No question definitions found for this chapter.</p>`; }
  else {
    qKeys.forEach(qk => {
      const q = questions[qk];
      const qIndex = Number(qk);
      const studentResp = extractStudentResponse(attemptObj, qk, qIndex);
      const normResp = normalizeStudentResponse(q, studentResp);
      const correct = evaluateAnswer(q, normResp);
      const isNoResponse = (normResp === undefined || normResp === null || (Array.isArray(normResp) && normResp.length===0) || (typeof normResp === 'string' && String(normResp).trim()===''));
      let cls = 'question-result';
      let resultText = '';
      let resultColor = '#d33';
      if(isNoResponse){ resultText = 'No response'; cls = 'question-result'; resultColor = '#666'; }
      else if(correct){ resultText = 'Correct'; cls = 'question-result correct'; resultColor = '#2b8a3e'; }
      else { resultText = 'Incorrect'; cls = 'question-result wrong'; resultColor = '#d33'; }
      html += `<div class="${cls}" style="padding:10px;border-bottom:1px solid #eee;margin-bottom:8px;">`;
      html += `<div style="display:flex;justify-content:space-between;align-items:center"><div style="font-weight:700;color:#501121">Q${escapeHtml(q.questionIndex || qk)}: ${escapeHtml(q.question||'')}</div><div style="font-size:12px;color:#666">${escapeHtml(q.type||'')}</div></div>`;
      if(q.type === 'multiple_choice'){
        const choices = Array.isArray(q.choices) ? q.choices : (q.choices ? Object.values(q.choices) : []);
        const correctOptions = Array.isArray(q.answer) ? q.answer : (q.answer !== undefined ? [q.answer] : []);
        const correctOptionsText = correctOptions.map(co=>{
          if(co === undefined || co === null) return String(co);
          if(!isNaN(Number(co))){ const n=Number(co); const idx=(n===0?0:n-1); return choices[idx] !== undefined ? choices[idx] : String(co); }
          return String(co).trim().replace(/^[A-Za-z]\s*[\.\)]\s*/,'').replace(/^\d+\.\s*/,'').trim();
        });
        let studentSelections = [];
        if(Array.isArray(normResp)) studentSelections = normResp.slice();
        else if(normResp !== undefined && normResp !== null && String(normResp).trim() !== '') studentSelections = [String(normResp)];
        const cmp = (a,b) => { if(a === undefined || b === undefined) return false; if(q.caseSensitive) return String(a).trim() === String(b).trim(); return String(a).toLowerCase().trim() === String(b).toLowerCase().trim(); };
        html += `<div style="margin-top:8px;display:flex;flex-direction:column;">`;
        let anySelected = false;
        choices.forEach((opt, idx)=>{
          const isCorrectOpt = correctOptionsText.some(co => cmp(opt, co));
          const isSelected = studentSelections.some(sel => cmp(sel, opt) || cmp(sel, String(idx)) || cmp(sel, String(idx+1)));
          if(isSelected) anySelected = true;
          const chCls = `choice ${isCorrectOpt ? 'correct-choice':''} ${isSelected ? 'student-choice':''}`;
          const tags = [];
          if(isCorrectOpt) tags.push('<span class="tag correct">Correct</span>');
          if(isSelected) tags.push('<span class="tag selected">Selected</span>');
          html += `<div class="${chCls}"><div>${escapeHtml(opt)}</div><div>${tags.join(' ')}</div></div>`;
        });
        html += `</div>`;
        if(!anySelected && studentSelections.length>0){ const rawDisplay = Array.isArray(studentResp) ? studentResp.join(', ') : String(studentResp); html += `<div style="margin-top:6px;color:#a23">Student answered (not in choices): <span style="font-weight:600">${escapeHtml(rawDisplay)}</span></div>`; }
        try{
          const rawDisplay = (studentResp === undefined || studentResp === null || (Array.isArray(studentResp) && studentResp.length===0) || (typeof studentResp === 'string' && String(studentResp).trim()==='')) ? '(no response)' : (Array.isArray(studentResp) ? studentResp.join(', ') : String(studentResp));
          const normDisplay = (normResp === undefined || normResp === null || (Array.isArray(normResp) && normResp.length===0) || (typeof normResp === 'string' && String(normResp).trim()==='')) ? '(no response)' : (Array.isArray(normResp) ? normResp.join(', ') : String(normResp));
          html += `<div style="margin-top:6px;color:#444">Student response (raw): <span style="font-weight:600">${escapeHtml(rawDisplay)}</span></div>`;
          html += `<div style="margin-top:4px;color:#444">Normalized: <span style="font-weight:600">${escapeHtml(normDisplay)}</span></div>`;
        }catch(e){}
        if(!correct && correctOptions.length && !isNoResponse){ const mappedCorrect = correctOptionsText.join(', '); html += `<div style="margin-top:8px;">Correct answer: <span style="font-weight:700">${escapeHtml(mappedCorrect)}</span></div>`; }
        html += `<div style="margin-top:8px;">Result: <span style="font-weight:700;color:${resultColor}">${escapeHtml(resultText)}</span></div>`;
      } else {
        html += `<div style="margin-top:6px;">Expected: <span style='font-weight:600'>${escapeHtml(String(q.answer===undefined?JSON.stringify(q.choices||''): q.answer))}</span></div>`;
        html += `<div style="margin-top:6px;">Student answer: <span style='font-weight:600'>${escapeHtml(String(studentResp===undefined?'(no response)': studentResp))}</span></div>`;
        html += `<div style="margin-top:6px;color:${resultColor};font-weight:700">${escapeHtml(resultText)}</div>`;
      }
      html += `</div>`;
    });
  }
  html += `</div>`;
  return html;
}

// Delegated handler for inline answers button
document.addEventListener('click', async (e)=>{
  const btn = e.target.closest && e.target.closest('[data-inline-answers]');
  if(!btn) return;
  try{
    const val = btn.getAttribute('data-inline-answers'); // sid|chapter|attemptIndex
  const parts = val ? val.split('|') : [];
  const sid = parts[0], ch = parts[1], attemptKey = parts[2];
  console.debug('Answers clicked', { val, sid, ch, attemptKey });
    const tr = btn.closest('tr');
    if(!tr) console.debug('Answers handler: no enclosing <tr> found for button, continuing anyway');

    // fetch attempt object with logging
    let fetched = null;
    console.debug('Answers handler: calling fetchAttemptObject', { sid, ch, attemptKey });
    try{
      fetched = await fetchAttemptObject(sid, ch, attemptKey);
      console.debug('fetchAttemptObject returned', { fetchedSummary: fetched ? { source: fetched.source, sampleKeys: fetched.obj ? Object.keys(fetched.obj).slice(0,5) : null } : null });
    }catch(err){
      console.error('fetchAttemptObject threw', err);
      showAttemptModal(`<div style="padding:12px"><h3>Error fetching attempt</h3><pre>${escapeHtml(err && err.message ? err.message : String(err))}</pre></div>`);
      return;
    }

    if(!fetched || !fetched.obj){
      console.debug('No fetched attempt object, showing fallback modal', { fetched });
      const fallbackHtml = `<div style="max-height:60vh;overflow:auto;padding:12px"><h3>No stored answers found</h3><p>There is no stored answers for this attempt.</p><pre>Request: ${escapeHtml(val)}</pre></div>`;
      try{ showAttemptModal(fallbackHtml); } catch(showErr){ console.error('showAttemptModal failed', showErr); alert('No stored answers and failed to open modal. See console.'); }
      return;
    }

    // We will show a modal that contains a dropdown of attempts so the instructor can select any attempt (by key)
    const quizSnap = await rtdb.ref(`quizzes/${ch}/questions`).get();
    const questions = quizSnap.exists() ? quizSnap.val() : {};
    const attempts = await getAttemptList(sid, ch);
    if(attempts.length === 0){ showAttemptModal(`<div style="padding:12px"><h3>No attempts found</h3><p>There are no attempts in QuizResults or StudentsProgress for this student/chapter.</p></div>`); return; }
    // build modal content with select
    let inner = `<div style="padding:8px;max-height:70vh;overflow:auto">`;
    inner += `<div style="display:flex;gap:8px;align-items:center;margin-bottom:10px"><label style="font-weight:700">Choose attempt:</label><select id="attemptPicker">`;
    attempts.forEach(a=>{ inner += `<option value="${escapeHtml(a.key)}">${escapeHtml(a.label)}</option>`; });
    inner += `</select></div>`;
    // placeholder for questions content
    inner += `<div id="attemptQuestionsContainer">Loading...</div>`;
    inner += `</div>`;
    showAttemptModal(inner);
    // load first attempt
    const picker = document.getElementById('attemptPicker');
    const containerEl = document.getElementById('attemptQuestionsContainer');
    async function loadByKey(key){
      containerEl.innerHTML = 'Loading attempt...';
      try{
        const fetchedAttempt = await fetchAttemptObject(sid, ch, key);
        if(!fetchedAttempt || !fetchedAttempt.obj){ containerEl.innerHTML = `<div style="color:#a23">Attempt data not found for key: ${escapeHtml(key)}</div>`; return; }
        const html = renderAttemptQuestionsHtml(fetchedAttempt.obj, fetchedAttempt.source, questions);
        containerEl.innerHTML = html;
      }catch(e){ containerEl.innerHTML = `<div style="color:#a23">Error loading attempt: ${escapeHtml(e && e.message? e.message : String(e))}</div>`; }
    }
    // initial load
    await loadByKey(attempts[0].key);
    // change handler
    picker.addEventListener('change', async (ev)=>{ await loadByKey(ev.target.value); });
  }catch(err){ console.error('Unhandled error in Answers handler', err); showAttemptModal(`<div style="padding:12px"><h3>Unhandled error</h3><pre>${escapeHtml(err && err.message ? err.message : String(err))}</pre></div>`); }
});

// Simple attempt modal implementation
function showAttemptModal(innerHtml){
  console.debug('showAttemptModal called, innerHtml length=', innerHtml ? innerHtml.length : 0);
  let modal = document.getElementById('attemptDetailsModal');
  if(!modal){
    modal = document.createElement('div'); modal.id='attemptDetailsModal'; modal.className='modal';
  const content = document.createElement('div'); content.className='modal-content'; content.style.maxWidth='900px';
  // limit modal height and keep its content scrollable when large
  content.style.maxHeight = '80vh';
  content.style.overflow = 'hidden';
    content.innerHTML = `
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:12px;">
        <div style="display:flex;flex-direction:column;">
          <div style="display:flex;align-items:center;gap:12px"><h3 id="attemptModalTitle">Attempt Details</h3><span id="wrongSummary" style="color:#d33;font-weight:700"></span></div>
          <div style="font-size:13px;color:#666" id="attemptModalSub"></div>
        </div>
        <div style="display:flex;gap:8px;align-items:center;">
          <button id="filterWrongBtn" class="btn" style="background:#fff;border:1px solid #ccc;padding:6px 10px;border-radius:6px;">Show Wrong Only</button>
          <button style="background:#fff;border:1px solid #ccc;padding:6px 10px;border-radius:6px;" id="closeAttemptModal">Close</button>
        </div>
      </div>
      <div id="attemptDetailsContent"></div>`;
    modal.appendChild(content); document.body.appendChild(modal);
    // Attach handlers after appending
    try{ document.getElementById('closeAttemptModal').addEventListener('click', ()=>{ modal.style.display='none'; }); }catch(e){ console.error('attach closeAttemptModal failed', e); }
    try{ document.getElementById('filterWrongBtn').addEventListener('click', ()=>{
      const btn = document.getElementById('filterWrongBtn'); const showing = btn.dataset.showing === '1';
      btn.dataset.showing = showing ? '0' : '1'; btn.textContent = showing ? 'Show Wrong Only' : 'Show All';
      document.querySelectorAll('#attemptDetailsContent .question-result').forEach(el=>{
        if(showing){ el.style.display='block'; } else { if(el.classList.contains('wrong')) el.style.display='block'; else el.style.display='none'; }
      });
    }); }catch(e){ console.error('attach filterWrongBtn failed', e); }
  }
  // ensure modal is attached to body and visible with inline styles in case external CSS hides it
  if(!modal.parentNode || modal.parentNode !== document.body) document.body.appendChild(modal);
  // Force important inline styles to override page CSS
  modal.style.setProperty('position','fixed','important');
  modal.style.setProperty('left','0','important'); modal.style.setProperty('top','0','important'); modal.style.setProperty('width','100%','important'); modal.style.setProperty('height','100%','important');
  modal.style.setProperty('display','flex','important'); modal.style.setProperty('align-items','center','important'); modal.style.setProperty('justify-content','center','important');
  modal.style.setProperty('z-index','2147483647','important');
  modal.style.setProperty('background','rgba(0,0,0,0.65)','important');
  // ensure content container exists and make it scrollable (so long answers don't expand modal)
  let contentEl = modal.querySelector('#attemptDetailsContent');
  if(!contentEl){
    const cont = document.createElement('div'); cont.id='attemptDetailsContent';
    const wrapper = modal.querySelector('.modal-content') || modal.firstChild;
    if(wrapper) wrapper.appendChild(cont); contentEl = cont;
  }
  // set scrollable area inside modal
  contentEl.style.maxHeight = 'calc(80vh - 120px)';
  contentEl.style.overflowY = 'auto';
  contentEl.style.padding = contentEl.style.padding || '8px';
  try{
    contentEl.innerHTML = innerHtml;
  }catch(e){ console.error('Failed to set attemptDetailsContent.innerHTML', e); }
  // update wrong count and default state
  const modalEl = document.getElementById('attemptDetailsModal');
  const wrongEls = modalEl ? modalEl.querySelectorAll('.question-result.wrong') : [];
  const wrongSummary = document.getElementById('wrongSummary');
  wrongSummary.textContent = wrongEls.length ? `Wrong: ${wrongEls.length}` : '';
  // reset filter button
  const filterBtn = document.getElementById('filterWrongBtn'); if(filterBtn){ filterBtn.dataset.showing='0'; filterBtn.textContent='Show Wrong Only'; }
  // focus for accessibility after a tiny delay
  setTimeout(()=>{
    try{ const first = modal.querySelector('.modal-content'); if(first) first.focus(); }catch(e){}
  },50);
}

// Modal helpers
function openQuestionModal(ch){ currentChapter=ch; editingQuestionId=null; resetModal(); document.getElementById('questionModal').style.display='flex'; }
function closeQuestionModal(){ document.getElementById('questionModal').style.display='none'; }
function toggleQuestionType(){ const t=document.getElementById('questionType').value; document.getElementById('mcFields').style.display=t==='multipleChoice'?'block':'none'; document.getElementById('idFields').style.display=t==='identification'?'block':'none'; document.getElementById('tfFields').style.display=t==='true_false'?'block':'none'; }
function resetModal(){ document.getElementById('modalTitle').innerText="Add New Question"; document.getElementById('questionText').value=""; document.getElementById('questionType').value="multipleChoice"; toggleQuestionType(); ["0","1","2","3"].forEach(i=>{document.getElementById('optionText'+i).value=""; document.querySelector(`input[name='correctOption'][value='${i}']`).checked=false;}); document.getElementById('identificationAnswer').value=""; document.querySelectorAll("input[name='trueFalseAnswer']").forEach(r=>r.checked=false); }

// Reset extended settings
function resetExtendedSettings(){
  document.getElementById('optCaseSensitive').checked = false;
  document.getElementById('optOrderMatters').checked = false;
  document.getElementById('optRandomizeOptions').checked = false;
  document.getElementById('idCaseSensitive').checked = false;
  document.getElementById('idOrderMatters').checked = false;
}

// Save question
async function saveQuestion(){
  const text=document.getElementById('questionText').value.trim();
  const type=document.getElementById('questionType').value;
  if(!text){alert("Enter question"); return;}
  let payload={question:text, showAnswer:true};
  if(type==="multipleChoice"){
    const opts=[0,1,2,3].map(i=>document.getElementById('optionText'+i).value.trim());
    const checked=document.querySelector("input[name='correctOption']:checked");
    if(!checked){alert("Select correct option"); return;}
    if(opts.some(o=>!o)){alert("Fill all options"); return;}
    payload.choices=opts; payload.answer=opts[checked.value]; payload.type="multiple_choice";
    // extended options
    payload.caseSensitive = !!document.getElementById('optCaseSensitive').checked;
    payload.orderMatters = !!document.getElementById('optOrderMatters').checked;
    payload.randomizeOptions = !!document.getElementById('optRandomizeOptions').checked;
  } else if(type==="identification"){
    const ans=document.getElementById('identificationAnswer').value.trim();
    if(!ans){alert("Enter answer"); return;}
    payload.answer=ans; payload.type="identification";
    payload.caseSensitive = !!document.getElementById('idCaseSensitive').checked;
    payload.orderMatters = !!document.getElementById('idOrderMatters').checked;
  } else if(type==="true_false"){
    const checked=document.querySelector("input[name='trueFalseAnswer']:checked");
    if(!checked){alert("Select True/False"); return;}
    payload.answer=checked.value; payload.type="true_false";
  }

  const ref=rtdb.ref(`quizzes/${currentChapter}/questions`);
  if(editingQuestionId){
    await ref.child(editingQuestionId).set(payload);
    alert("Question updated!");
  } else {
    const nextIndex = await getNextQuestionIndex(currentChapter);
    payload.questionIndex = nextIndex;
    await ref.child(nextIndex.toString()).set(payload);
    alert("Question added!");
  }
  closeQuestionModal();
  loadChapterQuestions(currentChapter);
}

// Edit
async function openEditModal(ch,id){
  currentChapter=ch; editingQuestionId=id; resetModal();
  const snap=await rtdb.ref(`quizzes/${ch}/questions/${id}`).get();
  if(!snap.exists()){alert("Missing"); return;}
  const q = snap.val();
  document.getElementById('modalTitle').innerText="Edit Question";
  document.getElementById('questionText').value=q.question;
  document.getElementById('questionType').value=q.type==="multiple_choice"?"multipleChoice":q.type;
  toggleQuestionType();
  if(q.type==="multiple_choice"){
    q.choices.forEach((opt,i)=>{document.getElementById('optionText'+i).value=opt; if(opt===q.answer) document.querySelector(`input[name='correctOption'][value='${i}']`).checked=true;});
    // populate extended settings
    document.getElementById('optCaseSensitive').checked = !!q.caseSensitive;
    document.getElementById('optOrderMatters').checked = !!q.orderMatters;
    document.getElementById('optRandomizeOptions').checked = !!q.randomizeOptions;
  } else if(q.type==="identification"){ document.getElementById('identificationAnswer').value=q.answer; }
  else if(q.type==="true_false"){ document.querySelector(`input[name='trueFalseAnswer'][value='${q.answer}']`).checked=true; }
  document.getElementById('questionModal').style.display='flex';
}

// Delete
async function deleteQuestion(ch,id){
  if(confirm("Delete this question?")){
    await rtdb.ref(`quizzes/${ch}/questions/${id}`).remove();
    loadChapterQuestions(ch);
  }
}

// Wire test modal button after DOM ready
document.addEventListener('DOMContentLoaded', ()=>{
  try{
    const tb = document.getElementById('testModalBtn');
    if(tb){ tb.addEventListener('click', ()=>{
      console.debug('Test Modal clicked');
      const sample = `<div style="max-height:60vh;overflow:auto;padding:12px;"><h3>Debug Modal</h3><p>If you see this, the modal rendering path is working. Next: test the Answers button to confirm data flow.</p></div>`;
      try{ showAttemptModal(sample); }catch(e){ console.error('showAttemptModal threw', e); alert('Modal test failed; see console.'); }
    }); }
  }catch(e){ console.error('Failed to attach Test Modal handler', e); }
});




</script>
</body>
</html>
