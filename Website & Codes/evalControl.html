<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Evaluation & Control</title>

<link rel="stylesheet" href="dashboard.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"/>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

<script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-database-compat.js"></script>

<style>
body { font-family:'Inter', sans-serif; background:#f8f9fa; margin:0; }
.data-header { cursor:pointer; padding:12px; border-radius:8px; margin:6px 0; background:#fff; display:flex; justify-content:space-between; align-items:center; box-shadow:0 2px 4px rgba(0,0,0,0.05); transition:0.2s; }
.data-header.open { background:#fefefe; }
.data-header i { transition: transform 0.2s; }
.data-header.open i { transform: rotate(90deg); }

.chapter-body { display:none; padding:16px; background:#fff; border-radius:10px; margin-bottom:16px; box-shadow:0 2px 6px rgba(0,0,0,0.03); max-height:400px; overflow-y:auto; }
.chapter-body::-webkit-scrollbar { width:8px; }
.chapter-body::-webkit-scrollbar-thumb { background:#a72344; border-radius:10px; }
.chapter-body::-webkit-scrollbar-track { background:#f1f1f1; }

.tabs { display:flex; margin-bottom:15px; border-bottom:1px solid #ddd; }
.tab { padding:10px 20px; cursor:pointer; background:#f5f5f5; border:1px solid #ddd; border-bottom:none; border-radius:5px 5px 0 0; margin-right:5px; transition:0.2s; }
.tab.active { background:#fff; border-bottom:1px solid #fff; font-weight:600; color:#a72344; }

.question-item { background:#fefefe; padding:14px; border-radius:8px; margin-bottom:12px; border:1px solid #eee; }
.question-text { font-weight:600; color:#501121; margin-bottom:8px; }
.question-options { display:grid; grid-template-columns: repeat(2,1fr); gap:8px; margin-bottom:8px; }
.question-option { padding:8px 10px; background:#fff; border-radius:6px; border:1px solid #e7e7e7; }
.correct-answer { background: rgba(76,201,240,0.08); border-color:#501121; color:#501121; font-weight:600; }
.question-actions { display:flex; justify-content:flex-end; gap:10px; }

.progress-table { width:100%; border-collapse: collapse; margin-top:10px; }
.progress-table th, .progress-table td { border:1px solid #ddd; padding:8px; text-align:left; }
.progress-table th { background:#f2f2f2; font-weight:bold; }

.question-result.correct { border-left:6px solid #2b8a3e; padding-left:8px; }
.question-result.wrong { border-left:6px solid #d33; padding-left:8px; background:#fff6f6; }

.choice { padding:8px 10px; border-radius:6px; border:1px solid #e7e7e7; margin-top:6px; display:flex; justify-content:space-between; align-items:center; }
.choice.correct-choice { background: rgba(43,138,62,0.06); border-color:#2b8a3e; }
.choice.student-choice { box-shadow: inset 0 0 0 2px rgba(0,0,0,0.04); }
.choice .tag { font-size:12px; padding:4px 6px; border-radius:6px; }
.choice .tag.correct { background:#2b8a3e;color:#fff; }
.choice .tag.selected { background:#d33;color:#fff; }

.add-question-btn { background: linear-gradient(180deg,#a72344,#7a1024); color:#fff; padding:10px 16px; border-radius:10px; font-weight:700; border:none; cursor:pointer; margin-bottom:12px; transition:0.2s; }
.add-question-btn:hover { transform:scale(1.03); }

.save-question-btn { background: linear-gradient(180deg,#4cc9f0,#501121); color:#fff; padding:10px 18px; border-radius:10px; font-weight:700; border:none; cursor:pointer; transition:0.2s; }
.save-question-btn:hover { transform:scale(1.03); }

.cancel-btn { background:#fff; color:#a72344; padding:10px 16px; border-radius:8px; font-weight:600; border:1px solid #a72344; cursor:pointer; transition:0.2s; }
.cancel-btn:hover { background:#fef1f1; }

.edit-btn { background:#501121; color:#fff; padding:8px 12px; border-radius:8px; border:none; cursor:pointer; font-weight:700; transition:0.2s; }
.edit-btn:hover { opacity:0.85; }

.delete-btn { background: linear-gradient(180deg,#ff6b6b,#d32f2f); color:#fff; padding:8px 12px; border-radius:8px; border:none; cursor:pointer; font-weight:700; transition:0.2s; }
.delete-btn:hover { opacity:0.85; }

/* Instructor action buttons in attempts table */
.view-btn, .answers-btn {
  display:inline-flex; align-items:center; gap:8px; padding:6px 10px; border-radius:8px; border:none; cursor:pointer; font-weight:700; font-size:13px; transition:transform .12s ease, box-shadow .12s ease;
}
.view-btn { background: linear-gradient(180deg,#501121,#501121); color:#fff; }
.view-btn:hover { transform:translateY(-1px); box-shadow:0 6px 14px rgba(42,166,200,0.12); }
.answers-btn { background: transparent; color:#501121; border:1px solid #501121; }
.answers-btn:hover { transform:translateY(-1px); box-shadow:0 6px 14px rgba(80,17,33,0.12); background:#fff; }
.view-btn .ico, .answers-btn .ico { width:14px; height:14px; display:inline-block; }

/* make sure FontAwesome icons inherit the button color */
.answers-btn .ico i, .view-btn .ico i { color: inherit; }

/* Section Answers button style */
.view-section-answers-btn {
  display:inline-flex; align-items:center; gap:8px; padding:8px 12px; border-radius:10px; border:none; cursor:pointer; font-weight:700; font-size:13px; background: linear-gradient(180deg,#501121,#7a1024); color:#fff; transition: transform .12s ease, box-shadow .12s ease;
}
.view-section-answers-btn:hover { transform:translateY(-2px); box-shadow:0 10px 24px rgba(80,17,33,0.16); }
.view-section-answers-btn .ico { width:14px; height:14px; display:inline-block; }


.modal { display:none; position:fixed; z-index:3000; left:0; top:0; width:100%; height:100%; background: rgba(0,0,0,0.45); align-items:center; justify-content:center; padding:20px; }
.modal-content { background:white; width:100%; max-width:600px; border-radius:12px; padding:25px; box-shadow:0 8px 20px rgba(0,0,0,0.15); animation:fadeIn 0.2s ease; }
@keyframes fadeIn { from{opacity:0; transform:translateY(-10px);} to{opacity:1; transform:translateY(0);} }

.modal-header { display:flex; justify-content:space-between; align-items:center; margin-bottom:18px; }
.modal-header h2 { color:#501121; font-size:22px; margin:0; }
.close { font-size:24px; cursor:pointer; color:#6c757d; transition:0.2s; }
.close:hover { color:#a72344; }

.question-form input[type=text] { width:100%; padding:10px; margin-bottom:10px; border-radius:8px; border:1px solid #ddd; }
.question-form select { width:100%; padding:10px; margin-bottom:12px; border-radius:8px; border:1px solid #ddd; }

#mcFields input[type=radio] { margin-right:6px; }
#tfFields label { margin-right:20px; }

/* Toggle switch */
.switch { display:inline-flex; align-items:center; gap:8px; cursor:pointer; }
.switch input[type=checkbox] { width:0; height:0; opacity:0; position:absolute; }
.switch .slider { width:44px; height:24px; background:#ccc; border-radius:20px; position:relative; transition:background 0.18s ease; display:inline-block; vertical-align:middle; }
.switch .slider::after { content:''; width:18px; height:18px; background:#fff; border-radius:50%; position:absolute; left:3px; top:3px; transition:transform 0.18s ease; box-shadow:0 1px 3px rgba(0,0,0,0.2); }
.switch input[type=checkbox]:checked + .slider { background:#4cc9f0; }
.switch input[type=checkbox]:checked + .slider::after { transform:translateX(20px); }
.switch .switch-label { margin-left:6px; display:inline-block; vertical-align:middle; color:#333; }
.settings-row { display:flex; gap:12px; align-items:center; margin-bottom:8px; flex-wrap:wrap; }

.chapters-scroll { max-height:600px; overflow-y:auto; padding-right:6px; }
.chapters-scroll::-webkit-scrollbar { width:8px; }
.chapters-scroll::-webkit-scrollbar-thumb { background:#a72344; border-radius:10px; }
</style>
<style>
/* Header action alignment */
.top-actions { display:flex; align-items:center; gap:8px; }
.top-actions .answers-btn, .top-actions #viewSectionsBtn { margin-left:6px; vertical-align:middle; padding:6px 10px; }
</style>
</head>
<body>
</style>
</head>
<body>
<div class="container-wrap">
  <div class="-main">
    <div class="main-menu">
      <img src="images/profile logo.PNG" width="60" height="60">
      <p>Math teacher</p>
      <div class="main-section">
        <p>Main</p>
        <a href="studentList.html">Student List</a>
        <a href="studentProgress.html">Student Progress</a>
        <a href="evalControl.html">Evaluation & Control</a>
        <a href="accSecSetup.html">Account & Section Setup</a>
      </div>
    </div>
  </div>

<div class="-side">
    <div class="top-bar">
  <div style="flex:1"></div>
  <div class="logout" style="display:flex; align-items:center; gap:8px;">
    <!-- text link (keeps visible text) -->
    <a href="mainWeb.html" id="logoutLink" style="color:#333; text-decoration:none;">Logout</a>
    <!-- icon button you added — now clickable and accessible -->
    <button id="logoutBtn" class="icon-btn" title="Logout" aria-label="Logout" style="color:#333; background:transparent;border:0;padding:6px;cursor:pointer;">
      <i class="fas fa-sign-out-alt"></i>
    </button>
  </div>
    </div>

    <div class="dash-window">
      <div class="header-title"><h1>Evaluation & Control</h1></div>
      <div class="data-container">
  <p style="display:flex;align-items:center;gap:10px;">Total Students: <span id="totalStudents">Loading...</span>
    <span class="top-actions">
      <button id="exportStudentsBtn" class="answers-btn"><span class="ico"><i class="fas fa-file-csv"></i></span> Export Students</button>
      <button id="viewSectionsBtn" class="answers-btn"><span class="ico"><i class="fas fa-layer-group"></i></span> View Sections</button>
    </span>
  </p>
        <div style="margin-top:8px;margin-bottom:10px;"></div>
        <div class="chapters-scroll">
          <div id="chaptersContainer"></div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Modal -->
<div class="modal" id="questionModal">
  <div class="modal-content">
    <div class="modal-header">
      <h2 id="modalTitle">Add New Question</h2>
      <span class="close" onclick="closeQuestionModal()">&times;</span>
    </div>
    <div class="question-form">
      <input type="text" id="questionText" placeholder="Enter your question">
      <select id="questionType" onchange="toggleQuestionType()">
        <option value="multipleChoice">Multiple Choice</option>
        <option value="identification">Identification</option>
        <option value="true_false">True/False</option>
      </select>
      <div id="mcFields">
        <div style="display:flex;flex-direction:column;gap:8px;margin-bottom:8px;">
          <label><input type="radio" name="correctOption" value="0"> <input type="text" id="optionText0" placeholder="Option A"></label>
          <label><input type="radio" name="correctOption" value="1"> <input type="text" id="optionText1" placeholder="Option B"></label>
          <label><input type="radio" name="correctOption" value="2"> <input type="text" id="optionText2" placeholder="Option C"></label>
          <label><input type="radio" name="correctOption" value="3"> <input type="text" id="optionText3" placeholder="Option D"></label>
        </div>
        <div class="settings-row">
          <label class="switch"><input type="checkbox" id="optCaseSensitive"><span class="slider"></span><span class="switch-label" style="font-size:13px;">Case sensitive</span></label>
          <label class="switch"><input type="checkbox" id="optOrderMatters"><span class="slider"></span><span class="switch-label" style="font-size:13px;">Order matters</span></label>
          <label class="switch"><input type="checkbox" id="optRandomizeOptions"><span class="slider"></span><span class="switch-label" style="font-size:13px;">Randomize options</span></label>
        </div>
      </div>
      <div id="idFields" style="display:none;">
        <input type="text" id="identificationAnswer" placeholder="Correct answer">
        <div style="margin-top:8px;" class="settings-row">
          <label class="switch"><input type="checkbox" id="idCaseSensitive"><span class="slider"></span><span class="switch-label" style="font-size:13px;">Case sensitive</span></label>
          <label class="switch"><input type="checkbox" id="idOrderMatters"><span class="slider"></span><span class="switch-label" style="font-size:13px;">Order matters</span></label>
        </div>
      </div>
      <div id="tfFields" style="display:none;">
        <label><input type="radio" name="trueFalseAnswer" value="True"> True</label>
        <label><input type="radio" name="trueFalseAnswer" value="False"> False</label>
      </div>
        <div style="text-align:right; margin-top:12px;">
          <button class="save-question-btn" onclick="saveQuestion()">Save</button>
          <button class="cancel-btn" onclick="closeQuestionModal()">Close</button>
        </div>
    </div>
  </div>

      <!-- Sections Modal -->
      <div class="modal" id="sectionsModal" aria-hidden="true">
        <div class="modal-content" style="max-width:900px; max-height:85vh; overflow:hidden;">
          <div class="modal-header">
            <h2>Sections & Transferred Students</h2>
            <span class="close" id="closeSectionsModal">&times;</span>
          </div>
          <div id="sectionsModalContent" style="padding:8px; max-height:calc(85vh - 120px); overflow:auto;">
            <p>Loading sections...</p>
          </div>
          <div style="text-align:right; margin-top:8px;">
          <button class="cancel-btn" id="closeSectionsModalBtn">Close</button>
          </div>
        </div>
      </div>
</div>

<script>
const firebaseConfig = {
  apiKey: "AIzaSyBkmM4hueT7PlnvV8FeRdp8g4rk0qQQrn4",
  authDomain: "midnightmathscape.firebaseapp.com",
  databaseURL: "https://midnightmathscape-e8e70-default-rtdb.firebaseio.com/",
  projectId: "midnightmathscape",
  storageBucket: "midnightmathscape.appspot.com",
  messagingSenderId: "1038485290511",
  appId: "1:1038485290511:web:c8aa78fbcd5266b706ed7a"
};
firebase.initializeApp(firebaseConfig);
const rtdb = firebase.database();

// Safe HTML escape helper
function escapeHtml(str){
  if(str === null || str === undefined) return '';
  return String(str)
    .replace(/&/g,'&amp;')
    .replace(/</g,'&lt;')
    .replace(/>/g,'&gt;')
    .replace(/"/g,'&quot;')
    .replace(/'/g,'&#39;');
}

// Count students from StudentAccount in realtime
const totalStudentsEl = document.getElementById('totalStudents');
rtdb.ref('StudentAccount').on('value', snap => {
  if (!snap.exists()) {
    totalStudentsEl.textContent = '0';
    return;
  }
  const students = snap.val();
  totalStudentsEl.textContent = Object.keys(students).length;
});

// CSV export helper for StudentAccount
async function exportStudentsCsv(){
  const snap = await rtdb.ref('StudentAccount').get();
  if(!snap.exists()){ alert('No students found'); return; }
  const data = snap.val();
  const rows = [];
  // header: include section and score summaries
  rows.push(['uid','firstname','lastname','section','totalAttempts','avgScore','lastScore','lastDate']);
  // fetch QuizResults to compute simple score summaries per student
  const qrSnap = await rtdb.ref('QuizResults').get();
  const quizResults = qrSnap.exists() ? qrSnap.val() : {};
  // try to read possible section mapping nodes (common names)
  const sectionsCandidates = ['Sections','Section','sections','sectionList','SectionList','SectionsList'];
  const sectionMap = {};
  // uid -> sectionName mapping (populated from SectionList if present)
  let uidToSection = {};
  try{
    const rootSnap = await rtdb.ref().get();
    const rootVal = rootSnap.exists() ? rootSnap.val() : {};
    for(const candidate of sectionsCandidates){
      if(rootVal[candidate] && typeof rootVal[candidate] === 'object'){
        Object.assign(sectionMap, rootVal[candidate]);
      }
    }
    // build uid -> sectionName map by scanning SectionList and common variants
    if(rootVal){
      const sectionNodes = ['SectionList','sectionList','Sections','sections'];
      sectionNodes.forEach(nodeName => {
        if(rootVal[nodeName] && typeof rootVal[nodeName] === 'object'){
          try{
            Object.keys(rootVal[nodeName]).forEach(sid => {
              const sec = rootVal[nodeName][sid] || {};
              const name = sec.name || sec.title || sid;
              if(sec.students && typeof sec.students === 'object'){
                Object.keys(sec.students).forEach(uid => { uidToSection[uid] = name; });
              }
            });
          }catch(e){ /* ignore */ }
        }
      });
    }
    // Also merge transferred students that may be stored under SectionList or similar nodes
    const transferredNodes = ['SectionList','sectionList','TransferredStudents','sectionTransfers','transferredStudents'];
    for(const nodeName of transferredNodes){
      if(rootVal && rootVal[nodeName] && typeof rootVal[nodeName] === 'object'){
        try{
          const node = rootVal[nodeName];
          // node may be sectionId -> { students: { uid: { ... } } } or flat uid -> { ... }
          Object.keys(node).forEach(key => {
            const sectionBlock = node[key];
            if(sectionBlock && sectionBlock.students && typeof sectionBlock.students === 'object'){
              Object.keys(sectionBlock.students).forEach(uid => {
                if(!data[uid]){
                  const stu = sectionBlock.students[uid] || {};
                  data[uid] = Object.assign({ firstname: stu.firstName || stu.firstname || stu.name || '', lastname: stu.lastName || stu.lastname || '', sectionId: stu.sectionId || stu.section || key }, stu);
                }
              });
            } else if(sectionBlock && sectionBlock.uid && sectionBlock.uid.students && typeof sectionBlock.uid.students === 'object'){
              // defensive: nested one deeper
              Object.keys(sectionBlock.uid.students).forEach(uid => {
                if(!data[uid]){
                  const stu = sectionBlock.uid.students[uid] || {};
                  data[uid] = Object.assign({ firstname: stu.firstName || stu.firstname || stu.name || '', lastname: stu.lastName || stu.lastname || '', sectionId: stu.sectionId || stu.section || key }, stu);
                }
              });
            } else if(sectionBlock && typeof sectionBlock === 'object' && Object.keys(sectionBlock).length>0){
              // fallback: maybe it's a flat map of uid -> student
              Object.keys(sectionBlock).forEach(uid => {
                const maybeStu = sectionBlock[uid];
                if(maybeStu && (maybeStu.firstname || maybeStu.firstName || maybeStu.lastName || maybeStu.lastname)){
                  if(!data[uid]){
                    data[uid] = Object.assign({ firstname: maybeStu.firstName || maybeStu.firstname || '', lastname: maybeStu.lastName || maybeStu.lastname || '', sectionId: maybeStu.sectionId || maybeStu.section || key }, maybeStu);
                  }
                }
              });
            }
          });
        }catch(e){ console.debug('failed merging transferred node', nodeName, e); }
      }
    }
  }catch(e){ console.debug('section map read failed', e); }
  for(const uid of Object.keys(data)){
    const s = data[uid] || {};
    // normalize name fields (various historical keys)
    const firstname = s.firstname || s.firstName || s.first || s.name || '';
    const lastname = s.lastname || s.lastName || s.surname || s.last || '';
    // aggregate scores from quizResults[uid]
    let totalAttempts = 0, sumScore = 0, lastScore = '', lastDate = '';
    const userQr = quizResults[uid] || {};
    for(const ch of Object.keys(userQr)){
      const chapter = userQr[ch] || {};
      for(const attemptKey of Object.keys(chapter)){
        const a = chapter[attemptKey] || {};
        if(a.score !== undefined && a.score !== null && !isNaN(Number(a.score))){ totalAttempts++; sumScore += Number(a.score); }
        const d = a.date || a.createdAt || a.time || '';
        if(d){
          // prefer ISO-parsable date, fall back to string compare
          try{
            const parsed = Date.parse(d);
            if(!isNaN(parsed)){
              if(!lastDate || parsed > Date.parse(lastDate)) { lastDate = d; lastScore = a.score !== undefined ? a.score : lastScore; }
            } else {
              if(!lastDate || String(d) > String(lastDate)) { lastDate = d; lastScore = a.score !== undefined ? a.score : lastScore; }
            }
          }catch(e){ /* ignore parse errors */ }
        }
      }
    }
    const avgScore = totalAttempts ? (sumScore / totalAttempts) : '';
    // resolve section name via sectionMap if possible, else pick stored sectionId from student record
    const sectionId = s.sectionId || s.section || s.sectionName || s.section_id || '';
  // prefer uid->section mapping (transfers), then sectionMap lookup, else raw id
  const sectionName = uidToSection[uid] || ((sectionId && sectionMap && sectionMap[sectionId]) ? (sectionMap[sectionId].title || sectionMap[sectionId].name || sectionMap[sectionId].sectionName || String(sectionMap[sectionId])) : (sectionId || ''));
    rows.push([
      uid,
      firstname,
      lastname,
      sectionName,
      totalAttempts,
      (avgScore === '' ? '' : Math.round(Number(avgScore) * 100)/100),
      lastScore,
      lastDate
    ]);
  }
  // convert to CSV string
  const csvContent = rows.map(r => r.map(cell => '"' + String(cell).replace(/"/g,'""') + '"').join(',')).join('\n');
  // add UTF-8 BOM so Excel on Windows recognizes encoding
  const bom = '\uFEFF';
  const blob = new Blob([bom + csvContent], { type: 'text/csv;charset=utf-8;' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  const ts = new Date().toISOString().replace(/[:\.]/g,'-');
  a.href = url; a.download = `students_${ts}.csv`; document.body.appendChild(a); a.click(); a.remove();
  setTimeout(()=> URL.revokeObjectURL(url), 5000);
}

// wire export button
document.addEventListener('click', (e)=>{
  const btn = e.target.closest && e.target.closest('#exportStudentsBtn');
  if(!btn) return;
  exportStudentsCsv().catch(err=>{ console.error('exportStudentsCsv failed', err); alert('Export failed: '+ (err && err.message?err.message:err)); });
});

// Sections modal handlers
let sectionsCache = {};
document.addEventListener('click', (e)=>{
  const b = e.target.closest && e.target.closest('#viewSectionsBtn');
  if(!b) return;
  openSectionsModal();
});
document.getElementById('closeSectionsModal')?.addEventListener('click', closeSectionsModal);
document.getElementById('closeSectionsModalBtn')?.addEventListener('click', closeSectionsModal);

async function openSectionsModal(){
  const modal = document.getElementById('sectionsModal');
  const content = document.getElementById('sectionsModalContent');
  if(!modal || !content) return;
  content.innerHTML = '<p>Loading sections...</p>';
  try{
    const snap = await rtdb.ref('SectionList').get();
    if(!snap.exists()){ content.innerHTML = '<p>No SectionList found.</p>'; }
    else{
      const sections = snap.val();
      // cache for lookups (sectionId -> sectionObject)
      sectionsCache = sections || {};
      const keys = Object.keys(sections || {});
      if(keys.length===0){ content.innerHTML = '<p>No sections available.</p>'; }
      else{
        let html = '';
        for(const sid of keys){
          const s = sections[sid] || {};
          const name = s.name || s.title || sid;
          const students = s.students || {};
          const uids = Object.keys(students || {});
          html += `<div style="border:1px solid #eee;padding:10px;border-radius:8px;margin-bottom:8px;">
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px;"><div><strong>${escapeHtml(name)}</strong></div><div><button class="view-section-answers-btn" data-section-id="${escapeHtml(sid)}">View Section Answers</button></div></div>`;
          if(uids.length===0) html += `<div style="color:#666">No students</div>`;
          else{
            html += `<div style="display:flex;flex-direction:column;gap:6px;">`;
            for(const uid of uids){
              html += `<div style=\"display:flex;justify-content:space-between;align-items:center;gap:8px;\">
                <div><button class=\"answers-btn\" data-section-uid=\"${escapeHtml(sid+'|'+uid)}\">View</button> <strong>${escapeHtml(uid)}</strong></div>
                <div style=\"color:#666\">${escapeHtml(students[uid]===true?'-':String(students[uid]))}</div>
              </div>`;
            }
            html += `</div>`;
          }
          html += `</div>`;
        }
        content.innerHTML = html;
      }
    }
  }catch(err){ console.error('openSectionsModal failed', err); content.innerHTML = '<pre>'+escapeHtml(err && err.message?err.message:String(err))+'</pre>'; }
  // show modal (reuse styles used elsewhere)
  modal.style.display='flex';
  // append to body in case of CSS specificity hiding
  if(!modal.parentNode || modal.parentNode !== document.body) document.body.appendChild(modal);
  modal.style.setProperty('position','fixed','important'); modal.style.setProperty('z-index','2147483646','important');
}

function closeSectionsModal(){ const modal = document.getElementById('sectionsModal'); if(modal) modal.style.display='none'; }

// delegated click handler inside sections modal: when a 'View' button is clicked show student details
document.addEventListener('click', async (e)=>{
  const btn = e.target.closest && e.target.closest('[data-section-uid]');
  if(!btn) return;
  const v = btn.getAttribute('data-section-uid');
  if(!v) return;
  const [sectionId, uid] = v.split('|');
  const content = document.getElementById('sectionsModalContent');
  if(!content) return;
  content.innerHTML = `<p>Loading student ${escapeHtml(uid)}...</p>`;
  try{
    const accSnap = await rtdb.ref('StudentAccount/'+uid).get();
    const credSnap = await rtdb.ref('Cridentials/'+uid).get();
    const acc = accSnap.exists() ? accSnap.val() : null;
    const cred = credSnap.exists() ? credSnap.val() : null;
    let html = `<div style="padding:8px;max-width:820px;">
      <h3>${escapeHtml(uid)}</h3>
      <table style=\"width:100%;border-collapse:collapse;\">`;
    const fields = {};
    if(acc) Object.assign(fields, acc);
    if(cred) Object.assign(fields, cred);
    fields.sectionId = fields.sectionId || sectionId;
    // resolve sectionId to friendly name if available
    try{
      if(fields.sectionId && sectionsCache && sectionsCache[fields.sectionId]){
        fields.section = sectionsCache[fields.sectionId].name || sectionsCache[fields.sectionId].title || fields.sectionId;
      } else {
        fields.section = fields.section || fields.sectionId || '';
      }
    }catch(e){ fields.section = fields.section || fields.sectionId || ''; }
    for(const k of Object.keys(fields)){
      // hide raw sectionId now that we provide 'section'
      if(k === 'sectionId') continue;
      // hide sensitive fields
      if(['pass','password','sessionToken'].includes(k)) continue;
      html += `<tr><td style=\"padding:6px;border:1px solid #eee;width:30%;font-weight:600;\">${escapeHtml(k)}</td><td style=\"padding:6px;border:1px solid #eee;\">${escapeHtml(String(fields[k]===undefined? '': fields[k]))}</td></tr>`;
    }
  html += `</table></div>`;
    content.innerHTML = html;
  }catch(err){ console.error('failed loading student', err); content.innerHTML = '<pre>'+escapeHtml(err && err.message?err.message:String(err))+'</pre>'; }
});

let editingQuestionId = null;
let currentChapter = null;

const chapterTitles = {
  chapter1:"Chapter 1: Midnight Hideout ", chapter2:"Chapter 2: Whispering Shelves", chapter3:"Chapter 3: Shattered Glass",
  chapter4:"Chapter 4: Silent Halls", chapter5:"Chapter 5: Echoes of Lunch", chapter6:"Chapter 6: Rooftop Rush",
  chapter7:"Chapter 7: Creaking Scaffold", chapter8:"Chapter 8: Flickering Screens", chapter9:"Chapter 9: Whispering Papers",
  chapter10:"Chapter 10: Creeping Silence", chapter11:"Chapter 11: Locked Secrets", chapter12:"Chapter 12: Freedom’s Edge"
};

// Build chapters UI
const container = document.getElementById('chaptersContainer');
Object.keys(chapterTitles).forEach(ch => {
  const header = document.createElement('div');
  header.className = 'data-header';
  header.dataset.chapter = ch;
  header.innerHTML = `<h3>${chapterTitles[ch]}</h3><i class="fa-solid fa-chevron-right"></i>`;
  const body = document.createElement('div');
  body.className = 'chapter-body';
  body.id = 'body-'+ch;
  body.innerHTML = `
    <div class="tabs">
      <div class="tab active" data-tab="questions">Question Management</div>
      <div class="tab" data-tab="progress">Student Progress</div>
    </div>
    <div id="questions-tab-${ch}"></div>
    <div id="progress-tab-${ch}" style="display:none;"></div>
  `;
  container.appendChild(header);
  container.appendChild(body);

  header.addEventListener('click', () => {
    const open = header.classList.contains('open');
    document.querySelectorAll('.data-header').forEach(h=>h.classList.remove('open'));
    document.querySelectorAll('.chapter-body').forEach(b=>b.style.display='none');
    if(!open){ header.classList.add('open'); body.style.display='block'; loadChapterQuestions(ch); }
  });
});

// Tabs
document.addEventListener('click', e=>{
  if(e.target.classList.contains('tab')){
    const tab=e.target, ch=tab.closest('.chapter-body').id.replace('body-','');
    tab.parentNode.querySelectorAll('.tab').forEach(t=>t.classList.remove('active'));
    tab.classList.add('active');
    document.getElementById(`questions-tab-${ch}`).style.display=tab.dataset.tab==='questions'?'block':'none';
    document.getElementById(`progress-tab-${ch}`).style.display=tab.dataset.tab==='progress'?'block':'none';
    if(tab.dataset.tab==='progress'){ subscribeStudentProgress(ch); }
  }
});

// Get next sequential question index
async function getNextQuestionIndex(ch){
  try{
    const qFound = await findQuizQuestions(ch);
    if(!qFound || !qFound.snap || !qFound.snap.exists()) return 1;
    const snap = qFound.snap;
    const indexes = [];
    snap.forEach(child=>indexes.push(parseInt(child.key)));
    return Math.max(...indexes)+1;
  }catch(e){ console.debug('getNextQuestionIndex failed', e); return 1; }
}

// Load questions
async function loadChapterQuestions(ch){
  currentChapter = ch;
  const container = document.getElementById(`questions-tab-${ch}`);
  container.innerHTML = `<button class="add-question-btn" onclick="openQuestionModal('${ch}')"><i class="fas fa-plus"></i> Add Question</button><div id="questions-list-${ch}">Loading...</div>`;
  const list = document.getElementById(`questions-list-${ch}`);
  // try to load questions from any variant of the chapter key
  const qFound = await findQuizQuestions(ch);
  if(!qFound || !qFound.snap || !qFound.snap.exists()){ list.innerHTML="<p>No questions yet</p>"; return; }
  list.innerHTML = "";
    qFound.snap.forEach(child=>{
    const q = child.val(), id = child.key;
    let optionsHtml="";
    if(q.type==="multiple_choice"){
      // respect randomizeOptions: when randomizing, we must still mark correct answer
      const choices = Array.isArray(q.choices) ? q.choices.slice() : [];
      let displayChoices = choices.slice();
      if(q.randomizeOptions){ displayChoices = shuffle(displayChoices); }
      displayChoices.forEach(opt=>{
        const correct = (q.orderMatters) ? (q.answer===opt) : (q.answer===opt);
        optionsHtml += `<div class="question-option ${correct?'correct-answer':''}">${opt}</div>`;
      });
      optionsHtml += `<p style="font-size:12px;color:#666;margin-top:6px">Case sensitive: ${q.caseSensitive? 'Yes':'No'} &nbsp; | &nbsp; Order matters: ${q.orderMatters? 'Yes':'No'} &nbsp; | &nbsp; Randomize: ${q.randomizeOptions? 'Yes':'No'}</p>`;
    } else {
      optionsHtml = `<div class="question-option"><b>Answer:</b> ${q.answer}</div>`;
    }
    list.innerHTML += `
      <div class="question-item">
        <div class="question-text">[${q.questionIndex}] ${q.question}</div>
        <div class="question-options">${optionsHtml}</div>
        <p><b>Show Answer:</b> ${q.showAnswer}</p>
        <div class="question-actions">
          <button class="edit-btn" onclick="openEditModal('${ch}','${id}')">Edit</button>
          <button class="delete-btn" onclick="deleteQuestion('${ch}','${id}')">Delete</button>
        </div>
      </div>`;
  });
}

// --- Preview / Evaluation helper (instructor testing) ---
// Render a simple preview box at the bottom of the questions list for the current chapter
function renderPreviewBox(ch){
  const container = document.getElementById(`questions-tab-${ch}`);
  // append preview area if not present
  if(!document.getElementById('previewArea')){
    const preview = document.createElement('div');
    preview.id = 'previewArea';
    preview.style.marginTop = '12px';
    preview.innerHTML = `<div style="padding:12px;border-radius:8px;background:#fff;border:1px solid #eee;"><h4>Preview / Test</h4><div id='previewContent'>Select a question from the list to preview it here (click Edit then Close to return)</div></div>`;
    container.appendChild(preview);
  }
}

// Evaluate answer against a question object q and a provided response
// For multiple_choice: response can be the option text (string) or array of strings if multiple answers expected
function evaluateAnswer(q, response){
  if(!q) return false;
  if(q.type === 'multiple_choice'){
    // For MCQs, normalize both the stored student response and the question's answer(s)
    // to handle legacy formats: letter prefixes ("A.", "B)"), numeric indices (0/1-based),
    // and braced lists.
    const caseSensitive = !!q.caseSensitive;
    const normalize = v => caseSensitive ? String(v).trim() : String(v).toLowerCase().trim();

    // Use normalizeStudentResponse to map numeric indices and strip prefixes when possible
    const respNorm = normalizeStudentResponse(q, response);
    const ansNorm = normalizeStudentResponse(q, q.answer);

    const toArray = x => Array.isArray(x) ? x : (x === undefined || x === null ? [] : [x]);
    const rArr = toArray(respNorm).map(x => normalize(x));
    const aArr = toArray(ansNorm).map(x => normalize(x));

    if(q.orderMatters){
      if(rArr.length !== aArr.length) return false;
      for(let i=0;i<rArr.length;i++) if(rArr[i] !== aArr[i]) return false;
      return true;
    } else {
      // compare as sets (order-insensitive)
      rArr.sort(); aArr.sort();
      return JSON.stringify(rArr) === JSON.stringify(aArr);
    }
  } else if(q.type === 'identification'){
    const caseSensitive = !!q.caseSensitive;
    const normalize = v => caseSensitive ? v.trim() : String(v).toLowerCase().trim();
    // orderMatters for identification could imply exact match on tokens order; default exact
    return normalize(response) === normalize(q.answer);
  } else if(q.type === 'true_false'){
    return String(response).toLowerCase() === String(q.answer).toLowerCase();
  }
  return false;
}

// Shuffle helper
function shuffle(array){
  for(let i = array.length -1; i>0; i--){
    const j = Math.floor(Math.random()*(i+1));
    [array[i], array[j]] = [array[j], array[i]];
  }
  return array;
}

// Map stored student response (possibly numeric index or array of indices) to choice text(s)
function normalizeStudentResponse(q, studentResp){
  if(!q) return studentResp;
  // If no choices available, return original
  const choices = Array.isArray(q.choices) ? q.choices : (q.choices ? Object.values(q.choices) : []);
  // If no choices are defined (identification or TF), just return trimmed/raw student value
  if(!choices || choices.length===0){
    if(Array.isArray(studentResp)) return studentResp.map(x=> (x===null||x===undefined)?x:String(x).trim());
    return (studentResp===null||studentResp===undefined)?studentResp:String(studentResp).trim();
  }
  // helper to map one value
  const mapOne = (v) => {
    if(v === null || v === undefined) return undefined;
    if(typeof v === 'number'){
      // try 0-based first, then 1-based
      const try0 = choices[v] !== undefined ? choices[v] : undefined;
      if(try0 !== undefined) return try0;
      const try1 = choices[v-1] !== undefined ? choices[v-1] : undefined;
      return try1;
    }
    let s = String(v).trim();
    if(s === '') return undefined;
    const lower = s.toLowerCase();
    // treat common placeholders as no-response
    if(['-','null','n/a','no response','none','na','invalid choice','.','invalid','(no response)'].indexOf(lower) !== -1) return undefined;

    // strip common choice prefixes like 'A. ', 'A) ', '1. ' (be generous: allow letters A-Z and lower/upper)
    let stripped = s.replace(/^[A-Za-z]\s*[\.\)]\s*/,'').replace(/^\d+\.\s*/,'').trim();
    if(stripped === '') return undefined;

    // Helper to find the canonical choice text from choices array that matches a candidate
    const findChoiceMatch = (candidate) => {
      const candNorm = String(candidate).toLowerCase().trim();
      for(const opt of choices){
        const optNorm = String(opt).toLowerCase().trim();
        if(optNorm === candNorm) return opt; // exact match
        // strip prefix from option and compare
        const optStripped = String(opt).replace(/^[A-Za-z]\s*[\.\)]\s*/,'').replace(/^\d+\.\s*/,'').trim();
        if(String(optStripped).toLowerCase().trim() === candNorm) return opt;
      }
      return null;
    };

    // If the stripped value exactly matches a defined choice (or matches after stripping prefixes), return the canonical choice
    const matchedChoice = findChoiceMatch(stripped);
    if(matchedChoice) return matchedChoice;
    const matchedChoiceRaw = findChoiceMatch(s);
    if(matchedChoiceRaw) return matchedChoiceRaw;

    // Handle set-like values: {a, b, c} or 'a, b, c'
    const isBraced = /^\{.*\}$/.test(stripped);
    if(isBraced || stripped.indexOf(',') !== -1){
      const inner = (isBraced ? stripped.slice(1, -1) : stripped).split(',').map(x=>String(x).trim()).filter(x=>x);
      if(inner.length === 0) return undefined;
      // If individual items match choices, return an array of matched choices
      const mappedItems = inner.map(item => {
        if(choices.indexOf(item) !== -1) return item;
        // try stripping prefixes from item
        const it = item.replace(/^[A-Da-d]\s*[\.|\)]\s*/,'').replace(/^\d+\.\s*/,'').trim();
        if(choices.indexOf(it) !== -1) return it;
        return item;
      });
      return mappedItems;
    }

    // numeric string -> index mapping (after stripping): try 0-based then 1-based
    if(!isNaN(Number(stripped))){
      const n = Number(stripped);
      if(choices[n] !== undefined) return choices[n];
      if(choices[n-1] !== undefined) return choices[n-1];
    }

    // fallback: return the stripped text
    return stripped;
  };

  if(Array.isArray(studentResp)){
    const mapped = studentResp.map(mapOne).filter(x=> x !== undefined && x !== null && String(x).trim() !== '');
    return mapped.length ? mapped : [];
  }
  return mapOne(studentResp);
}

// Robust extractor: get student response for a question key/index from various attempt shapes
function extractStudentResponse(attemptObj, qk, qIndex){
  if(!attemptObj) return undefined;
  // common shapes
  if(attemptObj.answers && attemptObj.answers[qk] !== undefined) return attemptObj.answers[qk];
  if(attemptObj.answers && attemptObj.answers['q'+qk] !== undefined) return attemptObj.answers['q'+qk];
  if(attemptObj.answers && attemptObj.answers['Q'+qk] !== undefined) return attemptObj.answers['Q'+qk];
  if(attemptObj.answers && attemptObj.answers[qIndex] !== undefined) return attemptObj.answers[qIndex];
  if(attemptObj.answers && attemptObj.answers['q'+qIndex] !== undefined) return attemptObj.answers['q'+qIndex];
  if(attemptObj.answers && attemptObj.answers['Q'+qIndex] !== undefined) return attemptObj.answers['Q'+qIndex];
  if(attemptObj.responses && attemptObj.responses[qk] !== undefined) return attemptObj.responses[qk];
  if(Array.isArray(attemptObj.responses) && attemptObj.responses.length >= qIndex) return attemptObj.responses[qIndex-1];
  if(attemptObj.responsesArray && Array.isArray(attemptObj.responsesArray) && attemptObj.responsesArray.length >= qIndex) return attemptObj.responsesArray[qIndex-1];
  if(attemptObj[qk] !== undefined) return attemptObj[qk];
  if(attemptObj['q'+qk] !== undefined) return attemptObj['q'+qk];
  if(attemptObj['Q'+qk] !== undefined) return attemptObj['Q'+qk];
  if(attemptObj['q'+qk] !== undefined) return attemptObj['q'+qk];
  if(attemptObj[String(qk)] !== undefined) return attemptObj[String(qk)];
  // some QuizResults store answers under a top-level 'answers' object with numeric keys as strings
  if(attemptObj.answers && typeof attemptObj.answers === 'object'){
    if(attemptObj.answers[String(qIndex)] !== undefined) return attemptObj.answers[String(qIndex)];
    // try to find keys like 'Q1', 'q1', or any key whose numeric part equals qIndex (robust matching)
    for(const k of Object.keys(attemptObj.answers)){
      if(!k) continue;
      const num = k.replace(/\D/g,'');
      if(num === String(qIndex)) return attemptObj.answers[k];
    }
  }
  return undefined;
}

// Fetch student name
async function getStudentName(sid){
  const snap = await rtdb.ref("StudentAccount/"+sid).get();
  if(!snap.exists()) return sid;
  const acc = snap.val();
  // prefer canonical camelCase keys, fallback to older lowercase ones
  const fn = acc.firstName || acc.firstname || acc.name || '';
  const ln = acc.lastName || acc.lastname || '';
  const full = (fn + ' ' + ln).trim();
  return full || sid;
}

// Subscribe to student progress (real-time)
function subscribeStudentProgress(ch){
  const container=document.getElementById(`progress-tab-${ch}`);
  container.innerHTML="<p>Loading...</p>";

  rtdb.ref().on("value", async snapshot=>{
    const allData = snapshot.val() || {};
  const quizResults = allData.QuizResults || {};

    // Collect attempts per student: { sid: [ {score, date, timeSpent, source, attemptIndex}, ... ] }
    const attemptsByStudent = {};

    // Helper to push attempt
    function pushAttempt(sid, attempt){
      if(!attemptsByStudent[sid]) attemptsByStudent[sid] = [];
      attemptsByStudent[sid].push(attempt);
    }

    // QuizResults (structure: QuizResults[sid][chapter][attemptKey] = {score,date,timeSpent})
    for(const sid in quizResults){
      if(!quizResults[sid] || !quizResults[sid][ch]) continue;
      const chapterEntries = quizResults[sid][ch];
      const keys = Object.keys(chapterEntries).sort();
      keys.forEach((key, idx) => {
        const res = chapterEntries[key] || {};
        // store the real attempt key so we can fetch the exact child later
        pushAttempt(sid, { score: res.score || 0, date: res.date || '', timeSpent: res.timeSpent || 0, source: 'QuizResults', attemptKey: key, displayIndex: idx+1 });
      });
    }

    // Note: StudentsProgress is legacy; prefer QuizResults which stores per-attempt answers.

    // Build HTML: per-student collapsible card with attempts table
    let html = '';
    const sids = Object.keys(attemptsByStudent).sort();
    for(const sid of sids){
      const studentName = await getStudentName(sid);
      const attempts = attemptsByStudent[sid] || [];
      // sort attempts by attemptIndex (already ordered) or date
      attempts.sort((a,b)=> (a.attemptIndex||0) - (b.attemptIndex||0));

      // build attempts table rows
      let attemptsRows = '';
    attempts.forEach(a => {
        const displayLabel = a.displayIndex ? a.displayIndex : (a.attemptKey || '1');
        const attemptKeyEsc = a.attemptKey ? a.attemptKey : String(a.displayIndex || '1');
          attemptsRows += `<tr><td>${escapeHtml(displayLabel)}</td><td>${a.score}</td><td>${escapeHtml(a.date)}</td><td>${escapeHtml(a.timeSpent)} mins</td><td>${escapeHtml(a.source)}</td><td><button class="view-btn" data-view-attempt="${sid}|${ch}|${attemptKeyEsc}"><span class="ico"><i class="fas fa-eye"></i></span> View</button> <button class="answers-btn" data-inline-answers="${sid}|${ch}|${attemptKeyEsc}"><span class="ico"><i class="fas fa-file-lines"></i></span> Answers</button></td></tr>`;
      });

      html += `
        <div class="data-header progress-header" data-sid="${sid}" style="display:flex;justify-content:space-between;align-items:center;cursor:pointer;">
          <div><strong>${studentName}</strong> <span style="color:#666;margin-left:8px;">(${sid})</span></div>
          <div style="color:#666">Attempts: ${attempts.length}</div>
        </div>
        <div class="chapter-body attempts-body" style="display:none; padding:10px 14px; margin-bottom:12px;">
          <table class='progress-table'>
            <thead><tr><th>Attempt #</th><th>Score</th><th>Date</th><th>Time Spent</th><th>Source</th></tr></thead>
            <tbody>
              ${attemptsRows}
            </tbody>
          </table>
        </div>
      `;
    }

    if(!sids.length) html = '<p>No attempts found.</p>';
    container.innerHTML = html;

    // Attach click handlers to toggle attempts
    document.querySelectorAll('.progress-header').forEach(h => {
      h.addEventListener('click', ()=>{
        const next = h.nextElementSibling;
        if(!next) return;
        const isOpen = next.style.display && next.style.display !== 'none';
        next.style.display = isOpen ? 'none' : 'block';
      });
    });
  });
}

// View attempt details handler (delegated)
document.addEventListener('click', async (e)=>{
  const btn = e.target.closest && e.target.closest('[data-view-attempt]');
  if(!btn) return;
  const val = btn.getAttribute('data-view-attempt'); // sid|chapter|attemptIndex
  const [sid, ch, attemptIndex] = val.split('|');
  // fetch attempt object from QuizResults (answers stored under QuizResults/{sid}/{chapter})
  try{
    // attemptIndex is actually the attemptKey (random push id) or numeric index; use fetchAttemptObject which tries exact keys first
    const attemptKey = attemptIndex;
    const fetched = await fetchAttemptObject(sid, ch, attemptKey);
    let attemptObj = fetched && fetched.obj ? fetched.obj : null;
    let source = fetched && fetched.source ? fetched.source : 'unknown';
    if(!attemptObj){
  const fallbackHtml = `<div style="max-height:60vh;overflow:auto"><h3>No stored answers found</h3><p>There is no per-attempt record for this attempt and no chapter-level answers were found in the database for this student/chapter.</p><p>Check that the student's attempts were saved under <code>QuizResults/${sid}/${ch}</code>.</p></div>`;
      showAttemptModal(fallbackHtml);
      return;
    }

    // Load chapter quiz questions to compare answers (try variants)
    let questions = {};
    try{
      const qFound = await findQuizQuestions(ch);
      if(qFound && qFound.snap && qFound.snap.exists()){ questions = qFound.snap.val(); console.debug('Loaded questions from', qFound.path); }
      else { const fallbackSnap = await rtdb.ref(`quizzes/${ch}/questions`).get(); if(fallbackSnap && fallbackSnap.exists()) questions = fallbackSnap.val(); }
    }catch(e){ console.debug('Failed to load questions for', ch, e); }

    // Build modal content: iterate questions in numeric order by questionIndex
    const qKeys = Object.keys(questions || {}).sort((a,b)=> Number(a) - Number(b));
    let html = `<div style="max-height:60vh;overflow:auto">`;
    html += `<h3>Attempt ${escapeHtml(attemptIndex)} — Student ${escapeHtml(sid)} — Source: ${escapeHtml(source)}</h3>`;

    if(qKeys.length===0){ html += `<p>No question definitions found for this chapter.</p>`; }
    else {
      qKeys.forEach(qk => {
        const q = questions[qk];
        // Determine student's response for this question from attemptObj
        // Attempt shapes vary: could be {answers: {qIndex: value}} or {responses: [...] } or flat fields. We'll try several heuristics.
  // extract student response using helper (qk is key, qIndex = numeric index)
  const qIndex = Number(qk);
  let studentResp = extractStudentResponse(attemptObj, qk, qIndex);
  // normalize stored responses (map numeric indices to choice text) so evaluation compares like-with-like
  const normResp = normalizeStudentResponse(q, studentResp);

  // evaluate correctness using evaluateAnswer (use normalized response)
  const correct = evaluateAnswer(q, normResp);
  // detect explicit no-response (undefined/null/empty string/empty array)
  const isNoResponse = (normResp === undefined || normResp === null || (Array.isArray(normResp) && normResp.length===0) || (typeof normResp === 'string' && String(normResp).trim()===''));
  // result state: 'Correct', 'Incorrect' or 'No response' (no-response should not be shown as wrong)
  let cls = 'question-result';
  let resultText = '';
  let resultColor = '#d33';
  if(isNoResponse){ resultText = 'No response'; cls = 'question-result'; resultColor = '#666'; }
  else if(correct){ resultText = 'Correct'; cls = 'question-result correct'; resultColor = '#2b8a3e'; }
  else { resultText = 'Incorrect'; cls = 'question-result wrong'; resultColor = '#d33'; }
        html += `<div class="${cls}" style="padding:10px;border-bottom:1px solid #eee;margin-bottom:8px;">
          <div style="display:flex;justify-content:space-between;align-items:center"><div style="font-weight:700;color:#501121">Q${escapeHtml(q.questionIndex || qk)}: ${escapeHtml(q.question||'')}</div><div style="font-size:12px;color:#666">${escapeHtml(q.type||'')}</div></div>`;

        if(q.type === 'multiple_choice'){
          // render choices and highlight correct and student selection
          const choices = Array.isArray(q.choices) ? q.choices : (q.choices ? Object.values(q.choices) : []);
          const correctOptions = Array.isArray(q.answer) ? q.answer : (q.answer !== undefined ? [q.answer] : []);
          // map correct options to display text (handle numeric indices and prefixes)
          const correctOptionsText = correctOptions.map(co=>{
            if(co === undefined || co === null) return String(co);
            if(!isNaN(Number(co))){ const n=Number(co); const idx=(n===0?0:n-1); return choices[idx] !== undefined ? choices[idx] : String(co); }
            const sCo = String(co).trim().replace(/^[A-Da-d]\s*[\.|\)]\s*/,'').replace(/^\d+\.\s*/,'').trim();
            return sCo;
          });

          // student selections normalized to array for easy checks
          let studentSelections = [];
          if(Array.isArray(normResp)) studentSelections = normResp.slice();
          else if(normResp !== undefined && normResp !== null && String(normResp).trim() !== '') studentSelections = [String(normResp)];

          // comparison helper honoring case sensitivity
          const cmp = (a,b) => {
            if(a === undefined || b === undefined) return false;
            if(q.caseSensitive) return String(a).trim() === String(b).trim();
            return String(a).toLowerCase().trim() === String(b).toLowerCase().trim();
          };

          html += `<div style="margin-top:8px;display:flex;flex-direction:column;">`;
          let anySelected = false;
          choices.forEach((opt, idx)=>{
            // is this option one of the correct options by value
            const isCorrectOpt = correctOptionsText.some(co => cmp(opt, co));
            // determine if student selected this option
            const isSelected = studentSelections.some(sel => cmp(sel, opt) || cmp(sel, String(idx)) || cmp(sel, String(idx+1)));
            if(isSelected) anySelected = true;
            const chCls = `choice ${isCorrectOpt ? 'correct-choice':''} ${isSelected ? 'student-choice':''}`;
            const tags = [];
            if(isCorrectOpt) tags.push('<span class="tag correct">Correct</span>');
            if(isSelected) tags.push('<span class="tag selected">Selected</span>');
            html += `<div class="${chCls}"><div>${escapeHtml(opt)}</div><div>${tags.join(' ')}</div></div>`;
          });
          html += `</div>`;
          // if student provided a response but it didn't match any choice, show that explicitly
          if(!anySelected && studentSelections.length>0){
            const rawDisplay = Array.isArray(studentResp) ? studentResp.join(', ') : String(studentResp);
            html += `<div style="margin-top:6px;color:#a23">Student answered (not in choices): <span style="font-weight:600">${escapeHtml(rawDisplay)}</span></div>`;
          }
          // if student didn't select anything, show explicit no response
          if(!anySelected){ html += `<div style="margin-top:6px;font-style:italic;color:#666">Student answer: <span style="font-weight:600">(no response)</span></div>`; }
          // show raw stored response and normalized mapping for instructor clarity
          try{
            const rawDisplay = (studentResp === undefined || studentResp === null || (Array.isArray(studentResp) && studentResp.length===0) || (typeof studentResp === 'string' && String(studentResp).trim()==='')) ? '(no response)' : (Array.isArray(studentResp) ? studentResp.join(', ') : String(studentResp));
            const normDisplay = (normResp === undefined || normResp === null || (Array.isArray(normResp) && normResp.length===0) || (typeof normResp === 'string' && String(normResp).trim()==='')) ? '(no response)' : (Array.isArray(normResp) ? normResp.join(', ') : String(normResp));
            html += `<div style="margin-top:6px;color:#444">Student response (raw): <span style="font-weight:600">${escapeHtml(rawDisplay)}</span></div>`;
            html += `<div style="margin-top:4px;color:#444">Normalized: <span style="font-weight:600">${escapeHtml(normDisplay)}</span></div>`;
          }catch(e){ /* ignore display errors */ }
          // if student is incorrect, show which option(s) are correct
          if(!correct && correctOptions.length){
            const mappedCorrect = correctOptionsText.join(', ');
            html += `<div style="margin-top:8px;">Correct answer: <span style="font-weight:700">${escapeHtml(mappedCorrect)}</span></div>`;
          }
          html += `<div style="margin-top:8px;">Result: <span style="font-weight:700;color:${resultColor}">${escapeHtml(resultText)}</span></div>`;
        } else {
          html += `<div style="margin-top:6px;">Expected: <span style='font-weight:600'>${escapeHtml(String(q.answer===undefined?JSON.stringify(q.choices||''): q.answer))}</span></div>`;
          html += `<div style="margin-top:6px;">Student answer: <span style='font-weight:600'>${escapeHtml(String(studentResp===undefined?'(no response)': studentResp))}</span></div>`;
          html += `<div style="margin-top:6px;color:${resultColor};font-weight:700">${escapeHtml(resultText)}</div>`;
        }
        html += `</div>`;
      });
    }
    html += `</div>`;

    // show custom modal (reuse simple modal pattern)
    showAttemptModal(html);
  }catch(err){ console.error(err); alert('Error loading attempt details: '+ (err && err.message ? err.message : err)); }
});

// Helper: fetch an attempt object with fallbacks (per-attempt nodes, chapter-level nodes)
async function fetchAttemptObject(sid, ch, attemptIndex){
  console.debug('fetchAttemptObject()', { sid, ch, attemptIndex });
  // attemptIndex may actually be a push-key (random id) or a numeric index. Try exact key paths first.
  // Prefer QuizResults exact path first (you store answers there)
  const qrExactFound = await findFirstChapterSnapshot('QuizResults', sid, ch);
  if(qrExactFound){
    const qrSnapExact = await rtdb.ref(`${qrExactFound.path}/${attemptIndex}`).get();
    console.debug('checked QuizResults exact (variant)', `${qrExactFound.path}/${attemptIndex}`, 'exists=', qrSnapExact.exists());
    if(qrSnapExact.exists()) return { obj: qrSnapExact.val(), source: `${qrExactFound.path}/${attemptIndex}` };
  }
  // legacy StudentsProgress exact path removed - relying on QuizResults only

  // If not found by exact key, fall back to previous numeric-index logic (attemptIndex may be numeric)
  // try numeric-index paths using chapter variants - prefer QuizResults then StudentsProgress
  const qrVariant = await findFirstChapterSnapshot('QuizResults', sid, ch);
  if(qrVariant){
    try{ const qrSnap = await rtdb.ref(`${qrVariant.path}/${attemptIndex}`).get(); console.debug('checked QuizResults numeric (variant)', `${qrVariant.path}/${attemptIndex}`, 'exists=', qrSnap.exists()); if(qrSnap.exists()) return { obj: qrSnap.val(), source: `${qrVariant.path}/${attemptIndex}` }; }catch(e){ console.debug('QuizResults numeric check failed', e); }
  }
  // StudentsProgress numeric variant checks removed - relying on QuizResults only

  // try chapter-level QuizResults (prefer this: answers are stored here)
  const chapterQrFound = await findFirstChapterSnapshot('QuizResults', sid, ch);
  if(chapterQrFound){
    try{
      const chapterQrSnap = chapterQrFound.snap;
      const chapterQrPath = chapterQrFound.path;
      const chVal = chapterQrSnap.val(); const chKeys = Object.keys(chVal||{});
      console.debug('checked', chapterQrPath, 'exists=', chapterQrSnap.exists(), 'keys=', chKeys.slice(0,5));
      if(chVal && (chVal.answers || chVal.responses || chKeys.some(k=>isNaN(Number(k))))) return { obj: chVal, source: chapterQrPath };
      if(chKeys.length) return { obj: chVal[chKeys[0]], source: `${chapterQrPath}:${chKeys[0]}` };
    }catch(e){ console.debug('chapter-level QuizResults check failed', e); }
  }

  // StudentsProgress chapter-level fallback removed - relying on QuizResults only
  return null;
}

// Helper: generate likely chapter key variants to tolerate DB naming differences
function chapterVariants(ch){
  const out = new Set();
  if(!ch) return [];
  const raw = String(ch).trim();
  out.add(raw);
  out.add(raw.toLowerCase());
  out.add(raw.replace(/\s+/g, ''));
  // split alpha+digits like 'chapter1' -> 'chapter 1'
  const m = raw.match(/^([a-zA-Z]+)(\d+)$/);
  if(m){ out.add(`${m[1]} ${m[2]}`); out.add(`${m[1].toLowerCase()} ${m[2]}`); out.add(`${m[1].charAt(0).toUpperCase() + m[1].slice(1).toLowerCase()} ${m[2]}`); }
  // if it's like 'chapter 1', also add no-space variant
  const m2 = raw.match(/^([a-zA-Z]+)\s+(\d+)$/);
  if(m2){ out.add(`${m2[1]}${m2[2]}`); out.add(`${m2[1].toLowerCase()}${m2[2]}`); }
  // explicit chapter forms for numeric chapters
  const digits = raw.match(/(\d+)/);
  if(digits){ const d = digits[0]; out.add(`chapter${d}`); out.add(`chapter ${d}`); out.add(`Chapter ${d}`); out.add(`Chapter${d}`); out.add(d); }
  // add hyphen/underscore and zero-padded variants and short forms (ch)
  if(digits){
    const d = digits[0];
    const pad2 = d.length === 1 ? `0${d}` : d;
    out.add(`chapter-${d}`);
    out.add(`chapter_${d}`);
    out.add(`chapter${pad2}`);
    out.add(`chapter-${pad2}`);
    out.add(`chapter_${pad2}`);
    out.add(`CHAPTER${d}`);
    out.add(`CHAPTER ${d}`);
    out.add(`ch${d}`);
    out.add(`ch ${d}`);
    out.add(`Ch${d}`);
  }
  return Array.from(out);
}

// Helper: find the first existing RTDB snapshot for a root path that includes student id and chapter variant
async function findFirstChapterSnapshot(root, sid, ch){
  const variants = chapterVariants(ch);
  for(const v of variants){
    const path = `${root}/${sid}/${v}`;
    try{
      const snap = await rtdb.ref(path).get();
      if(snap && snap.exists()) return { snap, path, variant: v };
    }catch(e){ console.debug('findFirstChapterSnapshot read failed for', path, e); }
  }
  return null;
}

// Helper: find quiz questions node for any chapter variant
async function findQuizQuestions(ch){
  const variants = chapterVariants(ch);
  for(const v of variants){
    const path = `quizzes/${v}/questions`;
    try{
      const snap = await rtdb.ref(path).get();
      if(snap && snap.exists()) return { snap, path, variant: v };
    }catch(e){ console.debug('findQuizQuestions read failed for', path, e); }
  }
  return null;
}

// Helper: find a key in an in-memory map object that matches any chapter variant
function findVariantKeyInMap(obj, ch){
  if(!obj || !ch) return null;
  const variants = chapterVariants(ch) || [];
  // direct check first
  for(const v of variants){ if(Object.prototype.hasOwnProperty.call(obj, v)) return v; }
  // normalized fallback: compare keys after lowercasing and removing spaces
  const normVariants = new Set(variants.map(v=>String(v).trim().toLowerCase().replace(/\s+/g,'')));
  for(const k of Object.keys(obj||{})){
    const nk = String(k).trim().toLowerCase().replace(/\s+/g,'');
    if(normVariants.has(nk)) return k;
  }
  return null;
}

// Return a list of attempts (keys) for a student/chapter with simple labels (date or key)
async function getAttemptList(sid, ch){
  const list = [];
  try{
    // try QuizResults with chapter key variants
    const qrFound = await findFirstChapterSnapshot('QuizResults', sid, ch);
    if(qrFound && qrFound.snap && qrFound.snap.exists()){
      const val = qrFound.snap.val();
      Object.keys(val||{}).forEach(k=>{
        const item = val[k] || {};
        const label = item.date ? `${item.date} (${k.substr(0,6)})` : `${k}`;
        list.push({ key: k, source: `QuizResults (${qrFound.variant})`, date: item.date || '', score: item.score || null, label });
      });
    }
  }catch(e){ console.debug('getAttemptList QuizResults read failed', e); }
  // Note: StudentsProgress removed - relying on QuizResults only
  // Sort by date desc if available, else keep insertion order
  list.sort((a,b)=>{
    if(a.date && b.date) return (a.date < b.date) ? 1 : -1;
    return 0;
  });
  return list;
}

// Render the questions block HTML for an attempt object
function renderAttemptQuestionsHtml(attemptObj, source, questions){
  const qKeys = Object.keys(questions || {}).sort((a,b)=> Number(a) - Number(b));
  let html = `<div style="max-height:60vh;overflow:auto">`;
  html += `<h3>Source: ${escapeHtml(source)}</h3>`;
  // If the attempt object looks like a direct answers map (keys like 'Q1', '1', etc), wrap it so extractor finds it
  let effectiveAttempt = attemptObj || {};
  try{
    if(!attemptObj) effectiveAttempt = {};
    else if(!attemptObj.answers){
      const keys = Object.keys(attemptObj||{});
      const looksLikeAnswers = keys.length > 0 && keys.some(k => /^q?\d+$/i.test(k) || /^Q\d+$/i.test(k) || /^Q\d+$/.test(k));
      if(looksLikeAnswers){ effectiveAttempt = { answers: attemptObj }; }
    }
  }catch(e){ effectiveAttempt = attemptObj; }
  if(qKeys.length===0){ html += `<p>No question definitions found for this chapter.</p>`; }
  else {
    qKeys.forEach(qk => {
      const q = questions[qk];
      const qIndex = Number(qk);
      const studentResp = extractStudentResponse(attemptObj, qk, qIndex);
      const normResp = normalizeStudentResponse(q, studentResp);
      const correct = evaluateAnswer(q, normResp);
      const isNoResponse = (normResp === undefined || normResp === null || (Array.isArray(normResp) && normResp.length===0) || (typeof normResp === 'string' && String(normResp).trim()===''));
      let cls = 'question-result';
      let resultText = '';
      let resultColor = '#d33';
      if(isNoResponse){ resultText = 'No response'; cls = 'question-result'; resultColor = '#666'; }
      else if(correct){ resultText = 'Correct'; cls = 'question-result correct'; resultColor = '#2b8a3e'; }
      else { resultText = 'Incorrect'; cls = 'question-result wrong'; resultColor = '#d33'; }
      html += `<div class="${cls}" style="padding:10px;border-bottom:1px solid #eee;margin-bottom:8px;">`;
      html += `<div style="display:flex;justify-content:space-between;align-items:center"><div style="font-weight:700;color:#501121">Q${escapeHtml(q.questionIndex || qk)}: ${escapeHtml(q.question||'')}</div><div style="font-size:12px;color:#666">${escapeHtml(q.type||'')}</div></div>`;
      if(q.type === 'multiple_choice'){
        const choices = Array.isArray(q.choices) ? q.choices : (q.choices ? Object.values(q.choices) : []);
        const correctOptions = Array.isArray(q.answer) ? q.answer : (q.answer !== undefined ? [q.answer] : []);
        const correctOptionsText = correctOptions.map(co=>{
          if(co === undefined || co === null) return String(co);
          if(!isNaN(Number(co))){ const n=Number(co); const idx=(n===0?0:n-1); return choices[idx] !== undefined ? choices[idx] : String(co); }
          return String(co).trim().replace(/^[A-Za-z]\s*[\.\)]\s*/,'').replace(/^\d+\.\s*/,'').trim();
        });
        let studentSelections = [];
        if(Array.isArray(normResp)) studentSelections = normResp.slice();
        else if(normResp !== undefined && normResp !== null && String(normResp).trim() !== '') studentSelections = [String(normResp)];
        const cmp = (a,b) => { if(a === undefined || b === undefined) return false; if(q.caseSensitive) return String(a).trim() === String(b).trim(); return String(a).toLowerCase().trim() === String(b).toLowerCase().trim(); };
        html += `<div style="margin-top:8px;display:flex;flex-direction:column;">`;
        let anySelected = false;
        choices.forEach((opt, idx)=>{
          const isCorrectOpt = correctOptionsText.some(co => cmp(opt, co));
          const isSelected = studentSelections.some(sel => cmp(sel, opt) || cmp(sel, String(idx)) || cmp(sel, String(idx+1)));
          if(isSelected) anySelected = true;
          const chCls = `choice ${isCorrectOpt ? 'correct-choice':''} ${isSelected ? 'student-choice':''}`;
          const tags = [];
          if(isCorrectOpt) tags.push('<span class="tag correct">Correct</span>');
          if(isSelected) tags.push('<span class="tag selected">Selected</span>');
          html += `<div class="${chCls}"><div>${escapeHtml(opt)}</div><div>${tags.join(' ')}</div></div>`;
        });
        html += `</div>`;
        if(!anySelected && studentSelections.length>0){ const rawDisplay = Array.isArray(studentResp) ? studentResp.join(', ') : String(studentResp); html += `<div style="margin-top:6px;color:#a23">Student answered (not in choices): <span style="font-weight:600">${escapeHtml(rawDisplay)}</span></div>`; }
        try{
          const rawDisplay = (studentResp === undefined || studentResp === null || (Array.isArray(studentResp) && studentResp.length===0) || (typeof studentResp === 'string' && String(studentResp).trim()==='')) ? '(no response)' : (Array.isArray(studentResp) ? studentResp.join(', ') : String(studentResp));
          const normDisplay = (normResp === undefined || normResp === null || (Array.isArray(normResp) && normResp.length===0) || (typeof normResp === 'string' && String(normResp).trim()==='')) ? '(no response)' : (Array.isArray(normResp) ? normResp.join(', ') : String(normResp));
          html += `<div style="margin-top:6px;color:#444">Student response (raw): <span style="font-weight:600">${escapeHtml(rawDisplay)}</span></div>`;
          html += `<div style="margin-top:4px;color:#444">Normalized: <span style="font-weight:600">${escapeHtml(normDisplay)}</span></div>`;
        }catch(e){}
        if(!correct && correctOptions.length && !isNoResponse){ const mappedCorrect = correctOptionsText.join(', '); html += `<div style="margin-top:8px;">Correct answer: <span style="font-weight:700">${escapeHtml(mappedCorrect)}</span></div>`; }
        html += `<div style="margin-top:8px;">Result: <span style="font-weight:700;color:${resultColor}">${escapeHtml(resultText)}</span></div>`;
      } else {
        html += `<div style="margin-top:6px;">Expected: <span style='font-weight:600'>${escapeHtml(String(q.answer===undefined?JSON.stringify(q.choices||''): q.answer))}</span></div>`;
        html += `<div style="margin-top:6px;">Student answer: <span style='font-weight:600'>${escapeHtml(String(studentResp===undefined?'(no response)': studentResp))}</span></div>`;
        html += `<div style="margin-top:6px;color:${resultColor};font-weight:700">${escapeHtml(resultText)}</div>`;
      }
      html += `</div>`;
    });
  }
  html += `</div>`;
  return html;
}

// Delegated handler for inline answers button
document.addEventListener('click', async (e)=>{
  const btn = e.target.closest && e.target.closest('[data-inline-answers]');
  if(!btn) return;
  try{
    const val = btn.getAttribute('data-inline-answers'); // sid|chapter|attemptIndex
  const parts = val ? val.split('|') : [];
  const sid = parts[0], ch = parts[1], attemptKey = parts[2];
  console.debug('Answers clicked', { val, sid, ch, attemptKey });
    const tr = btn.closest('tr');
    if(!tr) console.debug('Answers handler: no enclosing <tr> found for button, continuing anyway');

    // fetch attempt object with logging (uses chapter-variant lookups internally)
    let fetched = null;
    console.debug('Answers handler: calling fetchAttemptObject', { sid, ch, attemptKey });
    try{
      fetched = await fetchAttemptObject(sid, ch, attemptKey);
      console.debug('fetchAttemptObject returned', { fetchedSummary: fetched ? { source: fetched.source, sampleKeys: fetched.obj ? Object.keys(fetched.obj).slice(0,5) : null } : null });
    }catch(err){
      console.error('fetchAttemptObject threw', err);
      showAttemptModal(`<div style="padding:12px"><h3>Error fetching attempt</h3><pre>${escapeHtml(err && err.message ? err.message : String(err))}</pre></div>`);
      return;
    }

    if(!fetched || !fetched.obj){
      console.debug('No fetched attempt object, showing fallback modal', { fetched });
      const fallbackHtml = `<div style="max-height:60vh;overflow:auto;padding:12px"><h3>No stored answers found</h3><p>There is no stored answers for this attempt.</p><pre>Request: ${escapeHtml(val)}</pre></div>`;
      try{ showAttemptModal(fallbackHtml); } catch(showErr){ console.error('showAttemptModal failed', showErr); alert('No stored answers and failed to open modal. See console.'); }
      return;
    }

    // We will show a modal that contains a dropdown of attempts so the instructor can select any attempt (by key)
    // load quiz questions, trying chapter variants if necessary
    let questions = {};
    try{
      const qFound = await findQuizQuestions(ch);
      if(qFound && qFound.snap && qFound.snap.exists()){
        questions = qFound.snap.val();
        console.debug('Loaded questions from', qFound.path);
      } else {
        const fallbackSnap = await rtdb.ref(`quizzes/${ch}/questions`).get();
        if(fallbackSnap && fallbackSnap.exists()){ questions = fallbackSnap.val(); console.debug('Loaded questions from fallback quizzes/${ch}/questions'); }
      }
    }catch(e){ console.debug('Failed to load quiz questions for chapter', ch, e); }
    const attempts = await getAttemptList(sid, ch);
  if(attempts.length === 0){ showAttemptModal(`<div style="padding:12px"><h3>No attempts found</h3><p>There are no attempts in QuizResults for this student/chapter.</p></div>`); return; }
    // build modal content with select
    let inner = `<div style="padding:8px;max-height:70vh;overflow:auto">`;
    inner += `<div style="display:flex;gap:8px;align-items:center;margin-bottom:10px"><label style="font-weight:700">Choose attempt:</label><select id="attemptPicker">`;
    attempts.forEach(a=>{ inner += `<option value="${escapeHtml(a.key)}">${escapeHtml(a.label)}</option>`; });
    inner += `</select></div>`;
    // placeholder for questions content
    inner += `<div id="attemptQuestionsContainer">Loading...</div>`;
    inner += `</div>`;
    showAttemptModal(inner);
    // load first attempt
    const picker = document.getElementById('attemptPicker');
    const containerEl = document.getElementById('attemptQuestionsContainer');
    async function loadByKey(key){
      containerEl.innerHTML = 'Loading attempt...';
      try{
        const fetchedAttempt = await fetchAttemptObject(sid, ch, key);
        if(!fetchedAttempt || !fetchedAttempt.obj){ containerEl.innerHTML = `<div style="color:#a23">Attempt data not found for key: ${escapeHtml(key)}</div>`; return; }
        const html = renderAttemptQuestionsHtml(fetchedAttempt.obj, fetchedAttempt.source, questions);
        containerEl.innerHTML = html;
      }catch(e){ containerEl.innerHTML = `<div style="color:#a23">Error loading attempt: ${escapeHtml(e && e.message? e.message : String(e))}</div>`; }
    }
    // initial load
    await loadByKey(attempts[0].key);
    // change handler
    picker.addEventListener('change', async (ev)=>{ await loadByKey(ev.target.value); });
  }catch(err){ console.error('Unhandled error in Answers handler', err); showAttemptModal(`<div style="padding:12px"><h3>Unhandled error</h3><pre>${escapeHtml(err && err.message ? err.message : String(err))}</pre></div>`); }
});

// Simple attempt modal implementation
function showAttemptModal(innerHtml){
  console.debug('showAttemptModal called, innerHtml length=', innerHtml ? innerHtml.length : 0);
  let modal = document.getElementById('attemptDetailsModal');
  if(!modal){
    modal = document.createElement('div'); modal.id='attemptDetailsModal'; modal.className='modal';
  const content = document.createElement('div'); content.className='modal-content'; content.style.maxWidth='900px';
  // limit modal height and keep its content scrollable when large
  content.style.maxHeight = '80vh';
  content.style.overflow = 'hidden';
    content.innerHTML = `
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:12px;">
        <div style="display:flex;flex-direction:column;">
          <div style="display:flex;align-items:center;gap:12px"><h3 id="attemptModalTitle">Attempt Details</h3><span id="wrongSummary" style="color:#d33;font-weight:700"></span></div>
          <div style="font-size:13px;color:#666" id="attemptModalSub"></div>
        </div>
        <div style="display:flex;gap:8px;align-items:center;">
          <button id="filterWrongBtn" class="btn" style="background:#fff;border:1px solid #ccc;padding:6px 10px;border-radius:6px;">Show Wrong Only</button>
          <button style="background:#fff;border:1px solid #ccc;padding:6px 10px;border-radius:6px;" id="closeAttemptModal">Close</button>
        </div>
      </div>
      <div id="attemptDetailsContent"></div>`;
    modal.appendChild(content); document.body.appendChild(modal);
    // Attach handlers after appending
    try{ document.getElementById('closeAttemptModal').addEventListener('click', ()=>{ modal.style.display='none'; }); }catch(e){ console.error('attach closeAttemptModal failed', e); }
    try{ document.getElementById('filterWrongBtn').addEventListener('click', ()=>{
      const btn = document.getElementById('filterWrongBtn'); const showing = btn.dataset.showing === '1';
      btn.dataset.showing = showing ? '0' : '1'; btn.textContent = showing ? 'Show Wrong Only' : 'Show All';
      document.querySelectorAll('#attemptDetailsContent .question-result').forEach(el=>{
        if(showing){ el.style.display='block'; } else { if(el.classList.contains('wrong')) el.style.display='block'; else el.style.display='none'; }
      });
    }); }catch(e){ console.error('attach filterWrongBtn failed', e); }
  }
  // ensure modal is attached to body and visible with inline styles in case external CSS hides it
  if(!modal.parentNode || modal.parentNode !== document.body) document.body.appendChild(modal);
  // Force important inline styles to override page CSS
  modal.style.setProperty('position','fixed','important');
  modal.style.setProperty('left','0','important'); modal.style.setProperty('top','0','important'); modal.style.setProperty('width','100%','important'); modal.style.setProperty('height','100%','important');
  modal.style.setProperty('display','flex','important'); modal.style.setProperty('align-items','center','important'); modal.style.setProperty('justify-content','center','important');
  modal.style.setProperty('z-index','2147483647','important');
  modal.style.setProperty('background','rgba(0,0,0,0.65)','important');
  // ensure content container exists and make it scrollable (so long answers don't expand modal)
  let contentEl = modal.querySelector('#attemptDetailsContent');
  if(!contentEl){
    const cont = document.createElement('div'); cont.id='attemptDetailsContent';
    const wrapper = modal.querySelector('.modal-content') || modal.firstChild;
    if(wrapper) wrapper.appendChild(cont); contentEl = cont;
  }
  // set scrollable area inside modal
  contentEl.style.maxHeight = 'calc(80vh - 120px)';
  contentEl.style.overflowY = 'auto';
  contentEl.style.padding = contentEl.style.padding || '8px';
  try{
    contentEl.innerHTML = innerHtml;
  }catch(e){ console.error('Failed to set attemptDetailsContent.innerHTML', e); }
  // update wrong count and default state
  const modalEl = document.getElementById('attemptDetailsModal');
  const wrongEls = modalEl ? modalEl.querySelectorAll('.question-result.wrong') : [];
  const wrongSummary = document.getElementById('wrongSummary');
  wrongSummary.textContent = wrongEls.length ? `Wrong: ${wrongEls.length}` : '';
  // reset filter button
  const filterBtn = document.getElementById('filterWrongBtn'); if(filterBtn){ filterBtn.dataset.showing='0'; filterBtn.textContent='Show Wrong Only'; }
  // focus for accessibility after a tiny delay
  setTimeout(()=>{
    try{ const first = modal.querySelector('.modal-content'); if(first) first.focus(); }catch(e){}
  },50);
}

// Modal helpers
function openQuestionModal(ch){ currentChapter=ch; editingQuestionId=null; resetModal(); document.getElementById('questionModal').style.display='flex'; }
function closeQuestionModal(){ document.getElementById('questionModal').style.display='none'; }
function toggleQuestionType(){ const t=document.getElementById('questionType').value; document.getElementById('mcFields').style.display=t==='multipleChoice'?'block':'none'; document.getElementById('idFields').style.display=t==='identification'?'block':'none'; document.getElementById('tfFields').style.display=t==='true_false'?'block':'none'; }
function resetModal(){ document.getElementById('modalTitle').innerText="Add New Question"; document.getElementById('questionText').value=""; document.getElementById('questionType').value="multipleChoice"; toggleQuestionType(); ["0","1","2","3"].forEach(i=>{document.getElementById('optionText'+i).value=""; document.querySelector(`input[name='correctOption'][value='${i}']`).checked=false;}); document.getElementById('identificationAnswer').value=""; document.querySelectorAll("input[name='trueFalseAnswer']").forEach(r=>r.checked=false); }

// Reset extended settings
function resetExtendedSettings(){
  document.getElementById('optCaseSensitive').checked = false;
  document.getElementById('optOrderMatters').checked = false;
  document.getElementById('optRandomizeOptions').checked = false;
  document.getElementById('idCaseSensitive').checked = false;
  document.getElementById('idOrderMatters').checked = false;
}

// Save question
async function saveQuestion(){
  const text=document.getElementById('questionText').value.trim();
  const type=document.getElementById('questionType').value;
  if(!text){alert("Enter question"); return;}
  let payload={question:text, showAnswer:true};
  if(type==="multipleChoice"){
    const opts=[0,1,2,3].map(i=>document.getElementById('optionText'+i).value.trim());
    const checked=document.querySelector("input[name='correctOption']:checked");
    if(!checked){alert("Select correct option"); return;}
    if(opts.some(o=>!o)){alert("Fill all options"); return;}
    payload.choices=opts; payload.answer=opts[checked.value]; payload.type="multiple_choice";
    // extended options
    payload.caseSensitive = !!document.getElementById('optCaseSensitive').checked;
    payload.orderMatters = !!document.getElementById('optOrderMatters').checked;
    payload.randomizeOptions = !!document.getElementById('optRandomizeOptions').checked;
  } else if(type==="identification"){
    const ans=document.getElementById('identificationAnswer').value.trim();
    if(!ans){alert("Enter answer"); return;}
    payload.answer=ans; payload.type="identification";
    payload.caseSensitive = !!document.getElementById('idCaseSensitive').checked;
    payload.orderMatters = !!document.getElementById('idOrderMatters').checked;
  } else if(type==="true_false"){
    const checked=document.querySelector("input[name='trueFalseAnswer']:checked");
    if(!checked){alert("Select True/False"); return;}
    payload.answer=checked.value; payload.type="true_false";
  }

  // Save to whichever quiz questions path exists for the chapter, or default to canonical path
  try{
    const qFound = await findQuizQuestions(currentChapter);
    if(qFound && qFound.snap && qFound.snap.exists()){
      const base = qFound.path;
      if(editingQuestionId){ await rtdb.ref(`${base}/${editingQuestionId}`).set(payload); alert('Question updated!'); }
      else { const nextIndex = await getNextQuestionIndex(currentChapter); payload.questionIndex = nextIndex; await rtdb.ref(`${base}/${nextIndex}`).set(payload); alert('Question added!'); }
    } else {
      const base = `quizzes/${currentChapter}/questions`;
      if(editingQuestionId){ await rtdb.ref(`${base}/${editingQuestionId}`).set(payload); alert('Question updated!'); }
      else { const nextIndex = await getNextQuestionIndex(currentChapter); payload.questionIndex = nextIndex; await rtdb.ref(`${base}/${nextIndex}`).set(payload); alert('Question added!'); }
    }
  }catch(e){ console.error('Failed saving question', e); alert('Failed to save question: '+ (e && e.message? e.message : String(e))); }
  closeQuestionModal();
  loadChapterQuestions(currentChapter);
}

// Edit
async function openEditModal(ch,id){
  currentChapter=ch; editingQuestionId=id; resetModal();
  // try to locate the question across chapter variants
  const qFound = await findQuizQuestions(ch);
  let q = null;
  if(qFound && qFound.snap && qFound.snap.exists()){
    const childSnap = qFound.snap.child(id);
    if(childSnap && childSnap.exists()) q = childSnap.val();
  }
  if(!q){
    const snap = await rtdb.ref(`quizzes/${ch}/questions/${id}`).get();
    if(!snap.exists()){alert("Missing"); return;} q = snap.val();
  }
  document.getElementById('modalTitle').innerText="Edit Question";
  document.getElementById('questionText').value=q.question;
  document.getElementById('questionType').value=q.type==="multiple_choice"?"multipleChoice":q.type;
  toggleQuestionType();
  if(q.type==="multiple_choice"){
    q.choices.forEach((opt,i)=>{document.getElementById('optionText'+i).value=opt; if(opt===q.answer) document.querySelector(`input[name='correctOption'][value='${i}']`).checked=true;});
    // populate extended settings
    document.getElementById('optCaseSensitive').checked = !!q.caseSensitive;
    document.getElementById('optOrderMatters').checked = !!q.orderMatters;
    document.getElementById('optRandomizeOptions').checked = !!q.randomizeOptions;
  } else if(q.type==="identification"){ document.getElementById('identificationAnswer').value=q.answer; }
  else if(q.type==="true_false"){ document.querySelector(`input[name='trueFalseAnswer'][value='${q.answer}']`).checked=true; }
  document.getElementById('questionModal').style.display='flex';
}

// Delete
async function deleteQuestion(ch,id){
    if(confirm("Delete this question?")){
    // try to delete from the variant path if found, else fallback to the canonical path
    const qFound = await findQuizQuestions(ch);
    if(qFound && qFound.snap && qFound.snap.exists() && qFound.snap.child(id).exists()){
      await rtdb.ref(`${qFound.path}/${id}`).remove();
    } else {
      await rtdb.ref(`quizzes/${ch}/questions/${id}`).remove();
    }
    loadChapterQuestions(ch);
  }
}

// Wire test modal button after DOM ready
document.addEventListener('DOMContentLoaded', ()=>{
  try{
    // testModalBtn removed - no-op
  }catch(e){ console.error('Failed to attach Test Modal handler', e); }
});

// --- Section Answers Modal ---
// modal markup (injected once)
if(!document.getElementById('sectionAnswersModal')){
  const sModal = document.createElement('div'); sModal.id = 'sectionAnswersModal'; sModal.className = 'modal';
  sModal.style.display='none';
  sModal.innerHTML = `
    <div class="modal-content" style="max-width:1000px;">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:12px;">
        <div style="display:flex;flex-direction:column;">
          <div style="display:flex;align-items:center;gap:12px"><h3 id="sectionAnswersTitle">Section Answers</h3></div>
          <div style="font-size:13px;color:#666" id="sectionAnswersSub">Select chapter and load answers</div>
        </div>
        <div style="display:flex;gap:8px;align-items:center;">
          <select id="sectionAnswersChapterSelect"></select>
          <button id="loadSectionAnswersBtn" class="btn" style="background:#fff;border:1px solid #ccc;padding:6px 10px;border-radius:6px;">Load</button>
          <button id="closeSectionAnswersModal" class="btn" style="background:#fff;border:1px solid #ccc;padding:6px 10px;border-radius:6px;">Close</button>
        </div>
      </div>
      <div id="sectionAnswersContent" style="max-height:70vh;overflow:auto;padding:8px;"></div>
    </div>`;
  document.body.appendChild(sModal);
  // attach handlers
  document.getElementById('closeSectionAnswersModal').addEventListener('click', ()=>{ sModal.style.display='none'; });
  document.getElementById('loadSectionAnswersBtn').addEventListener('click', async ()=>{
    const sel = document.getElementById('sectionAnswersChapterSelect'); const ch = sel.value; const sid = sModal.dataset.sectionId;
    if(!sid){ alert('No section selected'); return; }
    await loadSectionAnswers(sid, ch);
  });
}

// Populate chapter select helper
function populateSectionChapterSelect(){
  const sel = document.getElementById('sectionAnswersChapterSelect'); if(!sel) return;
  sel.innerHTML = '';
  Object.keys(chapterTitles).forEach(k => { const o = document.createElement('option'); o.value = k; o.textContent = chapterTitles[k]; sel.appendChild(o); });
}

// Open section answers modal for sectionId
async function openSectionAnswersModal(sectionId){
  const modal = document.getElementById('sectionAnswersModal'); if(!modal) return;
  modal.dataset.sectionId = sectionId;
  document.getElementById('sectionAnswersTitle').textContent = 'Section Answers: ' + (sectionsCache && sectionsCache[sectionId] ? (sectionsCache[sectionId].name || sectionsCache[sectionId].title || sectionId) : sectionId);
  populateSectionChapterSelect();
  // default to currentChapter if set, else first
  const sel = document.getElementById('sectionAnswersChapterSelect'); if(currentChapter) sel.value = currentChapter; else if(sel.options.length) sel.selectedIndex = 0;
  modal.style.display='flex'; modal.style.setProperty('position','fixed','important'); modal.style.setProperty('z-index','2147483647','important');
}

// Load and render section answers for a chapter (aggregates latest attempt per student for that chapter)
async function loadSectionAnswers(sectionId, ch){
  const content = document.getElementById('sectionAnswersContent'); if(!content) return; content.innerHTML = '<p>Loading...</p>';
  try{
    // find section students from cache or fetch
    let sectionObj = sectionsCache && sectionsCache[sectionId];
    if(!sectionObj){ const snap = await rtdb.ref(`SectionList/${sectionId}`).get(); if(snap.exists()) sectionObj = snap.val(); }
    const studentMap = sectionObj && sectionObj.students ? sectionObj.students : {};
    const uids = Object.keys(studentMap||{});
    if(uids.length===0){ content.innerHTML = '<p>No students in this section.</p>'; return; }

    // load chapter questions (variant-aware)
    const qFound = await findQuizQuestions(ch);
    const questions = (qFound && qFound.snap && qFound.snap.exists()) ? qFound.snap.val() : {};
    const qKeys = Object.keys(questions||{}).sort((a,b)=>Number(a)-Number(b));

    // For each student, fetch their latest attempt for this chapter (use getAttemptList to find attempts) and then fetch that attempt object
    const rowsHtml = [];
    for(const uid of uids){
      // get attempt list and pick the latest (getAttemptList already uses variants)
      const attempts = await getAttemptList(uid, ch);
      if(!attempts || attempts.length===0){ rowsHtml.push(`<div style="border-bottom:1px solid #eee;padding:8px"><div style="font-weight:700">${escapeHtml(uid)} — <span style='color:#666'>No attempts</span></div></div>`); continue; }
      const latest = attempts[0]; // attempts are sorted by date desc in getAttemptList
      const fetched = await fetchAttemptObject(uid, ch, latest.key);
      const attemptObj = fetched && fetched.obj ? fetched.obj : null;
      const source = fetched && fetched.source ? fetched.source : 'unknown';
      // render a compact per-student question list and diagnostics
      let html = `<div style="border-bottom:1px solid #eee;padding:8px"><div style="display:flex;justify-content:space-between;align-items:center"><div style="font-weight:700">${escapeHtml(uid)}</div><div style="color:#666">Score: ${escapeHtml(String(latest.score||''))} &nbsp; ${escapeHtml(latest.date||'')}</div></div>`;
      if(!attemptObj){ html += `<div style='color:#a23;margin-top:6px'>No attempt object found (source: ${escapeHtml(source)})</div></div>`; rowsHtml.push(html); continue; }

      // Build diagnostics header (trim raw JSON and per-question extraction diagnostics)
      const rawJson = JSON.stringify(attemptObj, null, 2) || '';
      const trimmedRaw = rawJson.length > 2000 ? rawJson.substring(0,2000) + '\n... (trimmed)' : rawJson;
      const diagLines = [];
      html += '<div style="margin-top:8px;display:flex;flex-direction:column;gap:6px">';
      for(const qk of qKeys){ const q = questions[qk]; const qIndex = Number(qk); const studentResp = extractStudentResponse(attemptObj, qk, qIndex); const normResp = normalizeStudentResponse(q, studentResp); const correct = evaluateAnswer(q, normResp); const isNoResponse = (normResp === undefined || normResp === null || (Array.isArray(normResp) && normResp.length===0) || (typeof normResp === 'string' && String(normResp).trim()===''));
        const status = isNoResponse ? 'No response' : (correct ? 'Correct' : 'Wrong');
        // add diagnostic line for this question
        let rawDisplayForDiag = (studentResp === undefined || studentResp === null) ? '(no response)' : (Array.isArray(studentResp) ? studentResp.join(', ') : String(studentResp));
        let normDisplayForDiag = (normResp === undefined || normResp === null) ? '(no response)' : (Array.isArray(normResp) ? normResp.join(', ') : String(normResp));
        diagLines.push(`Q${qk}: raw => ${rawDisplayForDiag}  | normalized => ${normDisplayForDiag}  | status => ${status}`);

        html += `<div style='display:flex;justify-content:space-between;align-items:center;padding:6px;border-radius:6px;background:${correct? '#f0fff4':'#fff6f6'};border:1px solid ${correct? '#dff0df':'#f0c0c0'}'>`;
        html += `<div style="flex:1"><strong>Q${escapeHtml(q.questionIndex || qk)}</strong>: ${escapeHtml((q.question||'').slice(0,120))}</div>`;
        html += `<div style="min-width:160px;text-align:right;color:${isNoResponse? '#666': (correct? '#2b8a3e':'#d33')};font-weight:700">${escapeHtml(status)}</div>`;
        html += `</div>`;
        if(!correct && !isNoResponse){ const rawDisplay = rawDisplayForDiag; const normDisplay = normDisplayForDiag; let correctText = '';
            if(q.type === 'multiple_choice'){ const choices = Array.isArray(q.choices)?q.choices: (q.choices?Object.values(q.choices):[]); const correctOptions = Array.isArray(q.answer)?q.answer: (q.answer!==undefined?[q.answer]:[]); const correctOptionsText = correctOptions.map(co=>{ if(co===undefined||co===null) return String(co); if(!isNaN(Number(co))){ const n=Number(co); const idx=(n===0?0:n-1); return choices[idx] !== undefined ? choices[idx] : String(co);} return String(co).trim().replace(/^[A-Za-z]\s*[\.\)]\s*/,'').replace(/^\d+\.\s*/,'').trim(); }).join(', '); correctText = correctOptionsText; }
            html += `<div style='margin-top:6px;padding:8px;background:#fff;border:1px dashed #eee;font-size:13px;color:#444'><div><b>Student response (raw):</b> ${escapeHtml(rawDisplay)}</div><div><b>Normalized:</b> ${escapeHtml(normDisplay)}</div><div style='margin-top:6px;color:#222'><b>Correct answer:</b> ${escapeHtml(correctText || String(q.answer||''))}</div></div>`;
        }
      }
      // append diagnostics details
      const diagText = 'Source: ' + source + '\n\n' + 'Raw attempt (trimmed):\n' + trimmedRaw + '\n\n' + 'Per-question extraction:\n' + diagLines.join('\n');
      html += `</div>`; // close question column
      html += `<div style='margin-top:8px'><details><summary style='cursor:pointer'>Debug info (show raw attempt & per-question extraction)</summary><pre style='white-space:pre-wrap;max-height:360px;overflow:auto;padding:8px;border:1px solid #eee;background:#fafafa'>${escapeHtml(diagText)}</pre></details></div>`;
      html += '</div>';
      rowsHtml.push(html);
    }

    content.innerHTML = `<div style="display:flex;flex-direction:column;gap:8px;">${rowsHtml.join('')}</div>`;
  }catch(err){ console.error('loadSectionAnswers failed', err); content.innerHTML = '<pre>'+escapeHtml(err && err.message?err.message:String(err))+'</pre>'; }
}

// delegated handler to open section answers for a section
document.addEventListener('click', (e)=>{
  const b = e.target.closest && e.target.closest('.view-section-answers-btn');
  if(!b) return; const sectionId = b.getAttribute('data-section-id'); if(!sectionId) return; openSectionAnswersModal(sectionId);
});




</script>
</body>
</html>
